import{o as Ee,c as Le,a as ze,l as De}from"./CrOvi5ql.js";import{o as W,j as rt,n as dn,V as R,aK as G,g as mn,f as ct,aJ as Bt,B as qn,w as On,aP as hn,R as $n,a0 as ke,a as Lt,b7 as xn,b8 as gn,K as wn,aA as An,aL as kn,bh as Xn,bi as Bn,M as Yn,b as Tn,i as Pn,J as bn}from"./B-1bL4-x.js";function di(e,t){return Ee(),Le("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor","aria-hidden":"true","data-slot":"icon"},[ze("path",{"fill-rule":"evenodd",d:"M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z","clip-rule":"evenodd"})])}function mi(e,t){return Ee(),Le("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor","aria-hidden":"true","data-slot":"icon"},[ze("path",{d:"M18 1.5c2.9 0 5.25 2.35 5.25 5.25v3.75a.75.75 0 0 1-1.5 0V6.75a3.75 3.75 0 1 0-7.5 0v3a3 3 0 0 1 3 3v6.75a3 3 0 0 1-3 3H3.75a3 3 0 0 1-3-3v-6.75a3 3 0 0 1 3-3h9v-3c0-2.9 2.35-5.25 5.25-5.25Z"})])}function hi(e,t){return Ee(),Le("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor","aria-hidden":"true","data-slot":"icon"},[ze("path",{"fill-rule":"evenodd",d:"M12.516 2.17a.75.75 0 0 0-1.032 0 11.209 11.209 0 0 1-7.877 3.08.75.75 0 0 0-.722.515A12.74 12.74 0 0 0 2.25 9.75c0 5.942 4.064 10.933 9.563 12.348a.749.749 0 0 0 .374 0c5.499-1.415 9.563-6.406 9.563-12.348 0-1.39-.223-2.73-.635-3.985a.75.75 0 0 0-.722-.516l-.143.001c-2.996 0-5.717-1.17-7.734-3.08Zm3.094 8.016a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z","clip-rule":"evenodd"})])}const Sn=0,Zn=1,Wn=2,Xe=2,fe=1.25,Ye=1,O=32,V=O/4,_n=65535,Qt=Math.pow(2,-24),Ue=Symbol("SKIP_GENERATION"),Mn={strategy:Sn,maxDepth:40,maxLeafSize:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null,[Ue]:!1};function z(e,t,n){return n.min.x=t[e],n.min.y=t[e+1],n.min.z=t[e+2],n.max.x=t[e+3],n.max.y=t[e+4],n.max.z=t[e+5],n}function Ze(e){let t=-1,n=-1/0;for(let s=0;s<3;s++){const i=e[s+3]-e[s];i>n&&(n=i,t=s)}return t}function We(e,t){t.set(e)}function je(e,t,n){let s,i;for(let c=0;c<3;c++){const o=c+3;s=e[c],i=t[c],n[c]=s<i?s:i,s=e[o],i=t[o],n[o]=s>i?s:i}}function Dt(e,t,n){for(let s=0;s<3;s++){const i=t[e+2*s],c=t[e+2*s+1],o=i-c,a=i+c;o<n[s]&&(n[s]=o),a>n[s+3]&&(n[s+3]=a)}}function bt(e){const t=e[3]-e[0],n=e[4]-e[1],s=e[5]-e[2];return 2*(t*n+n*s+s*t)}function F(e,t){return t[e+15]===_n}function $(e,t){return t[e+6]}function k(e,t){return t[e+14]}function N(e){return e+V}function H(e,t){const n=t[e+6];return e+n*V}function Ve(e,t){return t[e+7]}function pe(e,t,n,s,i){let c=1/0,o=1/0,a=1/0,r=-1/0,y=-1/0,f=-1/0,u=1/0,l=1/0,p=1/0,g=-1/0,A=-1/0,w=-1/0;const B=e.offset||0;for(let d=(t-B)*6,h=(t+n-B)*6;d<h;d+=6){const m=e[d+0],x=e[d+1],S=m-x,T=m+x;S<c&&(c=S),T>r&&(r=T),m<u&&(u=m),m>g&&(g=m);const _=e[d+2],M=e[d+3],b=_-M,v=_+M;b<o&&(o=b),v>y&&(y=v),_<l&&(l=_),_>A&&(A=_);const P=e[d+4],I=e[d+5],C=P-I,E=P+I;C<a&&(a=C),E>f&&(f=E),P<p&&(p=P),P>w&&(w=P)}s[0]=c,s[1]=o,s[2]=a,s[3]=r,s[4]=y,s[5]=f,i[0]=u,i[1]=l,i[2]=p,i[3]=g,i[4]=A,i[5]=w}const Q=32,jn=(e,t)=>e.candidate-t.candidate,et=new Array(Q).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ut=new Float32Array(6);function Kn(e,t,n,s,i,c){let o=-1,a=0;if(c===Sn)o=Ze(t),o!==-1&&(a=(t[o]+t[o+3])/2);else if(c===Zn)o=Ze(e),o!==-1&&(a=Qn(n,s,i,o));else if(c===Wn){const r=bt(e);let y=fe*i;const f=n.offset||0,u=(s-f)*6,l=(s+i-f)*6;for(let p=0;p<3;p++){const g=t[p],B=(t[p+3]-g)/Q;if(i<Q/4){const d=[...et];d.length=i;let h=0;for(let x=u;x<l;x+=6,h++){const S=d[h];S.candidate=n[x+2*p],S.count=0;const{bounds:T,leftCacheBounds:_,rightCacheBounds:M}=S;for(let b=0;b<3;b++)M[b]=1/0,M[b+3]=-1/0,_[b]=1/0,_[b+3]=-1/0,T[b]=1/0,T[b+3]=-1/0;Dt(x,n,T)}d.sort(jn);let m=i;for(let x=0;x<m;x++){const S=d[x];for(;x+1<m&&d[x+1].candidate===S.candidate;)d.splice(x+1,1),m--}for(let x=u;x<l;x+=6){const S=n[x+2*p];for(let T=0;T<m;T++){const _=d[T];S>=_.candidate?Dt(x,n,_.rightCacheBounds):(Dt(x,n,_.leftCacheBounds),_.count++)}}for(let x=0;x<m;x++){const S=d[x],T=S.count,_=i-S.count,M=S.leftCacheBounds,b=S.rightCacheBounds;let v=0;T!==0&&(v=bt(M)/r);let P=0;_!==0&&(P=bt(b)/r);const I=Ye+fe*(v*T+P*_);I<y&&(o=p,y=I,a=S.candidate)}}else{for(let m=0;m<Q;m++){const x=et[m];x.count=0,x.candidate=g+B+m*B;const S=x.bounds;for(let T=0;T<3;T++)S[T]=1/0,S[T+3]=-1/0}for(let m=u;m<l;m+=6){let T=~~((n[m+2*p]-g)/B);T>=Q&&(T=Q-1);const _=et[T];_.count++,Dt(m,n,_.bounds)}const d=et[Q-1];We(d.bounds,d.rightCacheBounds);for(let m=Q-2;m>=0;m--){const x=et[m],S=et[m+1];je(x.bounds,S.rightCacheBounds,x.rightCacheBounds)}let h=0;for(let m=0;m<Q-1;m++){const x=et[m],S=x.count,T=x.bounds,M=et[m+1].rightCacheBounds;S!==0&&(h===0?We(T,Ut):je(T,Ut,Ut)),h+=S;let b=0,v=0;h!==0&&(b=bt(Ut)/r);const P=i-h;P!==0&&(v=bt(M)/r);const I=Ye+fe*(b*h+v*P);I<y&&(o=p,y=I,a=x.candidate)}}}}return{axis:o,pos:a}}function Qn(e,t,n,s){let i=0;const c=e.offset;for(let o=t,a=t+n;o<a;o++)i+=e[(o-c)*6+s*2];return i/n}class ye{constructor(){this.boundingData=new Float32Array(6)}}function Jn(e,t,n,s,i,c){let o=s,a=s+i-1;const r=c.pos,y=c.axis*2,f=n.offset||0;for(;;){for(;o<=a&&n[(o-f)*6+y]<r;)o++;for(;o<=a&&n[(a-f)*6+y]>=r;)a--;if(o<a){for(let u=0;u<t;u++){let l=e[o*t+u];e[o*t+u]=e[a*t+u],e[a*t+u]=l}for(let u=0;u<6;u++){const l=o-f,p=a-f,g=n[l*6+u];n[l*6+u]=n[p*6+u],n[p*6+u]=g}o++,a--}else return o}}let vn,Jt,Te,In;const Gn=Math.pow(2,32);function Pe(e){return"count"in e?1:1+Pe(e.left)+Pe(e.right)}function ts(e,t,n){return vn=new Float32Array(n),Jt=new Uint32Array(n),Te=new Uint16Array(n),In=new Uint8Array(n),be(e,t)}function be(e,t){const n=e/4,s=e/2,i="count"in t,c=t.boundingData;for(let o=0;o<6;o++)vn[n+o]=c[o];if(i)return t.buffer?(In.set(new Uint8Array(t.buffer),e),e+t.buffer.byteLength):(Jt[n+6]=t.offset,Te[s+14]=t.count,Te[s+15]=_n,e+O);{const{left:o,right:a,splitAxis:r}=t,y=e+O;let f=be(y,o);const u=e/O,p=f/O-u;if(p>Gn)throw new Error("MeshBVH: Cannot store relative child node offset greater than 32 bits.");return Jt[n+6]=p,Jt[n+7]=r,be(f,a)}}function es(e,t,n,s,i,c){const{maxDepth:o,verbose:a,maxLeafSize:r,strategy:y,onProgress:f}=i,u=e.primitiveBuffer,l=e.primitiveBufferStride,p=new Float32Array(6);let g=!1;const A=new ye;return pe(t,n,s,A.boundingData,p),B(A,n,s,p),A;function w(d){f&&f((d-c.offset)/c.count)}function B(d,h,m,x=null,S=0){if(!g&&S>=o&&(g=!0),m<=r||S>=o)return w(h+m),d.offset=h,d.count=m,d;const T=Kn(d.boundingData,x,t,h,m,y);if(T.axis===-1)return w(h+m),d.offset=h,d.count=m,d;const _=Jn(u,l,t,h,m,T);if(_===h||_===h+m)w(h+m),d.offset=h,d.count=m;else{d.splitAxis=T.axis;const M=new ye,b=h,v=_-h;d.left=M,pe(t,b,v,M.boundingData,p),B(M,b,v,p,S+1);const P=new ye,I=_,C=m-v;d.right=P,pe(t,I,C,P.boundingData,p),B(P,I,C,p,S+1)}return d}}function ns(e,t){const n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=e.getRootRanges(t.range),i=s[0],c=s[s.length-1],o={offset:i.offset,count:c.offset+c.count-i.offset},a=new Float32Array(6*o.count);a.offset=o.offset,e.computePrimitiveBounds(o.offset,o.count,a),e._roots=s.map(r=>{const y=es(e,a,r.offset,r.count,t,o),f=Pe(y),u=new n(O*f);return ts(0,y,u),u})}class Fe{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class ss{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let n=null;this.setBuffer=s=>{n&&t.push(n),n=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{n=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const L=new ss;let it,Pt;const yt=[],Vt=new Fe(()=>new W);function is(e,t,n,s,i,c){it=Vt.getPrimitive(),Pt=Vt.getPrimitive(),yt.push(it,Pt),L.setBuffer(e._roots[t]);const o=Se(0,e.geometry,n,s,i,c);L.clearBuffer(),Vt.releasePrimitive(it),Vt.releasePrimitive(Pt),yt.pop(),yt.pop();const a=yt.length;return a>0&&(Pt=yt[a-1],it=yt[a-2]),o}function Se(e,t,n,s,i=null,c=0,o=0){const{float32Array:a,uint16Array:r,uint32Array:y}=L;let f=e*2;if(F(f,r)){const l=$(e,y),p=k(f,r);return z(e,a,it),s(l,p,!1,o,c+e/V,it)}else{let b=function(P){const{uint16Array:I,uint32Array:C}=L;let E=P*2;for(;!F(E,I);)P=N(P),E=P*2;return $(P,C)},v=function(P){const{uint16Array:I,uint32Array:C}=L;let E=P*2;for(;!F(E,I);)P=H(P,C),E=P*2;return $(P,C)+k(E,I)};const l=N(e),p=H(e,y);let g=l,A=p,w,B,d,h;if(i&&(d=it,h=Pt,z(g,a,d),z(A,a,h),w=i(d),B=i(h),B<w)){g=p,A=l;const P=w;w=B,B=P,d=h}d||(d=it,z(g,a,d));const m=F(g*2,r),x=n(d,m,w,o+1,c+g/V);let S;if(x===Xe){const P=b(g),C=v(g)-P;S=s(P,C,!0,o+1,c+g/V,d)}else S=x&&Se(g,t,n,s,i,c,o+1);if(S)return!0;h=Pt,z(A,a,h);const T=F(A*2,r),_=n(h,T,B,o+1,c+A/V);let M;if(_===Xe){const P=b(A),C=v(A)-P;M=s(P,C,!0,o+1,c+A/V,h)}else M=_&&Se(A,t,n,s,i,c,o+1);return!!M}}const Rt=new L.constructor,ee=new L.constructor,st=new Fe(()=>new W),dt=new W,mt=new W,de=new W,me=new W;let he=!1;function os(e,t,n,s){if(he)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");he=!0;const i=e._roots,c=t._roots;let o,a=0,r=0;const y=new rt().copy(n).invert();for(let f=0,u=i.length;f<u;f++){Rt.setBuffer(i[f]),r=0;const l=st.getPrimitive();z(0,Rt.float32Array,l),l.applyMatrix4(y);for(let p=0,g=c.length;p<g&&(ee.setBuffer(c[p]),o=j(0,0,n,y,s,a,r,0,0,l),ee.clearBuffer(),r+=c[p].byteLength/O,!o);p++);if(st.releasePrimitive(l),Rt.clearBuffer(),a+=i[f].byteLength/O,o)break}return he=!1,o}function j(e,t,n,s,i,c=0,o=0,a=0,r=0,y=null,f=!1){let u,l;f?(u=ee,l=Rt):(u=Rt,l=ee);const p=u.float32Array,g=u.uint32Array,A=u.uint16Array,w=l.float32Array,B=l.uint32Array,d=l.uint16Array,h=e*2,m=t*2,x=F(h,A),S=F(m,d);let T=!1;if(S&&x)f?T=i($(t,B),k(t*2,d),$(e,g),k(e*2,A),r,o+t/V,a,c+e/V):T=i($(e,g),k(e*2,A),$(t,B),k(t*2,d),a,c+e/V,r,o+t/V);else if(S){const _=st.getPrimitive();z(t,w,_),_.applyMatrix4(n);const M=N(e),b=H(e,g);z(M,p,dt),z(b,p,mt);const v=_.intersectsBox(dt),P=_.intersectsBox(mt);T=v&&j(t,M,s,n,i,o,c,r,a+1,_,!f)||P&&j(t,b,s,n,i,o,c,r,a+1,_,!f),st.releasePrimitive(_)}else{const _=N(t),M=H(t,B);z(_,w,de),z(M,w,me);const b=y.intersectsBox(de),v=y.intersectsBox(me);if(b&&v)T=j(e,_,n,s,i,c,o,a,r+1,y,f)||j(e,M,n,s,i,c,o,a,r+1,y,f);else if(b)if(x)T=j(e,_,n,s,i,c,o,a,r+1,y,f);else{const P=st.getPrimitive();P.copy(de).applyMatrix4(n);const I=N(e),C=H(e,g);z(I,p,dt),z(C,p,mt);const E=P.intersectsBox(dt),D=P.intersectsBox(mt);T=E&&j(_,I,s,n,i,o,c,r,a+1,P,!f)||D&&j(_,C,s,n,i,o,c,r,a+1,P,!f),st.releasePrimitive(P)}else if(v)if(x)T=j(e,M,n,s,i,c,o,a,r+1,y,f);else{const P=st.getPrimitive();P.copy(me).applyMatrix4(n);const I=N(e),C=H(e,g);z(I,p,dt),z(C,p,mt);const E=P.intersectsBox(dt),D=P.intersectsBox(mt);T=E&&j(M,I,s,n,i,o,c,r,a+1,P,!f)||D&&j(M,C,s,n,i,o,c,r,a+1,P,!f),st.releasePrimitive(P)}}return T}const Ke=new W,ht=new Float32Array(6);class rs{constructor(){this._roots=null,this.primitiveBuffer=null,this.primitiveBufferStride=null}init(t){t={...Mn,...t},ns(this,t)}getRootRanges(){throw new Error("BVH: getRootRanges() not implemented")}writePrimitiveBounds(){throw new Error("BVH: writePrimitiveBounds() not implemented")}writePrimitiveRangeBounds(t,n,s,i){let c=1/0,o=1/0,a=1/0,r=-1/0,y=-1/0,f=-1/0;for(let u=t,l=t+n;u<l;u++){this.writePrimitiveBounds(u,ht,0);const[p,g,A,w,B,d]=ht;p<c&&(c=p),w>r&&(r=w),g<o&&(o=g),B>y&&(y=B),A<a&&(a=A),d>f&&(f=d)}return s[i+0]=c,s[i+1]=o,s[i+2]=a,s[i+3]=r,s[i+4]=y,s[i+5]=f,s}computePrimitiveBounds(t,n,s){const i=s.offset||0;for(let c=t,o=t+n;c<o;c++){this.writePrimitiveBounds(c,ht,0);const[a,r,y,f,u,l]=ht,p=(a+f)/2,g=(r+u)/2,A=(y+l)/2,w=(f-a)/2,B=(u-r)/2,d=(l-y)/2,h=(c-i)*6;s[h+0]=p,s[h+1]=w+(Math.abs(p)+w)*Qt,s[h+2]=g,s[h+3]=B+(Math.abs(g)+B)*Qt,s[h+4]=A,s[h+5]=d+(Math.abs(A)+d)*Qt}return s}shiftPrimitiveOffsets(t){const n=this._indirectBuffer;if(n)for(let s=0,i=n.length;s<i;s++)n[s]+=t;else{const s=this._roots;for(let i=0;i<s.length;i++){const c=s[i],o=new Uint32Array(c),a=new Uint16Array(c),r=c.byteLength/O;for(let y=0;y<r;y++){const f=V*y,u=2*f;F(u,a)&&(o[f+6]+=t)}}}}traverse(t,n=0){const s=this._roots[n],i=new Uint32Array(s),c=new Uint16Array(s);o(0);function o(a,r=0){const y=a*2,f=F(y,c);if(f){const u=i[a+6],l=c[y+14];t(r,f,new Float32Array(s,a*4,6),u,l)}else{const u=N(a),l=H(a,i),p=Ve(a,i);t(r,f,new Float32Array(s,a*4,6),p)||(o(u,r+1),o(l,r+1))}}}refit(){const t=this._roots;for(let n=0,s=t.length;n<s;n++){const i=t[n],c=new Uint32Array(i),o=new Uint16Array(i),a=new Float32Array(i),r=i.byteLength/O;for(let y=r-1;y>=0;y--){const f=y*V,u=f*2;if(F(u,o)){const p=$(f,c),g=k(u,o);this.writePrimitiveRangeBounds(p,g,ht,0),a.set(ht,f)}else{const p=N(f),g=H(f,c);for(let A=0;A<3;A++){const w=a[p+A],B=a[p+A+3],d=a[g+A],h=a[g+A+3];a[f+A]=w<d?w:d,a[f+A+3]=B>h?B:h}}}}}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{z(0,new Float32Array(s),Ke),t.union(Ke)}),t}shapecast(t){let{boundsTraverseOrder:n,intersectsBounds:s,intersectsRange:i,intersectsPrimitive:c,scratchPrimitive:o,iterate:a}=t;if(i&&c){const u=i;i=(l,p,g,A,w)=>u(l,p,g,A,w)?!0:a(l,p,this,c,g,A,o)}else i||(c?i=(u,l,p,g)=>a(u,l,this,c,p,g,o):i=(u,l,p)=>p);let r=!1,y=0;const f=this._roots;for(let u=0,l=f.length;u<l;u++){const p=f[u];if(r=is(this,u,s,i,n,y),r)break;y+=p.byteLength/O}return r}bvhcast(t,n,s){let{intersectsRanges:i}=s;return os(this,t,n,i)}}function cs(){return typeof SharedArrayBuffer<"u"}function Ne(e){return e.index?e.index.count:e.attributes.position.count}function oe(e){return Ne(e)/3}function as(e,t=ArrayBuffer){return e>65535?new Uint32Array(new t(4*e)):new Uint16Array(new t(2*e))}function ls(e,t){if(!e.index){const n=e.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=as(n,s);e.setIndex(new dn(i,1));for(let c=0;c<n;c++)i[c]=c}}function us(e,t,n){const s=Ne(e)/n,i=t||e.drawRange,c=i.start/n,o=(i.start+i.count)/n,a=Math.max(0,c),r=Math.min(s,o)-a;return{offset:Math.floor(a),count:Math.floor(r)}}function fs(e,t){return e.groups.map(n=>({offset:n.start/t,count:n.count/t}))}function Qe(e,t,n){const s=us(e,t,n),i=fs(e,n);if(!i.length)return[s];const c=[],o=s.offset,a=s.offset+s.count,r=Ne(e)/n,y=[];for(const l of i){const{offset:p,count:g}=l,A=p,w=isFinite(g)?g:r-p,B=p+w;A<a&&B>o&&(y.push({pos:Math.max(o,A),isStart:!0}),y.push({pos:Math.min(a,B),isStart:!1}))}y.sort((l,p)=>l.pos!==p.pos?l.pos-p.pos:l.type==="end"?-1:1);let f=0,u=null;for(const l of y){const p=l.pos;f!==0&&p!==u&&c.push({offset:u,count:p-u}),f+=l.isStart?1:-1,u=p}return c}function ps(e,t){const n=e[e.length-1],s=n.offset+n.count>2**16,i=e.reduce((y,f)=>y+f.count,0),c=s?4:2,o=t?new SharedArrayBuffer(i*c):new ArrayBuffer(i*c),a=s?new Uint32Array(o):new Uint16Array(o);let r=0;for(let y=0;y<e.length;y++){const{offset:f,count:u}=e[y];for(let l=0;l<u;l++)a[r+l]=f+l;r+=u}return a}class ys extends rs{get indirect(){return!!this._indirectBuffer}get primitiveStride(){return null}get primitiveBufferStride(){return this.indirect?1:this.primitiveStride}set primitiveBufferStride(t){}get primitiveBuffer(){return this.indirect?this._indirectBuffer:this.geometry.index.array}set primitiveBuffer(t){}constructor(t,n={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("BVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("BVH: Only BufferGeometries are supported.");if(n.useSharedArrayBuffer&&!cs())throw new Error("BVH: SharedArrayBuffer is not available.");super(),this.geometry=t,this.resolvePrimitiveIndex=n.indirect?s=>this._indirectBuffer[s]:s=>s,this.primitiveBuffer=null,this.primitiveBufferStride=null,this._indirectBuffer=null,n={...Mn,...n},n[Ue]||this.init(n)}init(t){const{geometry:n,primitiveStride:s}=this;if(t.indirect){const i=Qe(n,t.range,s),c=ps(i,t.useSharedArrayBuffer);this._indirectBuffer=c}else ls(n,t);super.init(t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new W))}getRootRanges(t){return this.indirect?[{offset:0,count:this._indirectBuffer.length}]:Qe(this.geometry,t,this.primitiveStride)}raycastObject3D(){throw new Error("BVH: raycastObject3D() not implemented")}}class tt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,n){let s=1/0,i=-1/0;for(let c=0,o=t.length;c<o;c++){const r=t[c][n];s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}setFromPoints(t,n){let s=1/0,i=-1/0;for(let c=0,o=n.length;c<o;c++){const a=n[c],r=t.dot(a);s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}tt.prototype.setFromBox=(function(){const e=new R;return function(n,s){const i=s.min,c=s.max;let o=1/0,a=-1/0;for(let r=0;r<=1;r++)for(let y=0;y<=1;y++)for(let f=0;f<=1;f++){e.x=i.x*r+c.x*(1-r),e.y=i.y*y+c.y*(1-y),e.z=i.z*f+c.z*(1-f);const u=n.dot(e);o=Math.min(u,o),a=Math.max(u,a)}this.min=o,this.max=a}})();const ds=(function(){const e=new R,t=new R,n=new R;return function(i,c,o){const a=i.start,r=e,y=c.start,f=t;n.subVectors(a,y),e.subVectors(i.end,i.start),t.subVectors(c.end,c.start);const u=n.dot(f),l=f.dot(r),p=f.dot(f),g=n.dot(r),w=r.dot(r)*p-l*l;let B,d;w!==0?B=(u*l-g*p)/w:B=0,d=(u+B*l)/p,o.x=B,o.y=d}})(),He=(function(){const e=new ct,t=new R,n=new R;return function(i,c,o,a){ds(i,c,e);let r=e.x,y=e.y;if(r>=0&&r<=1&&y>=0&&y<=1){i.at(r,o),c.at(y,a);return}else if(r>=0&&r<=1){y<0?c.at(0,a):c.at(1,a),i.closestPointToPoint(a,!0,o);return}else if(y>=0&&y<=1){r<0?i.at(0,o):i.at(1,o),c.closestPointToPoint(o,!0,a);return}else{let f;r<0?f=i.start:f=i.end;let u;y<0?u=c.start:u=c.end;const l=t,p=n;if(i.closestPointToPoint(u,!0,t),c.closestPointToPoint(f,!0,n),l.distanceToSquared(u)<=p.distanceToSquared(f)){o.copy(l),a.copy(u);return}else{o.copy(f),a.copy(p);return}}}})(),ms=(function(){const e=new R,t=new R,n=new mn,s=new G;return function(c,o){const{radius:a,center:r}=c,{a:y,b:f,c:u}=o;if(s.start=y,s.end=f,s.closestPointToPoint(r,!0,e).distanceTo(r)<=a||(s.start=y,s.end=u,s.closestPointToPoint(r,!0,e).distanceTo(r)<=a)||(s.start=f,s.end=u,s.closestPointToPoint(r,!0,e).distanceTo(r)<=a))return!0;const A=o.getPlane(n);if(Math.abs(A.distanceToPoint(r))<=a){const B=A.projectPoint(r,t);if(o.containsPoint(B))return!0}return!1}})(),hs=["x","y","z"],J=1e-15,Je=J*J;function Y(e){return Math.abs(e)<J}class K extends Bt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new R),this.satBounds=new Array(4).fill().map(()=>new tt),this.points=[this.a,this.b,this.c],this.plane=new mn,this.isDegenerateIntoSegment=!1,this.isDegenerateIntoPoint=!1,this.degenerateSegment=new G,this.needsUpdate=!0}intersectsSphere(t){return ms(t,this)}update(){const t=this.a,n=this.b,s=this.c,i=this.points,c=this.satAxes,o=this.satBounds,a=c[0],r=o[0];this.getNormal(a),r.setFromPoints(a,i);const y=c[1],f=o[1];y.subVectors(t,n),f.setFromPoints(y,i);const u=c[2],l=o[2];u.subVectors(n,s),l.setFromPoints(u,i);const p=c[3],g=o[3];p.subVectors(s,t),g.setFromPoints(p,i);const A=y.length(),w=u.length(),B=p.length();this.isDegenerateIntoPoint=!1,this.isDegenerateIntoSegment=!1,A<J?w<J||B<J?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(t),this.degenerateSegment.end.copy(s)):w<J?B<J?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(n),this.degenerateSegment.end.copy(t)):B<J&&(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(s),this.degenerateSegment.end.copy(n)),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}K.prototype.closestPointToSegment=(function(){const e=new R,t=new R,n=new G;return function(i,c=null,o=null){const{start:a,end:r}=i,y=this.points;let f,u=1/0;for(let l=0;l<3;l++){const p=(l+1)%3;n.start.copy(y[l]),n.end.copy(y[p]),He(n,i,e,t),f=e.distanceToSquared(t),f<u&&(u=f,c&&c.copy(e),o&&o.copy(t))}return this.closestPointToPoint(a,e),f=a.distanceToSquared(e),f<u&&(u=f,c&&c.copy(e),o&&o.copy(a)),this.closestPointToPoint(r,e),f=r.distanceToSquared(e),f<u&&(u=f,c&&c.copy(e),o&&o.copy(r)),Math.sqrt(u)}})();K.prototype.intersectsTriangle=(function(){const e=new K,t=new tt,n=new tt,s=new R,i=new R,c=new R,o=new R,a=new G,r=new G,y=new R,f=new ct,u=new ct;function l(h,m,x,S){const T=s;!h.isDegenerateIntoPoint&&!h.isDegenerateIntoSegment?T.copy(h.plane.normal):T.copy(m.plane.normal);const _=h.satBounds,M=h.satAxes;for(let P=1;P<4;P++){const I=_[P],C=M[P];if(t.setFromPoints(C,m.points),I.isSeparated(t)||(o.copy(T).cross(C),t.setFromPoints(o,h.points),n.setFromPoints(o,m.points),t.isSeparated(n)))return!1}const b=m.satBounds,v=m.satAxes;for(let P=1;P<4;P++){const I=b[P],C=v[P];if(t.setFromPoints(C,h.points),I.isSeparated(t)||(o.crossVectors(T,C),t.setFromPoints(o,h.points),n.setFromPoints(o,m.points),t.isSeparated(n)))return!1}return x&&(x.start.set(0,0,0),x.end.set(0,0,0)),!0}function p(h,m,x,S,T,_,M,b,v,P,I){let C=M/(M-b);P.x=S+(T-S)*C,I.start.subVectors(m,h).multiplyScalar(C).add(h),C=M/(M-v),P.y=S+(_-S)*C,I.end.subVectors(x,h).multiplyScalar(C).add(h)}function g(h,m,x,S,T,_,M,b,v,P,I){if(T>0)p(h.c,h.a,h.b,S,m,x,v,M,b,P,I);else if(_>0)p(h.b,h.a,h.c,x,m,S,b,M,v,P,I);else if(b*v>0||M!=0)p(h.a,h.b,h.c,m,x,S,M,b,v,P,I);else if(b!=0)p(h.b,h.a,h.c,x,m,S,b,M,v,P,I);else if(v!=0)p(h.c,h.a,h.b,S,m,x,v,M,b,P,I);else return!0;return!1}function A(h,m,x,S){const T=m.degenerateSegment,_=h.plane.distanceToPoint(T.start),M=h.plane.distanceToPoint(T.end);return Y(_)?Y(M)?l(h,m,x,S):(x&&(x.start.copy(T.start),x.end.copy(T.start)),h.containsPoint(T.start)):Y(M)?(x&&(x.start.copy(T.end),x.end.copy(T.end)),h.containsPoint(T.end)):h.plane.intersectLine(T,s)!=null?(x&&(x.start.copy(s),x.end.copy(s)),h.containsPoint(s)):!1}function w(h,m,x){const S=m.a;return Y(h.plane.distanceToPoint(S))&&h.containsPoint(S)?(x&&(x.start.copy(S),x.end.copy(S)),!0):!1}function B(h,m,x){const S=h.degenerateSegment,T=m.a;return S.closestPointToPoint(T,!0,s),T.distanceToSquared(s)<Je?(x&&(x.start.copy(T),x.end.copy(T)),!0):!1}function d(h,m,x,S){if(h.isDegenerateIntoSegment)if(m.isDegenerateIntoSegment){const T=h.degenerateSegment,_=m.degenerateSegment,M=i,b=c;T.delta(M),_.delta(b);const v=s.subVectors(_.start,T.start),P=M.x*b.y-M.y*b.x;if(Y(P))return!1;const I=(v.x*b.y-v.y*b.x)/P,C=-(M.x*v.y-M.y*v.x)/P;if(I<0||I>1||C<0||C>1)return!1;const E=T.start.z+M.z*I,D=_.start.z+b.z*C;return Y(E-D)?(x&&(x.start.copy(T.start).addScaledVector(M,I),x.end.copy(T.start).addScaledVector(M,I)),!0):!1}else return m.isDegenerateIntoPoint?B(h,m,x):A(m,h,x,S);else{if(h.isDegenerateIntoPoint)return m.isDegenerateIntoPoint?m.a.distanceToSquared(h.a)<Je?(x&&(x.start.copy(h.a),x.end.copy(h.a)),!0):!1:m.isDegenerateIntoSegment?B(m,h,x):w(m,h,x);if(m.isDegenerateIntoPoint)return w(h,m,x);if(m.isDegenerateIntoSegment)return A(h,m,x,S)}}return function(m,x=null,S=!1){this.needsUpdate&&this.update(),m.isExtendedTriangle?m.needsUpdate&&m.update():(e.copy(m),e.update(),m=e);const T=d(this,m,x,S);if(T!==void 0)return T;const _=this.plane,M=m.plane;let b=M.distanceToPoint(this.a),v=M.distanceToPoint(this.b),P=M.distanceToPoint(this.c);Y(b)&&(b=0),Y(v)&&(v=0),Y(P)&&(P=0);const I=b*v,C=b*P;if(I>0&&C>0)return!1;let E=_.distanceToPoint(m.a),D=_.distanceToPoint(m.b),zt=_.distanceToPoint(m.c);Y(E)&&(E=0),Y(D)&&(D=0),Y(zt)&&(zt=0);const qe=E*D,Oe=E*zt;if(qe>0&&Oe>0)return!1;i.copy(_.normal),c.copy(M.normal);const ce=i.cross(c);let ae=0,le=Math.abs(ce.x);const $e=Math.abs(ce.y);$e>le&&(le=$e,ae=1),Math.abs(ce.z)>le&&(ae=2);const pt=hs[ae],Dn=this.a[pt],Un=this.b[pt],Vn=this.c[pt],Fn=m.a[pt],Nn=m.b[pt],Hn=m.c[pt];if(g(this,Dn,Un,Vn,I,C,b,v,P,f,a))return l(this,m,x,S);if(g(m,Fn,Nn,Hn,qe,Oe,E,D,zt,u,r))return l(this,m,x,S);if(f.y<f.x){const ue=f.y;f.y=f.x,f.x=ue,y.copy(a.start),a.start.copy(a.end),a.end.copy(y)}if(u.y<u.x){const ue=u.y;u.y=u.x,u.x=ue,y.copy(r.start),r.start.copy(r.end),r.end.copy(y)}return f.y<u.x||u.y<f.x?!1:(x&&(u.x>f.x?x.start.copy(r.start):x.start.copy(a.start),u.y<f.y?x.end.copy(r.end):x.end.copy(a.end)),!0)}})();K.prototype.distanceToPoint=(function(){const e=new R;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}})();K.prototype.distanceToTriangle=(function(){const e=new R,t=new R,n=["a","b","c"],s=new G,i=new G;return function(o,a=null,r=null){const y=a||r?s:null;if(this.intersectsTriangle(o,y))return(a||r)&&(a&&y.getCenter(a),r&&y.getCenter(r)),0;let f=1/0;for(let u=0;u<3;u++){let l;const p=n[u],g=o[p];this.closestPointToPoint(g,e),l=g.distanceToSquared(e),l<f&&(f=l,a&&a.copy(e),r&&r.copy(g));const A=this[p];o.closestPointToPoint(A,e),l=A.distanceToSquared(e),l<f&&(f=l,a&&a.copy(A),r&&r.copy(e))}for(let u=0;u<3;u++){const l=n[u],p=n[(u+1)%3];s.set(this[l],this[p]);for(let g=0;g<3;g++){const A=n[g],w=n[(g+1)%3];i.set(o[A],o[w]),He(s,i,e,t);const B=e.distanceToSquared(t);B<f&&(f=B,a&&a.copy(e),r&&r.copy(t))}}return Math.sqrt(f)}})();class X{constructor(t,n,s){this.isOrientedBox=!0,this.min=new R,this.max=new R,this.matrix=new rt,this.invMatrix=new rt,this.points=new Array(8).fill().map(()=>new R),this.satAxes=new Array(3).fill().map(()=>new R),this.satBounds=new Array(3).fill().map(()=>new tt),this.alignedSatBounds=new Array(3).fill().map(()=>new tt),this.needsUpdate=!1,t&&this.min.copy(t),n&&this.max.copy(n),s&&this.matrix.copy(s)}set(t,n,s){this.min.copy(t),this.max.copy(n),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}X.prototype.update=(function(){return function(){const t=this.matrix,n=this.min,s=this.max,i=this.points;for(let y=0;y<=1;y++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const l=1*y|2*f|4*u,p=i[l];p.x=y?s.x:n.x,p.y=f?s.y:n.y,p.z=u?s.z:n.z,p.applyMatrix4(t)}const c=this.satBounds,o=this.satAxes,a=i[0];for(let y=0;y<3;y++){const f=o[y],u=c[y],l=1<<y,p=i[l];f.subVectors(a,p),u.setFromPoints(f,i)}const r=this.alignedSatBounds;r[0].setFromPointsField(i,"x"),r[1].setFromPointsField(i,"y"),r[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();X.prototype.intersectsBox=(function(){const e=new tt;return function(n){this.needsUpdate&&this.update();const s=n.min,i=n.max,c=this.satBounds,o=this.satAxes,a=this.alignedSatBounds;if(e.min=s.x,e.max=i.x,a[0].isSeparated(e)||(e.min=s.y,e.max=i.y,a[1].isSeparated(e))||(e.min=s.z,e.max=i.z,a[2].isSeparated(e)))return!1;for(let r=0;r<3;r++){const y=o[r],f=c[r];if(e.setFromBox(y,n),f.isSeparated(e))return!1}return!0}})();X.prototype.intersectsTriangle=(function(){const e=new K,t=new Array(3),n=new tt,s=new tt,i=new R;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(e.copy(o),e.update(),o=e);const a=this.satBounds,r=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let l=0;l<3;l++){const p=a[l],g=r[l];if(n.setFromPoints(g,t),p.isSeparated(n))return!1}const y=o.satBounds,f=o.satAxes,u=this.points;for(let l=0;l<3;l++){const p=y[l],g=f[l];if(n.setFromPoints(g,u),p.isSeparated(n))return!1}for(let l=0;l<3;l++){const p=r[l];for(let g=0;g<4;g++){const A=f[g];if(i.crossVectors(p,A),n.setFromPoints(i,t),s.setFromPoints(i,u),n.isSeparated(s))return!1}}return!0}})();X.prototype.closestPointToPoint=(function(){return function(t,n){return this.needsUpdate&&this.update(),n.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),n}})();X.prototype.distanceToPoint=(function(){const e=new R;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}})();X.prototype.distanceToBox=(function(){const e=["x","y","z"],t=new Array(12).fill().map(()=>new G),n=new Array(12).fill().map(()=>new G),s=new R,i=new R;return function(o,a=0,r=null,y=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(r||y)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),r&&r.copy(s),y&&y.copy(i)),0;const f=a*a,u=o.min,l=o.max,p=this.points;let g=1/0;for(let w=0;w<8;w++){const B=p[w];i.copy(B).clamp(u,l);const d=B.distanceToSquared(i);if(d<g&&(g=d,r&&r.copy(B),y&&y.copy(i),d<f))return Math.sqrt(d)}let A=0;for(let w=0;w<3;w++)for(let B=0;B<=1;B++)for(let d=0;d<=1;d++){const h=(w+1)%3,m=(w+2)%3,x=B<<h|d<<m,S=1<<w|B<<h|d<<m,T=p[x],_=p[S];t[A].set(T,_);const b=e[w],v=e[h],P=e[m],I=n[A],C=I.start,E=I.end;C[b]=u[b],C[v]=B?u[v]:l[v],C[P]=d?u[P]:l[v],E[b]=l[b],E[v]=B?u[v]:l[v],E[P]=d?u[P]:l[v],A++}for(let w=0;w<=1;w++)for(let B=0;B<=1;B++)for(let d=0;d<=1;d++){i.x=w?l.x:u.x,i.y=B?l.y:u.y,i.z=d?l.z:u.z,this.closestPointToPoint(i,s);const h=i.distanceToSquared(s);if(h<g&&(g=h,r&&r.copy(s),y&&y.copy(i),h<f))return Math.sqrt(h)}for(let w=0;w<12;w++){const B=t[w];for(let d=0;d<12;d++){const h=n[d];He(B,h,s,i);const m=s.distanceToSquared(i);if(m<g&&(g=m,r&&r.copy(s),y&&y.copy(i),m<f))return Math.sqrt(m)}}return Math.sqrt(g)}})();class xs extends Fe{constructor(){super(()=>new K)}}const Z=new xs,St=new R,xe=new R;function gs(e,t,n={},s=0,i=1/0){const c=s*s,o=i*i;let a=1/0,r=null;if(e.shapecast({boundsTraverseOrder:f=>(St.copy(t).clamp(f.min,f.max),St.distanceToSquared(t)),intersectsBounds:(f,u,l)=>l<a&&l<o,intersectsTriangle:(f,u)=>{f.closestPointToPoint(t,St);const l=t.distanceToSquared(St);return l<a&&(xe.copy(St),a=l,r=u),l<c}}),a===1/0)return null;const y=Math.sqrt(a);return n.point?n.point.copy(xe):n.point=xe.clone(),n.distance=y,n.faceIndex=r,n}const Ft=parseInt(hn)>=169,ws=parseInt(hn)<=161,lt=new R,ut=new R,ft=new R,Nt=new ct,Ht=new ct,qt=new ct,Ge=new R,tn=new R,en=new R,_t=new R;function As(e,t,n,s,i,c,o,a){let r;if(c===qn?r=e.intersectTriangle(s,n,t,!0,i):r=e.intersectTriangle(t,n,s,c!==On,i),r===null)return null;const y=e.origin.distanceTo(i);return y<o||y>a?null:{distance:y,point:i.clone()}}function nn(e,t,n,s,i,c,o,a,r,y,f){lt.fromBufferAttribute(t,c),ut.fromBufferAttribute(t,o),ft.fromBufferAttribute(t,a);const u=As(e,lt,ut,ft,_t,r,y,f);if(u){if(s){Nt.fromBufferAttribute(s,c),Ht.fromBufferAttribute(s,o),qt.fromBufferAttribute(s,a),u.uv=new ct;const p=Bt.getInterpolation(_t,lt,ut,ft,Nt,Ht,qt,u.uv);Ft||(u.uv=p)}if(i){Nt.fromBufferAttribute(i,c),Ht.fromBufferAttribute(i,o),qt.fromBufferAttribute(i,a),u.uv1=new ct;const p=Bt.getInterpolation(_t,lt,ut,ft,Nt,Ht,qt,u.uv1);Ft||(u.uv1=p),ws&&(u.uv2=u.uv1)}if(n){Ge.fromBufferAttribute(n,c),tn.fromBufferAttribute(n,o),en.fromBufferAttribute(n,a),u.normal=new R;const p=Bt.getInterpolation(_t,lt,ut,ft,Ge,tn,en,u.normal);u.normal.dot(e.direction)>0&&u.normal.multiplyScalar(-1),Ft||(u.normal=p)}const l={a:c,b:o,c:a,normal:new R,materialIndex:0};if(Bt.getNormal(lt,ut,ft,l.normal),u.face=l,u.faceIndex=c,Ft){const p=new R;Bt.getBarycoord(_t,lt,ut,ft,p),u.barycoord=p}}return u}function sn(e){return e&&e.isMaterial?e.side:e}function re(e,t,n,s,i,c,o){const a=s*3;let r=a+0,y=a+1,f=a+2;const{index:u,groups:l}=e;e.index&&(r=u.getX(r),y=u.getX(y),f=u.getX(f));const{position:p,normal:g,uv:A,uv1:w}=e.attributes;if(Array.isArray(t)){const B=s*3;for(let d=0,h=l.length;d<h;d++){const{start:m,count:x,materialIndex:S}=l[d];if(B>=m&&B<m+x){const T=sn(t[S]),_=nn(n,p,g,A,w,r,y,f,T,c,o);if(_)if(_.faceIndex=s,_.face.materialIndex=S,i)i.push(_);else return _}}}else{const B=sn(t),d=nn(n,p,g,A,w,r,y,f,B,c,o);if(d)if(d.faceIndex=s,d.face.materialIndex=0,i)i.push(d);else return d}return null}function U(e,t,n,s){const i=e.a,c=e.b,o=e.c;let a=t,r=t+1,y=t+2;n&&(a=n.getX(a),r=n.getX(r),y=n.getX(y)),i.x=s.getX(a),i.y=s.getY(a),i.z=s.getZ(a),c.x=s.getX(r),c.y=s.getY(r),c.z=s.getZ(r),o.x=s.getX(y),o.y=s.getY(y),o.z=s.getZ(y)}function Bs(e,t,n,s,i,c,o,a){const{geometry:r,_indirectBuffer:y}=e;for(let f=s,u=s+i;f<u;f++)re(r,t,n,f,c,o,a)}function Ts(e,t,n,s,i,c,o){const{geometry:a,_indirectBuffer:r}=e;let y=1/0,f=null;for(let u=s,l=s+i;u<l;u++){let p;p=re(a,t,n,u,null,c,o),p&&p.distance<y&&(f=p,y=p.distance)}return f}function Ps(e,t,n,s,i,c,o){const{geometry:a}=n,{index:r}=a,y=a.attributes.position;for(let f=e,u=t+e;f<u;f++){let l;if(l=f,U(o,l*3,r,y),o.needsUpdate=!0,s(o,l,i,c))return!0}return!1}function bs(e,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,s=n.index?n.index.array:null,i=n.attributes.position;let c,o,a,r,y=0;const f=e._roots;for(let l=0,p=f.length;l<p;l++)c=f[l],o=new Uint32Array(c),a=new Uint16Array(c),r=new Float32Array(c),u(0,y),y+=c.byteLength;function u(l,p,g=!1){const A=l*2;if(F(A,a)){const w=$(l,o),B=k(A,a);let d=1/0,h=1/0,m=1/0,x=-1/0,S=-1/0,T=-1/0;for(let _=3*w,M=3*(w+B);_<M;_++){let b=s[_];const v=i.getX(b),P=i.getY(b),I=i.getZ(b);v<d&&(d=v),v>x&&(x=v),P<h&&(h=P),P>S&&(S=P),I<m&&(m=I),I>T&&(T=I)}return r[l+0]!==d||r[l+1]!==h||r[l+2]!==m||r[l+3]!==x||r[l+4]!==S||r[l+5]!==T?(r[l+0]=d,r[l+1]=h,r[l+2]=m,r[l+3]=x,r[l+4]=S,r[l+5]=T,!0):!1}else{const w=N(l),B=H(l,o);let d=g,h=!1,m=!1;if(t){if(!d){const b=w/V+p/O,v=B/V+p/O;h=t.has(b),m=t.has(v),d=!h&&!m}}else h=!0,m=!0;const x=d||h,S=d||m;let T=!1;x&&(T=u(w,p,d));let _=!1;S&&(_=u(B,p,d));const M=T||_;if(M)for(let b=0;b<3;b++){const v=w+b,P=B+b,I=r[v],C=r[v+3],E=r[P],D=r[P+3];r[l+b]=I<E?I:E,r[l+b+3]=C>D?C:D}return M}}}function at(e,t,n,s,i){let c,o,a,r,y,f;const u=1/n.direction.x,l=1/n.direction.y,p=1/n.direction.z,g=n.origin.x,A=n.origin.y,w=n.origin.z;let B=t[e],d=t[e+3],h=t[e+1],m=t[e+3+1],x=t[e+2],S=t[e+3+2];return u>=0?(c=(B-g)*u,o=(d-g)*u):(c=(d-g)*u,o=(B-g)*u),l>=0?(a=(h-A)*l,r=(m-A)*l):(a=(m-A)*l,r=(h-A)*l),c>r||a>o||((a>c||isNaN(c))&&(c=a),(r<o||isNaN(o))&&(o=r),p>=0?(y=(x-w)*p,f=(S-w)*p):(y=(S-w)*p,f=(x-w)*p),c>f||y>o)?!1:((y>c||c!==c)&&(c=y),(f<o||o!==o)&&(o=f),c<=i&&o>=s)}function Ss(e,t,n,s,i,c,o,a){const{geometry:r,_indirectBuffer:y}=e;for(let f=s,u=s+i;f<u;f++){let l=y?y[f]:f;re(r,t,n,l,c,o,a)}}function _s(e,t,n,s,i,c,o){const{geometry:a,_indirectBuffer:r}=e;let y=1/0,f=null;for(let u=s,l=s+i;u<l;u++){let p;p=re(a,t,n,r?r[u]:u,null,c,o),p&&p.distance<y&&(f=p,y=p.distance)}return f}function Ms(e,t,n,s,i,c,o){const{geometry:a}=n,{index:r}=a,y=a.attributes.position;for(let f=e,u=t+e;f<u;f++){let l;if(l=n.resolveTriangleIndex(f),U(o,l*3,r,y),o.needsUpdate=!0,s(o,l,i,c))return!0}return!1}function vs(e,t,n,s,i,c,o){L.setBuffer(e._roots[t]),_e(0,e,n,s,i,c,o),L.clearBuffer()}function _e(e,t,n,s,i,c,o){const{float32Array:a,uint16Array:r,uint32Array:y}=L,f=e*2;if(F(f,r)){const l=$(e,y),p=k(f,r);Bs(t,n,s,l,p,i,c,o)}else{const l=N(e);at(l,a,s,c,o)&&_e(l,t,n,s,i,c,o);const p=H(e,y);at(p,a,s,c,o)&&_e(p,t,n,s,i,c,o)}}const Is=["x","y","z"];function Cs(e,t,n,s,i,c){L.setBuffer(e._roots[t]);const o=Me(0,e,n,s,i,c);return L.clearBuffer(),o}function Me(e,t,n,s,i,c){const{float32Array:o,uint16Array:a,uint32Array:r}=L;let y=e*2;if(F(y,a)){const u=$(e,r),l=k(y,a);return Ts(t,n,s,u,l,i,c)}else{const u=Ve(e,r),l=Is[u],g=s.direction[l]>=0;let A,w;g?(A=N(e),w=H(e,r)):(A=H(e,r),w=N(e));const d=at(A,o,s,i,c)?Me(A,t,n,s,i,c):null;if(d){const x=d.point[l];if(g?x<=o[w+u]:x>=o[w+u+3])return d}const m=at(w,o,s,i,c)?Me(w,t,n,s,i,c):null;return d&&m?d.distance<=m.distance?d:m:d||m||null}}const Ot=new W,xt=new K,gt=new K,Mt=new rt,on=new X,$t=new X;function Rs(e,t,n,s){L.setBuffer(e._roots[t]);const i=ve(0,e,n,s);return L.clearBuffer(),i}function ve(e,t,n,s,i=null){const{float32Array:c,uint16Array:o,uint32Array:a}=L;let r=e*2;if(i===null&&(n.boundingBox||n.computeBoundingBox(),on.set(n.boundingBox.min,n.boundingBox.max,s),i=on),F(r,o)){const f=t.geometry,u=f.index,l=f.attributes.position,p=n.index,g=n.attributes.position,A=$(e,a),w=k(r,o);if(Mt.copy(s).invert(),n.boundsTree)return z(e,c,$t),$t.matrix.copy(Mt),$t.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:d=>$t.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let h=A*3,m=(w+A)*3;h<m;h+=3)if(U(gt,h,u,l),gt.needsUpdate=!0,d.intersectsTriangle(gt))return!0;return!1}});{const B=oe(n);for(let d=A*3,h=(w+A)*3;d<h;d+=3){U(xt,d,u,l),xt.a.applyMatrix4(Mt),xt.b.applyMatrix4(Mt),xt.c.applyMatrix4(Mt),xt.needsUpdate=!0;for(let m=0,x=B*3;m<x;m+=3)if(U(gt,m,p,g),gt.needsUpdate=!0,xt.intersectsTriangle(gt))return!0}}}else{const f=N(e),u=H(e,a);return z(f,c,Ot),!!(i.intersectsBox(Ot)&&ve(f,t,n,s,i)||(z(u,c,Ot),i.intersectsBox(Ot)&&ve(u,t,n,s,i)))}}const kt=new rt,ge=new X,vt=new X,Es=new R,Ls=new R,zs=new R,Ds=new R;function Us(e,t,n,s={},i={},c=0,o=1/0){t.boundingBox||t.computeBoundingBox(),ge.set(t.boundingBox.min,t.boundingBox.max,n),ge.needsUpdate=!0;const a=e.geometry,r=a.attributes.position,y=a.index,f=t.attributes.position,u=t.index,l=Z.getPrimitive(),p=Z.getPrimitive();let g=Es,A=Ls,w=null,B=null;i&&(w=zs,B=Ds);let d=1/0,h=null,m=null;return kt.copy(n).invert(),vt.matrix.copy(kt),e.shapecast({boundsTraverseOrder:x=>ge.distanceToBox(x),intersectsBounds:(x,S,T)=>T<d&&T<o?(S&&(vt.min.copy(x.min),vt.max.copy(x.max),vt.needsUpdate=!0),!0):!1,intersectsRange:(x,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:_=>vt.distanceToBox(_),intersectsBounds:(_,M,b)=>b<d&&b<o,intersectsRange:(_,M)=>{for(let b=_,v=_+M;b<v;b++){U(p,3*b,u,f),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let P=x,I=x+S;P<I;P++){U(l,3*P,y,r),l.needsUpdate=!0;const C=l.distanceToTriangle(p,g,w);if(C<d&&(A.copy(g),B&&B.copy(w),d=C,h=P,m=b),C<c)return!0}}}});{const T=oe(t);for(let _=0,M=T;_<M;_++){U(p,3*_,u,f),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let b=x,v=x+S;b<v;b++){U(l,3*b,y,r),l.needsUpdate=!0;const P=l.distanceToTriangle(p,g,w);if(P<d&&(A.copy(g),B&&B.copy(w),d=P,h=b,m=_),P<c)return!0}}}}}),Z.releasePrimitive(l),Z.releasePrimitive(p),d===1/0?null:(s.point?s.point.copy(A):s.point=A.clone(),s.distance=d,s.faceIndex=h,i&&(i.point?i.point.copy(B):i.point=B.clone(),i.point.applyMatrix4(kt),A.applyMatrix4(kt),i.distance=A.sub(i.point).length(),i.faceIndex=m),s)}function Vs(e,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,s=n.index?n.index.array:null,i=n.attributes.position;let c,o,a,r,y=0;const f=e._roots;for(let l=0,p=f.length;l<p;l++)c=f[l],o=new Uint32Array(c),a=new Uint16Array(c),r=new Float32Array(c),u(0,y),y+=c.byteLength;function u(l,p,g=!1){const A=l*2;if(F(A,a)){const w=$(l,o),B=k(A,a);let d=1/0,h=1/0,m=1/0,x=-1/0,S=-1/0,T=-1/0;for(let _=w,M=w+B;_<M;_++){const b=3*e.resolveTriangleIndex(_);for(let v=0;v<3;v++){let P=b+v;P=s?s[P]:P;const I=i.getX(P),C=i.getY(P),E=i.getZ(P);I<d&&(d=I),I>x&&(x=I),C<h&&(h=C),C>S&&(S=C),E<m&&(m=E),E>T&&(T=E)}}return r[l+0]!==d||r[l+1]!==h||r[l+2]!==m||r[l+3]!==x||r[l+4]!==S||r[l+5]!==T?(r[l+0]=d,r[l+1]=h,r[l+2]=m,r[l+3]=x,r[l+4]=S,r[l+5]=T,!0):!1}else{const w=N(l),B=H(l,o);let d=g,h=!1,m=!1;if(t){if(!d){const b=w/V+p/O,v=B/V+p/O;h=t.has(b),m=t.has(v),d=!h&&!m}}else h=!0,m=!0;const x=d||h,S=d||m;let T=!1;x&&(T=u(w,p,d));let _=!1;S&&(_=u(B,p,d));const M=T||_;if(M)for(let b=0;b<3;b++){const v=w+b,P=B+b,I=r[v],C=r[v+3],E=r[P],D=r[P+3];r[l+b]=I<E?I:E,r[l+b+3]=C>D?C:D}return M}}}function Fs(e,t,n,s,i,c,o){L.setBuffer(e._roots[t]),Ie(0,e,n,s,i,c,o),L.clearBuffer()}function Ie(e,t,n,s,i,c,o){const{float32Array:a,uint16Array:r,uint32Array:y}=L,f=e*2;if(F(f,r)){const l=$(e,y),p=k(f,r);Ss(t,n,s,l,p,i,c,o)}else{const l=N(e);at(l,a,s,c,o)&&Ie(l,t,n,s,i,c,o);const p=H(e,y);at(p,a,s,c,o)&&Ie(p,t,n,s,i,c,o)}}const Ns=["x","y","z"];function Hs(e,t,n,s,i,c){L.setBuffer(e._roots[t]);const o=Ce(0,e,n,s,i,c);return L.clearBuffer(),o}function Ce(e,t,n,s,i,c){const{float32Array:o,uint16Array:a,uint32Array:r}=L;let y=e*2;if(F(y,a)){const u=$(e,r),l=k(y,a);return _s(t,n,s,u,l,i,c)}else{const u=Ve(e,r),l=Ns[u],g=s.direction[l]>=0;let A,w;g?(A=N(e),w=H(e,r)):(A=H(e,r),w=N(e));const d=at(A,o,s,i,c)?Ce(A,t,n,s,i,c):null;if(d){const x=d.point[l];if(g?x<=o[w+u]:x>=o[w+u+3])return d}const m=at(w,o,s,i,c)?Ce(w,t,n,s,i,c):null;return d&&m?d.distance<=m.distance?d:m:d||m||null}}const Xt=new W,wt=new K,At=new K,It=new rt,rn=new X,Yt=new X;function qs(e,t,n,s){L.setBuffer(e._roots[t]);const i=Re(0,e,n,s);return L.clearBuffer(),i}function Re(e,t,n,s,i=null){const{float32Array:c,uint16Array:o,uint32Array:a}=L;let r=e*2;if(i===null&&(n.boundingBox||n.computeBoundingBox(),rn.set(n.boundingBox.min,n.boundingBox.max,s),i=rn),F(r,o)){const f=t.geometry,u=f.index,l=f.attributes.position,p=n.index,g=n.attributes.position,A=$(e,a),w=k(r,o);if(It.copy(s).invert(),n.boundsTree)return z(e,c,Yt),Yt.matrix.copy(It),Yt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:d=>Yt.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let h=A,m=w+A;h<m;h++)if(U(At,3*t.resolveTriangleIndex(h),u,l),At.needsUpdate=!0,d.intersectsTriangle(At))return!0;return!1}});{const B=oe(n);for(let d=A,h=w+A;d<h;d++){const m=t.resolveTriangleIndex(d);U(wt,3*m,u,l),wt.a.applyMatrix4(It),wt.b.applyMatrix4(It),wt.c.applyMatrix4(It),wt.needsUpdate=!0;for(let x=0,S=B*3;x<S;x+=3)if(U(At,x,p,g),At.needsUpdate=!0,wt.intersectsTriangle(At))return!0}}}else{const f=N(e),u=H(e,a);return z(f,c,Xt),!!(i.intersectsBox(Xt)&&Re(f,t,n,s,i)||(z(u,c,Xt),i.intersectsBox(Xt)&&Re(u,t,n,s,i)))}}const Zt=new rt,we=new X,Ct=new X,Os=new R,$s=new R,ks=new R,Xs=new R;function Ys(e,t,n,s={},i={},c=0,o=1/0){t.boundingBox||t.computeBoundingBox(),we.set(t.boundingBox.min,t.boundingBox.max,n),we.needsUpdate=!0;const a=e.geometry,r=a.attributes.position,y=a.index,f=t.attributes.position,u=t.index,l=Z.getPrimitive(),p=Z.getPrimitive();let g=Os,A=$s,w=null,B=null;i&&(w=ks,B=Xs);let d=1/0,h=null,m=null;return Zt.copy(n).invert(),Ct.matrix.copy(Zt),e.shapecast({boundsTraverseOrder:x=>we.distanceToBox(x),intersectsBounds:(x,S,T)=>T<d&&T<o?(S&&(Ct.min.copy(x.min),Ct.max.copy(x.max),Ct.needsUpdate=!0),!0):!1,intersectsRange:(x,S)=>{if(t.boundsTree){const T=t.boundsTree;return T.shapecast({boundsTraverseOrder:_=>Ct.distanceToBox(_),intersectsBounds:(_,M,b)=>b<d&&b<o,intersectsRange:(_,M)=>{for(let b=_,v=_+M;b<v;b++){const P=T.resolveTriangleIndex(b);U(p,3*P,u,f),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let I=x,C=x+S;I<C;I++){const E=e.resolveTriangleIndex(I);U(l,3*E,y,r),l.needsUpdate=!0;const D=l.distanceToTriangle(p,g,w);if(D<d&&(A.copy(g),B&&B.copy(w),d=D,h=I,m=b),D<c)return!0}}}})}else{const T=oe(t);for(let _=0,M=T;_<M;_++){U(p,3*_,u,f),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let b=x,v=x+S;b<v;b++){const P=e.resolveTriangleIndex(b);U(l,3*P,y,r),l.needsUpdate=!0;const I=l.distanceToTriangle(p,g,w);if(I<d&&(A.copy(g),B&&B.copy(w),d=I,h=b,m=_),I<c)return!0}}}}}),Z.releasePrimitive(l),Z.releasePrimitive(p),d===1/0?null:(s.point?s.point.copy(A):s.point=A.clone(),s.distance=d,s.faceIndex=h,i&&(i.point?i.point.copy(B):i.point=B.clone(),i.point.applyMatrix4(Zt),A.applyMatrix4(Zt),i.distance=A.sub(i.point).length(),i.faceIndex=m),s)}function cn(e,t,n){return e===null?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e)}const Wt=new X,jt=new $n,an=new R,ln=new rt,un=new R,Ae=["getX","getY","getZ"];class ne extends ys{static serialize(t,n={}){n={cloneBuffers:!0,...n};const s=t.geometry,i=t._roots,c=t._indirectBuffer,o=s.getIndex(),a={version:1,roots:null,index:null,indirectBuffer:null};return n.cloneBuffers?(a.roots=i.map(r=>r.slice()),a.index=o?o.array.slice():null,a.indirectBuffer=c?c.slice():null):(a.roots=i,a.index=o?o.array:null,a.indirectBuffer=c),a}static deserialize(t,n,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:i,roots:c,indirectBuffer:o}=t;t.version||r(c);const a=new ne(n,{...s,[Ue]:!0});if(a._roots=c,a._indirectBuffer=o||null,s.setIndex){const y=n.getIndex();if(y===null){const f=new dn(t.index,1,!1);n.setIndex(f)}else y.array!==i&&(y.array.set(i),y.needsUpdate=!0)}return a;function r(y){for(let f=0;f<y.length;f++){const u=y[f],l=new Uint32Array(u),p=new Uint16Array(u);for(let g=0,A=u.byteLength/O;g<A;g++){const w=V*g,B=2*w;F(B,p)||(l[w+6]=l[w+6]/V-g)}}}}get primitiveStride(){return 3}get resolveTriangleIndex(){return this.resolvePrimitiveIndex}constructor(t,n={}){n.maxLeafTris&&(n={...n,maxLeafSize:n.maxLeafTris}),super(t,n)}shiftTriangleOffsets(t){return super.shiftPrimitiveOffsets(t)}writePrimitiveBounds(t,n,s){const i=this.geometry,c=this._indirectBuffer,o=i.attributes.position,a=i.index?i.index.array:null,y=(c?c[t]:t)*3;let f=y+0,u=y+1,l=y+2;a&&(f=a[f],u=a[u],l=a[l]);for(let p=0;p<3;p++){const g=o[Ae[p]](f),A=o[Ae[p]](u),w=o[Ae[p]](l);let B=g;A<B&&(B=A),w<B&&(B=w);let d=g;A>d&&(d=A),w>d&&(d=w),n[s+p]=B,n[s+p+3]=d}return n}computePrimitiveBounds(t,n,s){const i=this.geometry,c=this._indirectBuffer,o=i.attributes.position,a=i.index?i.index.array:null,r=o.normalized;if(t<0||n+t-s.offset>s.length/6)throw new Error("MeshBVH: compute triangle bounds range is invalid.");const y=o.array,f=o.offset||0;let u=3;o.isInterleavedBufferAttribute&&(u=o.data.stride);const l=["getX","getY","getZ"],p=s.offset;for(let g=t,A=t+n;g<A;g++){const B=(c?c[g]:g)*3,d=(g-p)*6;let h=B+0,m=B+1,x=B+2;a&&(h=a[h],m=a[m],x=a[x]),r||(h=h*u+f,m=m*u+f,x=x*u+f);for(let S=0;S<3;S++){let T,_,M;r?(T=o[l[S]](h),_=o[l[S]](m),M=o[l[S]](x)):(T=y[h+S],_=y[m+S],M=y[x+S]);let b=T;_<b&&(b=_),M<b&&(b=M);let v=T;_>v&&(v=_),M>v&&(v=M);const P=(v-b)/2,I=S*2;s[d+I+0]=b+P,s[d+I+1]=P+(Math.abs(b)+P)*Qt}}return s}raycastObject3D(t,n,s=[]){const{material:i}=t;if(i===void 0)return;ln.copy(t.matrixWorld).invert(),jt.copy(n.ray).applyMatrix4(ln),un.setFromMatrixScale(t.matrixWorld),an.copy(jt.direction).multiply(un);const c=an.length(),o=n.near/c,a=n.far/c;if(n.firstHitOnly===!0){let r=this.raycastFirst(jt,i,o,a);r=cn(r,t,n),r&&s.push(r)}else{const r=this.raycast(jt,i,o,a);for(let y=0,f=r.length;y<f;y++){const u=cn(r[y],t,n);u&&s.push(u)}}return s}refit(t=null){return(this.indirect?Vs:bs)(this,t)}raycast(t,n=ke,s=0,i=1/0){const c=this._roots,o=[],a=this.indirect?Fs:vs;for(let r=0,y=c.length;r<y;r++)a(this,r,n,t,o,s,i);return o}raycastFirst(t,n=ke,s=0,i=1/0){const c=this._roots;let o=null;const a=this.indirect?Hs:Cs;for(let r=0,y=c.length;r<y;r++){const f=a(this,r,n,t,s,i);f!=null&&(o==null||f.distance<o.distance)&&(o=f)}return o}intersectsGeometry(t,n){let s=!1;const i=this._roots,c=this.indirect?qs:Rs;for(let o=0,a=i.length;o<a&&(s=c(this,o,t,n),!s);o++);return s}shapecast(t){const n=Z.getPrimitive(),s=super.shapecast({...t,intersectsPrimitive:t.intersectsTriangle,scratchPrimitive:n,iterate:this.indirect?Ms:Ps});return Z.releasePrimitive(n),s}bvhcast(t,n,s){let{intersectsRanges:i,intersectsTriangles:c}=s;const o=Z.getPrimitive(),a=this.geometry.index,r=this.geometry.attributes.position,y=this.indirect?g=>{const A=this.resolveTriangleIndex(g);U(o,A*3,a,r)}:g=>{U(o,g*3,a,r)},f=Z.getPrimitive(),u=t.geometry.index,l=t.geometry.attributes.position,p=t.indirect?g=>{const A=t.resolveTriangleIndex(g);U(f,A*3,u,l)}:g=>{U(f,g*3,u,l)};if(c){if(!(t instanceof ne))throw new Error('MeshBVH: "intersectsTriangles" callback can only be used with another MeshBVH.');const g=(A,w,B,d,h,m,x,S)=>{for(let T=B,_=B+d;T<_;T++){p(T),f.a.applyMatrix4(n),f.b.applyMatrix4(n),f.c.applyMatrix4(n),f.needsUpdate=!0;for(let M=A,b=A+w;M<b;M++)if(y(M),o.needsUpdate=!0,c(o,f,M,T,h,m,x,S))return!0}return!1};if(i){const A=i;i=function(w,B,d,h,m,x,S,T){return A(w,B,d,h,m,x,S,T)?!0:g(w,B,d,h,m,x,S,T)}}else i=g}return super.bvhcast(t,n,{intersectsRanges:i})}intersectsBox(t,n){return Wt.set(t.min,t.max,n),Wt.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Wt.intersectsBox(s),intersectsTriangle:s=>Wt.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:n=>t.intersectsBox(n),intersectsTriangle:n=>n.intersectsSphere(t)})}closestPointToGeometry(t,n,s={},i={},c=0,o=1/0){return(this.indirect?Ys:Us)(this,t,n,s,i,c,o)}closestPointToPoint(t,n={},s=0,i=1/0){return gs(this,t,n,s,i)}}const Tt={Mesh:Lt.prototype.raycast,Line:wn.prototype.raycast,LineSegments:xn.prototype.raycast,LineLoop:gn.prototype.raycast,Points:An.prototype.raycast,BatchedMesh:Xn.prototype.raycast},q=new Lt,Kt=[];function Zs(e,t){if(this.isBatchedMesh)Ws.call(this,e,t);else{const{geometry:n}=this;if(n.boundsTree)n.boundsTree.raycastObject3D(this,e,t);else{let s;if(this instanceof Lt)s=Tt.Mesh;else if(this instanceof xn)s=Tt.LineSegments;else if(this instanceof gn)s=Tt.LineLoop;else if(this instanceof wn)s=Tt.Line;else if(this instanceof An)s=Tt.Points;else throw new Error("BVH: Fallback raycast function not found.");s.call(this,e,t)}}}function Ws(e,t){if(this.boundsTrees){const n=this.boundsTrees,s=this._drawInfo||this._instanceInfo,i=this._drawRanges||this._geometryInfo,c=this.matrixWorld;q.material=this.material,q.geometry=this.geometry;const o=q.geometry.boundsTree,a=q.geometry.drawRange;q.geometry.boundingSphere===null&&(q.geometry.boundingSphere=new kn);for(let r=0,y=s.length;r<y;r++){if(!this.getVisibleAt(r))continue;const f=s[r].geometryIndex;if(q.geometry.boundsTree=n[f],this.getMatrixAt(r,q.matrixWorld).premultiply(c),!q.geometry.boundsTree){this.getBoundingBoxAt(f,q.geometry.boundingBox),this.getBoundingSphereAt(f,q.geometry.boundingSphere);const u=i[f];q.geometry.setDrawRange(u.start,u.count)}q.raycast(e,Kt);for(let u=0,l=Kt.length;u<l;u++){const p=Kt[u];p.object=this,p.batchId=r,t.push(p)}Kt.length=0}q.geometry.boundsTree=o,q.geometry.drawRange=a,q.material=null,q.geometry=null}else Tt.BatchedMesh.call(this,e,t)}function js(e={}){const{type:t=ne}=e;return this.boundsTree=new t(this,e),this.boundsTree}function Ks(){this.boundsTree=null}bn.prototype.computeBoundsTree=js;bn.prototype.disposeBoundsTree=Ks;Lt.prototype.raycast=Zs;const fn=[];function xi(e){fn.length=0,fn.push(...e)}let Cn=null,Rn=null,En=null,Ln=null;function gi(){return Cn}function Qs(){return Rn}function wi(){return En}function Ai(){return Ln}function Bi(e){Cn=e}function Ti(e){Rn=e}function Pi(e){En=e}function bi(e){Ln=e}let Js=1.7,Gs=0,ti=200,ei=.4,ni=1;function Si(e){Js=e}function _i(e){Gs=e}function Mi(e){ti=e}function vi(e){ei=e}function Ii(e){ni=e}const Ci=De(!1),Ri=!1,Ei=De(!1),Et=[],pn=[],yn=[],Li=new Map,zi=new Pn,Di=new Pn,si=[];for(let e=0;e<8;e++){const t=e/8*Math.PI*2;si.push(new R(Math.cos(t),0,Math.sin(t)))}const Ui=new Tn(26248),Vi=.8,Fi=new Tn(21862),Ni=.4;function Hi(e){return Math.round(e*1e4)/1e4}function qi(e){return e.split("/").pop()||""}function Oi(e){return e.replace(/\.glb$/i,"").replace(/[-_]/g," ").replace(/\b\w/g,t=>t.toUpperCase())}const Be=new R;function $i(){return Qs().getWorldDirection(Be),Math.atan2(Be.x,Be.z)}function nt(e){e&&(e.source?.data?.close&&e.source.data.close(),e.dispose())}function ki(e){e.traverse(t=>{if(t.geometry&&t.geometry.dispose(),t.material){const n=Array.isArray(t.material)?t.material:[t.material];for(const s of n)nt(s.map),nt(s.normalMap),nt(s.roughnessMap),nt(s.metalnessMap),nt(s.emissiveMap),nt(s.aoMap),nt(s.lightMap),nt(s.alphaMap),s.dispose()}})}function Xi(e){e.traverse(t=>{t.geometry&&t.geometry.dispose()})}function Yi(e,t,n){const s=[];return e.userData?.isTent||e.traverse(i=>{if(!i.isMesh||i.userData.isDisplayZone||i.userData.isTentSurface)return;const c=Array.isArray(i.material)?i.material:[i.material];for(const o of c)o.emissive&&(s.push({mesh:i,origEmissive:o.emissive.clone(),origEmissiveIntensity:o.emissiveIntensity??1}),o.emissive.copy(t),o.emissiveIntensity=n)}),s}function Zi(e){for(const t of e){const n=Array.isArray(t.mesh.material)?t.mesh.material:[t.mesh.material];for(const s of n)s.emissive&&(s.emissive.copy(t.origEmissive),s.emissiveIntensity=t.origEmissiveIntensity)}}function Wi(e){zn(e),e.traverse(t=>{if(!t.isMesh)return;let n=Et.indexOf(t);n>=0&&Et.splice(n,1),n=pn.indexOf(t),n>=0&&pn.splice(n,1)})}const ii=200;function oi(e){const t=e.geometry;if(!t||t.boundsTree)return;const n=t.index;(n?n.count/3:(t.attributes?.position?.count??0)/3)>ii&&t.computeBoundsTree({strategy:0,maxLeafSize:10})}function ri(e){e.traverse(t=>{t.isMesh&&oi(t)})}const Gt=[];let te=!1;function ji(e){Gt.push(e),te||ci()}function ci(){if(Gt.length===0){te=!1;return}te=!0;const e=()=>{const t=Gt.shift();t&&ri(t),Gt.length>0?setTimeout(e,0):te=!1};setTimeout(e,0)}const ai=new Yn({visible:!1}),se=new Map,ot=new R,ie=new R;function li(e){zn(e);const t=new W().setFromObject(e);if(t.isEmpty())return;t.getSize(ot),t.getCenter(ie);const n=new Bn(ot.x,ot.y,ot.z);n.computeBoundingSphere();const s=new Lt(n,ai);s.position.copy(ie),s.visible=!1,s.matrixAutoUpdate=!1,s.updateMatrix(),s.matrixWorld.copy(s.matrix),s.userData.isCollisionProxy=!0,Et.push(s),se.set(e,s)}function zn(e){const t=se.get(e);if(!t)return;const n=Et.indexOf(t);n>=0&&Et.splice(n,1),t.geometry.dispose(),se.delete(e)}function Ki(e){for(let t=0;t<yn.length;t++){const n=yn[t],s=se.get(n.group),i=e?.[t]??new W().setFromObject(n.group);i.isEmpty()||(i.getSize(ot),i.getCenter(ie),s?(s.geometry.dispose(),s.geometry=new Bn(ot.x,ot.y,ot.z),s.geometry.computeBoundingSphere(),s.position.copy(ie),s.updateMatrix(),s.matrixWorld.copy(s.matrix)):li(n.group))}}const ui=De(!1);function Qi(){return{sidebarOpen:ui}}export{ri as A,Fi as B,Et as C,si as D,zi as E,ei as F,Ki as G,oi as H,_i as I,Ii as J,Si as K,vi as L,ti as M,Mi as N,xi as O,Ni as P,zn as Q,bi as R,Bi as S,Vi as T,Ti as U,Pi as V,Ri as W,mi as X,hi as Y,Qi as Z,di as _,gi as a,wi as b,Qs as c,fn as d,Ci as e,Oi as f,Ai as g,pn as h,Li as i,qi as j,Wi as k,Xi as l,Hi as m,ji as n,li as o,yn as p,Di as q,ni as r,Gs as s,Js as t,ki as u,Ei as v,Zi as w,Yi as x,Ui as y,$i as z};

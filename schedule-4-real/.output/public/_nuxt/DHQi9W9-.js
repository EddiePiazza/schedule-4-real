import{o as ce,c as ae,a as Et,l as Ue,N as Ut}from"./LgMdrHNb.js";import{o as W,j as rt,n as mn,V as R,af as G,g as hn,f as ct,ae as Bt,B as $n,w as On,ak as xn,R as Zn,aZ as ke,a as zt,aM as gn,aN as wn,K as An,aO as Bn,ag as kn,a$ as Xn,b0 as Tn,M as Yn,b as Pn,i as bn,J as Sn}from"./uBFS2Jma.js";function mi(e,t){return ce(),ae("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor","aria-hidden":"true","data-slot":"icon"},[Et("path",{"fill-rule":"evenodd",d:"M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z","clip-rule":"evenodd"})])}function hi(e,t){return ce(),ae("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor","aria-hidden":"true","data-slot":"icon"},[Et("path",{d:"M18 1.5c2.9 0 5.25 2.35 5.25 5.25v3.75a.75.75 0 0 1-1.5 0V6.75a3.75 3.75 0 1 0-7.5 0v3a3 3 0 0 1 3 3v6.75a3 3 0 0 1-3 3H3.75a3 3 0 0 1-3-3v-6.75a3 3 0 0 1 3-3h9v-3c0-2.9 2.35-5.25 5.25-5.25Z"})])}function xi(e,t){return ce(),ae("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor","aria-hidden":"true","data-slot":"icon"},[Et("path",{"fill-rule":"evenodd",d:"M12.516 2.17a.75.75 0 0 0-1.032 0 11.209 11.209 0 0 1-7.877 3.08.75.75 0 0 0-.722.515A12.74 12.74 0 0 0 2.25 9.75c0 5.942 4.064 10.933 9.563 12.348a.749.749 0 0 0 .374 0c5.499-1.415 9.563-6.406 9.563-12.348 0-1.39-.223-2.73-.635-3.985a.75.75 0 0 0-.722-.516l-.143.001c-2.996 0-5.717-1.17-7.734-3.08Zm3.094 8.016a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z","clip-rule":"evenodd"})])}function gi(e,t){return ce(),ae("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor","aria-hidden":"true","data-slot":"icon"},[Et("path",{"fill-rule":"evenodd",d:"M8.25 6.75a3.75 3.75 0 1 1 7.5 0 3.75 3.75 0 0 1-7.5 0ZM15.75 9.75a3 3 0 1 1 6 0 3 3 0 0 1-6 0ZM2.25 9.75a3 3 0 1 1 6 0 3 3 0 0 1-6 0ZM6.31 15.117A6.745 6.745 0 0 1 12 12a6.745 6.745 0 0 1 6.709 7.498.75.75 0 0 1-.372.568A12.696 12.696 0 0 1 12 21.75c-2.305 0-4.47-.612-6.337-1.684a.75.75 0 0 1-.372-.568 6.787 6.787 0 0 1 1.019-4.38Z","clip-rule":"evenodd"}),Et("path",{d:"M5.082 14.254a8.287 8.287 0 0 0-1.308 5.135 9.687 9.687 0 0 1-1.764-.44l-.115-.04a.563.563 0 0 1-.373-.487l-.01-.121a3.75 3.75 0 0 1 3.57-4.047ZM20.226 19.389a8.287 8.287 0 0 0-1.308-5.135 3.75 3.75 0 0 1 3.57 4.047l-.01.121a.563.563 0 0 1-.373.486l-.115.04c-.567.2-1.156.349-1.764.441Z"})])}const _n=0,Wn=1,jn=2,Xe=2,me=1.25,Ye=1,$=32,V=$/4,Mn=65535,Gt=Math.pow(2,-24),Ve=Symbol("SKIP_GENERATION"),vn={strategy:_n,maxDepth:40,maxLeafSize:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null,[Ve]:!1};function z(e,t,n){return n.min.x=t[e],n.min.y=t[e+1],n.min.z=t[e+2],n.max.x=t[e+3],n.max.y=t[e+4],n.max.z=t[e+5],n}function We(e){let t=-1,n=-1/0;for(let s=0;s<3;s++){const i=e[s+3]-e[s];i>n&&(n=i,t=s)}return t}function je(e,t){t.set(e)}function Ke(e,t,n){let s,i;for(let c=0;c<3;c++){const o=c+3;s=e[c],i=t[c],n[c]=s<i?s:i,s=e[o],i=t[o],n[o]=s>i?s:i}}function Vt(e,t,n){for(let s=0;s<3;s++){const i=t[e+2*s],c=t[e+2*s+1],o=i-c,a=i+c;o<n[s]&&(n[s]=o),a>n[s+3]&&(n[s+3]=a)}}function bt(e){const t=e[3]-e[0],n=e[4]-e[1],s=e[5]-e[2];return 2*(t*n+n*s+s*t)}function F(e,t){return t[e+15]===Mn}function O(e,t){return t[e+6]}function Z(e,t){return t[e+14]}function N(e){return e+V}function H(e,t){const n=t[e+6];return e+n*V}function Fe(e,t){return t[e+7]}function he(e,t,n,s,i){let c=1/0,o=1/0,a=1/0,r=-1/0,y=-1/0,f=-1/0,u=1/0,l=1/0,p=1/0,g=-1/0,A=-1/0,w=-1/0;const B=e.offset||0;for(let d=(t-B)*6,h=(t+n-B)*6;d<h;d+=6){const m=e[d+0],x=e[d+1],S=m-x,T=m+x;S<c&&(c=S),T>r&&(r=T),m<u&&(u=m),m>g&&(g=m);const _=e[d+2],M=e[d+3],b=_-M,v=_+M;b<o&&(o=b),v>y&&(y=v),_<l&&(l=_),_>A&&(A=_);const P=e[d+4],I=e[d+5],C=P-I,E=P+I;C<a&&(a=C),E>f&&(f=E),P<p&&(p=P),P>w&&(w=P)}s[0]=c,s[1]=o,s[2]=a,s[3]=r,s[4]=y,s[5]=f,i[0]=u,i[1]=l,i[2]=p,i[3]=g,i[4]=A,i[5]=w}const Q=32,Kn=(e,t)=>e.candidate-t.candidate,et=new Array(Q).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ft=new Float32Array(6);function Qn(e,t,n,s,i,c){let o=-1,a=0;if(c===_n)o=We(t),o!==-1&&(a=(t[o]+t[o+3])/2);else if(c===Wn)o=We(e),o!==-1&&(a=Jn(n,s,i,o));else if(c===jn){const r=bt(e);let y=me*i;const f=n.offset||0,u=(s-f)*6,l=(s+i-f)*6;for(let p=0;p<3;p++){const g=t[p],B=(t[p+3]-g)/Q;if(i<Q/4){const d=[...et];d.length=i;let h=0;for(let x=u;x<l;x+=6,h++){const S=d[h];S.candidate=n[x+2*p],S.count=0;const{bounds:T,leftCacheBounds:_,rightCacheBounds:M}=S;for(let b=0;b<3;b++)M[b]=1/0,M[b+3]=-1/0,_[b]=1/0,_[b+3]=-1/0,T[b]=1/0,T[b+3]=-1/0;Vt(x,n,T)}d.sort(Kn);let m=i;for(let x=0;x<m;x++){const S=d[x];for(;x+1<m&&d[x+1].candidate===S.candidate;)d.splice(x+1,1),m--}for(let x=u;x<l;x+=6){const S=n[x+2*p];for(let T=0;T<m;T++){const _=d[T];S>=_.candidate?Vt(x,n,_.rightCacheBounds):(Vt(x,n,_.leftCacheBounds),_.count++)}}for(let x=0;x<m;x++){const S=d[x],T=S.count,_=i-S.count,M=S.leftCacheBounds,b=S.rightCacheBounds;let v=0;T!==0&&(v=bt(M)/r);let P=0;_!==0&&(P=bt(b)/r);const I=Ye+me*(v*T+P*_);I<y&&(o=p,y=I,a=S.candidate)}}else{for(let m=0;m<Q;m++){const x=et[m];x.count=0,x.candidate=g+B+m*B;const S=x.bounds;for(let T=0;T<3;T++)S[T]=1/0,S[T+3]=-1/0}for(let m=u;m<l;m+=6){let T=~~((n[m+2*p]-g)/B);T>=Q&&(T=Q-1);const _=et[T];_.count++,Vt(m,n,_.bounds)}const d=et[Q-1];je(d.bounds,d.rightCacheBounds);for(let m=Q-2;m>=0;m--){const x=et[m],S=et[m+1];Ke(x.bounds,S.rightCacheBounds,x.rightCacheBounds)}let h=0;for(let m=0;m<Q-1;m++){const x=et[m],S=x.count,T=x.bounds,M=et[m+1].rightCacheBounds;S!==0&&(h===0?je(T,Ft):Ke(T,Ft,Ft)),h+=S;let b=0,v=0;h!==0&&(b=bt(Ft)/r);const P=i-h;P!==0&&(v=bt(M)/r);const I=Ye+me*(b*h+v*P);I<y&&(o=p,y=I,a=x.candidate)}}}}return{axis:o,pos:a}}function Jn(e,t,n,s){let i=0;const c=e.offset;for(let o=t,a=t+n;o<a;o++)i+=e[(o-c)*6+s*2];return i/n}class xe{constructor(){this.boundingData=new Float32Array(6)}}function Gn(e,t,n,s,i,c){let o=s,a=s+i-1;const r=c.pos,y=c.axis*2,f=n.offset||0;for(;;){for(;o<=a&&n[(o-f)*6+y]<r;)o++;for(;o<=a&&n[(a-f)*6+y]>=r;)a--;if(o<a){for(let u=0;u<t;u++){let l=e[o*t+u];e[o*t+u]=e[a*t+u],e[a*t+u]=l}for(let u=0;u<6;u++){const l=o-f,p=a-f,g=n[l*6+u];n[l*6+u]=n[p*6+u],n[p*6+u]=g}o++,a--}else return o}}let In,te,_e,Cn;const ts=Math.pow(2,32);function Me(e){return"count"in e?1:1+Me(e.left)+Me(e.right)}function es(e,t,n){return In=new Float32Array(n),te=new Uint32Array(n),_e=new Uint16Array(n),Cn=new Uint8Array(n),ve(e,t)}function ve(e,t){const n=e/4,s=e/2,i="count"in t,c=t.boundingData;for(let o=0;o<6;o++)In[n+o]=c[o];if(i)return t.buffer?(Cn.set(new Uint8Array(t.buffer),e),e+t.buffer.byteLength):(te[n+6]=t.offset,_e[s+14]=t.count,_e[s+15]=Mn,e+$);{const{left:o,right:a,splitAxis:r}=t,y=e+$;let f=ve(y,o);const u=e/$,p=f/$-u;if(p>ts)throw new Error("MeshBVH: Cannot store relative child node offset greater than 32 bits.");return te[n+6]=p,te[n+7]=r,ve(f,a)}}function ns(e,t,n,s,i,c){const{maxDepth:o,verbose:a,maxLeafSize:r,strategy:y,onProgress:f}=i,u=e.primitiveBuffer,l=e.primitiveBufferStride,p=new Float32Array(6);let g=!1;const A=new xe;return he(t,n,s,A.boundingData,p),B(A,n,s,p),A;function w(d){f&&f((d-c.offset)/c.count)}function B(d,h,m,x=null,S=0){if(!g&&S>=o&&(g=!0),m<=r||S>=o)return w(h+m),d.offset=h,d.count=m,d;const T=Qn(d.boundingData,x,t,h,m,y);if(T.axis===-1)return w(h+m),d.offset=h,d.count=m,d;const _=Gn(u,l,t,h,m,T);if(_===h||_===h+m)w(h+m),d.offset=h,d.count=m;else{d.splitAxis=T.axis;const M=new xe,b=h,v=_-h;d.left=M,he(t,b,v,M.boundingData,p),B(M,b,v,p,S+1);const P=new xe,I=_,C=m-v;d.right=P,he(t,I,C,P.boundingData,p),B(P,I,C,p,S+1)}return d}}function ss(e,t){const n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=e.getRootRanges(t.range),i=s[0],c=s[s.length-1],o={offset:i.offset,count:c.offset+c.count-i.offset},a=new Float32Array(6*o.count);a.offset=o.offset,e.computePrimitiveBounds(o.offset,o.count,a),e._roots=s.map(r=>{const y=ns(e,a,r.offset,r.count,t,o),f=Me(y),u=new n($*f);return es(0,y,u),u})}class Ne{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class is{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let n=null;this.setBuffer=s=>{n&&t.push(n),n=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{n=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const L=new is;let it,Pt;const yt=[],Nt=new Ne(()=>new W);function os(e,t,n,s,i,c){it=Nt.getPrimitive(),Pt=Nt.getPrimitive(),yt.push(it,Pt),L.setBuffer(e._roots[t]);const o=Ie(0,e.geometry,n,s,i,c);L.clearBuffer(),Nt.releasePrimitive(it),Nt.releasePrimitive(Pt),yt.pop(),yt.pop();const a=yt.length;return a>0&&(Pt=yt[a-1],it=yt[a-2]),o}function Ie(e,t,n,s,i=null,c=0,o=0){const{float32Array:a,uint16Array:r,uint32Array:y}=L;let f=e*2;if(F(f,r)){const l=O(e,y),p=Z(f,r);return z(e,a,it),s(l,p,!1,o,c+e/V,it)}else{let b=function(P){const{uint16Array:I,uint32Array:C}=L;let E=P*2;for(;!F(E,I);)P=N(P),E=P*2;return O(P,C)},v=function(P){const{uint16Array:I,uint32Array:C}=L;let E=P*2;for(;!F(E,I);)P=H(P,C),E=P*2;return O(P,C)+Z(E,I)};const l=N(e),p=H(e,y);let g=l,A=p,w,B,d,h;if(i&&(d=it,h=Pt,z(g,a,d),z(A,a,h),w=i(d),B=i(h),B<w)){g=p,A=l;const P=w;w=B,B=P,d=h}d||(d=it,z(g,a,d));const m=F(g*2,r),x=n(d,m,w,o+1,c+g/V);let S;if(x===Xe){const P=b(g),C=v(g)-P;S=s(P,C,!0,o+1,c+g/V,d)}else S=x&&Ie(g,t,n,s,i,c,o+1);if(S)return!0;h=Pt,z(A,a,h);const T=F(A*2,r),_=n(h,T,B,o+1,c+A/V);let M;if(_===Xe){const P=b(A),C=v(A)-P;M=s(P,C,!0,o+1,c+A/V,h)}else M=_&&Ie(A,t,n,s,i,c,o+1);return!!M}}const Rt=new L.constructor,se=new L.constructor,st=new Ne(()=>new W),dt=new W,mt=new W,ge=new W,we=new W;let Ae=!1;function rs(e,t,n,s){if(Ae)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ae=!0;const i=e._roots,c=t._roots;let o,a=0,r=0;const y=new rt().copy(n).invert();for(let f=0,u=i.length;f<u;f++){Rt.setBuffer(i[f]),r=0;const l=st.getPrimitive();z(0,Rt.float32Array,l),l.applyMatrix4(y);for(let p=0,g=c.length;p<g&&(se.setBuffer(c[p]),o=j(0,0,n,y,s,a,r,0,0,l),se.clearBuffer(),r+=c[p].byteLength/$,!o);p++);if(st.releasePrimitive(l),Rt.clearBuffer(),a+=i[f].byteLength/$,o)break}return Ae=!1,o}function j(e,t,n,s,i,c=0,o=0,a=0,r=0,y=null,f=!1){let u,l;f?(u=se,l=Rt):(u=Rt,l=se);const p=u.float32Array,g=u.uint32Array,A=u.uint16Array,w=l.float32Array,B=l.uint32Array,d=l.uint16Array,h=e*2,m=t*2,x=F(h,A),S=F(m,d);let T=!1;if(S&&x)f?T=i(O(t,B),Z(t*2,d),O(e,g),Z(e*2,A),r,o+t/V,a,c+e/V):T=i(O(e,g),Z(e*2,A),O(t,B),Z(t*2,d),a,c+e/V,r,o+t/V);else if(S){const _=st.getPrimitive();z(t,w,_),_.applyMatrix4(n);const M=N(e),b=H(e,g);z(M,p,dt),z(b,p,mt);const v=_.intersectsBox(dt),P=_.intersectsBox(mt);T=v&&j(t,M,s,n,i,o,c,r,a+1,_,!f)||P&&j(t,b,s,n,i,o,c,r,a+1,_,!f),st.releasePrimitive(_)}else{const _=N(t),M=H(t,B);z(_,w,ge),z(M,w,we);const b=y.intersectsBox(ge),v=y.intersectsBox(we);if(b&&v)T=j(e,_,n,s,i,c,o,a,r+1,y,f)||j(e,M,n,s,i,c,o,a,r+1,y,f);else if(b)if(x)T=j(e,_,n,s,i,c,o,a,r+1,y,f);else{const P=st.getPrimitive();P.copy(ge).applyMatrix4(n);const I=N(e),C=H(e,g);z(I,p,dt),z(C,p,mt);const E=P.intersectsBox(dt),D=P.intersectsBox(mt);T=E&&j(_,I,s,n,i,o,c,r,a+1,P,!f)||D&&j(_,C,s,n,i,o,c,r,a+1,P,!f),st.releasePrimitive(P)}else if(v)if(x)T=j(e,M,n,s,i,c,o,a,r+1,y,f);else{const P=st.getPrimitive();P.copy(we).applyMatrix4(n);const I=N(e),C=H(e,g);z(I,p,dt),z(C,p,mt);const E=P.intersectsBox(dt),D=P.intersectsBox(mt);T=E&&j(M,I,s,n,i,o,c,r,a+1,P,!f)||D&&j(M,C,s,n,i,o,c,r,a+1,P,!f),st.releasePrimitive(P)}}return T}const Qe=new W,ht=new Float32Array(6);class cs{constructor(){this._roots=null,this.primitiveBuffer=null,this.primitiveBufferStride=null}init(t){t={...vn,...t},ss(this,t)}getRootRanges(){throw new Error("BVH: getRootRanges() not implemented")}writePrimitiveBounds(){throw new Error("BVH: writePrimitiveBounds() not implemented")}writePrimitiveRangeBounds(t,n,s,i){let c=1/0,o=1/0,a=1/0,r=-1/0,y=-1/0,f=-1/0;for(let u=t,l=t+n;u<l;u++){this.writePrimitiveBounds(u,ht,0);const[p,g,A,w,B,d]=ht;p<c&&(c=p),w>r&&(r=w),g<o&&(o=g),B>y&&(y=B),A<a&&(a=A),d>f&&(f=d)}return s[i+0]=c,s[i+1]=o,s[i+2]=a,s[i+3]=r,s[i+4]=y,s[i+5]=f,s}computePrimitiveBounds(t,n,s){const i=s.offset||0;for(let c=t,o=t+n;c<o;c++){this.writePrimitiveBounds(c,ht,0);const[a,r,y,f,u,l]=ht,p=(a+f)/2,g=(r+u)/2,A=(y+l)/2,w=(f-a)/2,B=(u-r)/2,d=(l-y)/2,h=(c-i)*6;s[h+0]=p,s[h+1]=w+(Math.abs(p)+w)*Gt,s[h+2]=g,s[h+3]=B+(Math.abs(g)+B)*Gt,s[h+4]=A,s[h+5]=d+(Math.abs(A)+d)*Gt}return s}shiftPrimitiveOffsets(t){const n=this._indirectBuffer;if(n)for(let s=0,i=n.length;s<i;s++)n[s]+=t;else{const s=this._roots;for(let i=0;i<s.length;i++){const c=s[i],o=new Uint32Array(c),a=new Uint16Array(c),r=c.byteLength/$;for(let y=0;y<r;y++){const f=V*y,u=2*f;F(u,a)&&(o[f+6]+=t)}}}}traverse(t,n=0){const s=this._roots[n],i=new Uint32Array(s),c=new Uint16Array(s);o(0);function o(a,r=0){const y=a*2,f=F(y,c);if(f){const u=i[a+6],l=c[y+14];t(r,f,new Float32Array(s,a*4,6),u,l)}else{const u=N(a),l=H(a,i),p=Fe(a,i);t(r,f,new Float32Array(s,a*4,6),p)||(o(u,r+1),o(l,r+1))}}}refit(){const t=this._roots;for(let n=0,s=t.length;n<s;n++){const i=t[n],c=new Uint32Array(i),o=new Uint16Array(i),a=new Float32Array(i),r=i.byteLength/$;for(let y=r-1;y>=0;y--){const f=y*V,u=f*2;if(F(u,o)){const p=O(f,c),g=Z(u,o);this.writePrimitiveRangeBounds(p,g,ht,0),a.set(ht,f)}else{const p=N(f),g=H(f,c);for(let A=0;A<3;A++){const w=a[p+A],B=a[p+A+3],d=a[g+A],h=a[g+A+3];a[f+A]=w<d?w:d,a[f+A+3]=B>h?B:h}}}}}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{z(0,new Float32Array(s),Qe),t.union(Qe)}),t}shapecast(t){let{boundsTraverseOrder:n,intersectsBounds:s,intersectsRange:i,intersectsPrimitive:c,scratchPrimitive:o,iterate:a}=t;if(i&&c){const u=i;i=(l,p,g,A,w)=>u(l,p,g,A,w)?!0:a(l,p,this,c,g,A,o)}else i||(c?i=(u,l,p,g)=>a(u,l,this,c,p,g,o):i=(u,l,p)=>p);let r=!1,y=0;const f=this._roots;for(let u=0,l=f.length;u<l;u++){const p=f[u];if(r=os(this,u,s,i,n,y),r)break;y+=p.byteLength/$}return r}bvhcast(t,n,s){let{intersectsRanges:i}=s;return rs(this,t,n,i)}}function as(){return typeof SharedArrayBuffer<"u"}function He(e){return e.index?e.index.count:e.attributes.position.count}function le(e){return He(e)/3}function ls(e,t=ArrayBuffer){return e>65535?new Uint32Array(new t(4*e)):new Uint16Array(new t(2*e))}function us(e,t){if(!e.index){const n=e.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=ls(n,s);e.setIndex(new mn(i,1));for(let c=0;c<n;c++)i[c]=c}}function fs(e,t,n){const s=He(e)/n,i=t||e.drawRange,c=i.start/n,o=(i.start+i.count)/n,a=Math.max(0,c),r=Math.min(s,o)-a;return{offset:Math.floor(a),count:Math.floor(r)}}function ps(e,t){return e.groups.map(n=>({offset:n.start/t,count:n.count/t}))}function Je(e,t,n){const s=fs(e,t,n),i=ps(e,n);if(!i.length)return[s];const c=[],o=s.offset,a=s.offset+s.count,r=He(e)/n,y=[];for(const l of i){const{offset:p,count:g}=l,A=p,w=isFinite(g)?g:r-p,B=p+w;A<a&&B>o&&(y.push({pos:Math.max(o,A),isStart:!0}),y.push({pos:Math.min(a,B),isStart:!1}))}y.sort((l,p)=>l.pos!==p.pos?l.pos-p.pos:l.type==="end"?-1:1);let f=0,u=null;for(const l of y){const p=l.pos;f!==0&&p!==u&&c.push({offset:u,count:p-u}),f+=l.isStart?1:-1,u=p}return c}function ys(e,t){const n=e[e.length-1],s=n.offset+n.count>2**16,i=e.reduce((y,f)=>y+f.count,0),c=s?4:2,o=t?new SharedArrayBuffer(i*c):new ArrayBuffer(i*c),a=s?new Uint32Array(o):new Uint16Array(o);let r=0;for(let y=0;y<e.length;y++){const{offset:f,count:u}=e[y];for(let l=0;l<u;l++)a[r+l]=f+l;r+=u}return a}class ds extends cs{get indirect(){return!!this._indirectBuffer}get primitiveStride(){return null}get primitiveBufferStride(){return this.indirect?1:this.primitiveStride}set primitiveBufferStride(t){}get primitiveBuffer(){return this.indirect?this._indirectBuffer:this.geometry.index.array}set primitiveBuffer(t){}constructor(t,n={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("BVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("BVH: Only BufferGeometries are supported.");if(n.useSharedArrayBuffer&&!as())throw new Error("BVH: SharedArrayBuffer is not available.");super(),this.geometry=t,this.resolvePrimitiveIndex=n.indirect?s=>this._indirectBuffer[s]:s=>s,this.primitiveBuffer=null,this.primitiveBufferStride=null,this._indirectBuffer=null,n={...vn,...n},n[Ve]||this.init(n)}init(t){const{geometry:n,primitiveStride:s}=this;if(t.indirect){const i=Je(n,t.range,s),c=ys(i,t.useSharedArrayBuffer);this._indirectBuffer=c}else us(n,t);super.init(t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new W))}getRootRanges(t){return this.indirect?[{offset:0,count:this._indirectBuffer.length}]:Je(this.geometry,t,this.primitiveStride)}raycastObject3D(){throw new Error("BVH: raycastObject3D() not implemented")}}class tt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,n){let s=1/0,i=-1/0;for(let c=0,o=t.length;c<o;c++){const r=t[c][n];s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}setFromPoints(t,n){let s=1/0,i=-1/0;for(let c=0,o=n.length;c<o;c++){const a=n[c],r=t.dot(a);s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}tt.prototype.setFromBox=(function(){const e=new R;return function(n,s){const i=s.min,c=s.max;let o=1/0,a=-1/0;for(let r=0;r<=1;r++)for(let y=0;y<=1;y++)for(let f=0;f<=1;f++){e.x=i.x*r+c.x*(1-r),e.y=i.y*y+c.y*(1-y),e.z=i.z*f+c.z*(1-f);const u=n.dot(e);o=Math.min(u,o),a=Math.max(u,a)}this.min=o,this.max=a}})();const ms=(function(){const e=new R,t=new R,n=new R;return function(i,c,o){const a=i.start,r=e,y=c.start,f=t;n.subVectors(a,y),e.subVectors(i.end,i.start),t.subVectors(c.end,c.start);const u=n.dot(f),l=f.dot(r),p=f.dot(f),g=n.dot(r),w=r.dot(r)*p-l*l;let B,d;w!==0?B=(u*l-g*p)/w:B=0,d=(u+B*l)/p,o.x=B,o.y=d}})(),qe=(function(){const e=new ct,t=new R,n=new R;return function(i,c,o,a){ms(i,c,e);let r=e.x,y=e.y;if(r>=0&&r<=1&&y>=0&&y<=1){i.at(r,o),c.at(y,a);return}else if(r>=0&&r<=1){y<0?c.at(0,a):c.at(1,a),i.closestPointToPoint(a,!0,o);return}else if(y>=0&&y<=1){r<0?i.at(0,o):i.at(1,o),c.closestPointToPoint(o,!0,a);return}else{let f;r<0?f=i.start:f=i.end;let u;y<0?u=c.start:u=c.end;const l=t,p=n;if(i.closestPointToPoint(u,!0,t),c.closestPointToPoint(f,!0,n),l.distanceToSquared(u)<=p.distanceToSquared(f)){o.copy(l),a.copy(u);return}else{o.copy(f),a.copy(p);return}}}})(),hs=(function(){const e=new R,t=new R,n=new hn,s=new G;return function(c,o){const{radius:a,center:r}=c,{a:y,b:f,c:u}=o;if(s.start=y,s.end=f,s.closestPointToPoint(r,!0,e).distanceTo(r)<=a||(s.start=y,s.end=u,s.closestPointToPoint(r,!0,e).distanceTo(r)<=a)||(s.start=f,s.end=u,s.closestPointToPoint(r,!0,e).distanceTo(r)<=a))return!0;const A=o.getPlane(n);if(Math.abs(A.distanceToPoint(r))<=a){const B=A.projectPoint(r,t);if(o.containsPoint(B))return!0}return!1}})(),xs=["x","y","z"],J=1e-15,Ge=J*J;function X(e){return Math.abs(e)<J}class K extends Bt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new R),this.satBounds=new Array(4).fill().map(()=>new tt),this.points=[this.a,this.b,this.c],this.plane=new hn,this.isDegenerateIntoSegment=!1,this.isDegenerateIntoPoint=!1,this.degenerateSegment=new G,this.needsUpdate=!0}intersectsSphere(t){return hs(t,this)}update(){const t=this.a,n=this.b,s=this.c,i=this.points,c=this.satAxes,o=this.satBounds,a=c[0],r=o[0];this.getNormal(a),r.setFromPoints(a,i);const y=c[1],f=o[1];y.subVectors(t,n),f.setFromPoints(y,i);const u=c[2],l=o[2];u.subVectors(n,s),l.setFromPoints(u,i);const p=c[3],g=o[3];p.subVectors(s,t),g.setFromPoints(p,i);const A=y.length(),w=u.length(),B=p.length();this.isDegenerateIntoPoint=!1,this.isDegenerateIntoSegment=!1,A<J?w<J||B<J?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(t),this.degenerateSegment.end.copy(s)):w<J?B<J?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(n),this.degenerateSegment.end.copy(t)):B<J&&(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(s),this.degenerateSegment.end.copy(n)),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}K.prototype.closestPointToSegment=(function(){const e=new R,t=new R,n=new G;return function(i,c=null,o=null){const{start:a,end:r}=i,y=this.points;let f,u=1/0;for(let l=0;l<3;l++){const p=(l+1)%3;n.start.copy(y[l]),n.end.copy(y[p]),qe(n,i,e,t),f=e.distanceToSquared(t),f<u&&(u=f,c&&c.copy(e),o&&o.copy(t))}return this.closestPointToPoint(a,e),f=a.distanceToSquared(e),f<u&&(u=f,c&&c.copy(e),o&&o.copy(a)),this.closestPointToPoint(r,e),f=r.distanceToSquared(e),f<u&&(u=f,c&&c.copy(e),o&&o.copy(r)),Math.sqrt(u)}})();K.prototype.intersectsTriangle=(function(){const e=new K,t=new tt,n=new tt,s=new R,i=new R,c=new R,o=new R,a=new G,r=new G,y=new R,f=new ct,u=new ct;function l(h,m,x,S){const T=s;!h.isDegenerateIntoPoint&&!h.isDegenerateIntoSegment?T.copy(h.plane.normal):T.copy(m.plane.normal);const _=h.satBounds,M=h.satAxes;for(let P=1;P<4;P++){const I=_[P],C=M[P];if(t.setFromPoints(C,m.points),I.isSeparated(t)||(o.copy(T).cross(C),t.setFromPoints(o,h.points),n.setFromPoints(o,m.points),t.isSeparated(n)))return!1}const b=m.satBounds,v=m.satAxes;for(let P=1;P<4;P++){const I=b[P],C=v[P];if(t.setFromPoints(C,h.points),I.isSeparated(t)||(o.crossVectors(T,C),t.setFromPoints(o,h.points),n.setFromPoints(o,m.points),t.isSeparated(n)))return!1}return x&&(x.start.set(0,0,0),x.end.set(0,0,0)),!0}function p(h,m,x,S,T,_,M,b,v,P,I){let C=M/(M-b);P.x=S+(T-S)*C,I.start.subVectors(m,h).multiplyScalar(C).add(h),C=M/(M-v),P.y=S+(_-S)*C,I.end.subVectors(x,h).multiplyScalar(C).add(h)}function g(h,m,x,S,T,_,M,b,v,P,I){if(T>0)p(h.c,h.a,h.b,S,m,x,v,M,b,P,I);else if(_>0)p(h.b,h.a,h.c,x,m,S,b,M,v,P,I);else if(b*v>0||M!=0)p(h.a,h.b,h.c,m,x,S,M,b,v,P,I);else if(b!=0)p(h.b,h.a,h.c,x,m,S,b,M,v,P,I);else if(v!=0)p(h.c,h.a,h.b,S,m,x,v,M,b,P,I);else return!0;return!1}function A(h,m,x,S){const T=m.degenerateSegment,_=h.plane.distanceToPoint(T.start),M=h.plane.distanceToPoint(T.end);return X(_)?X(M)?l(h,m,x,S):(x&&(x.start.copy(T.start),x.end.copy(T.start)),h.containsPoint(T.start)):X(M)?(x&&(x.start.copy(T.end),x.end.copy(T.end)),h.containsPoint(T.end)):h.plane.intersectLine(T,s)!=null?(x&&(x.start.copy(s),x.end.copy(s)),h.containsPoint(s)):!1}function w(h,m,x){const S=m.a;return X(h.plane.distanceToPoint(S))&&h.containsPoint(S)?(x&&(x.start.copy(S),x.end.copy(S)),!0):!1}function B(h,m,x){const S=h.degenerateSegment,T=m.a;return S.closestPointToPoint(T,!0,s),T.distanceToSquared(s)<Ge?(x&&(x.start.copy(T),x.end.copy(T)),!0):!1}function d(h,m,x,S){if(h.isDegenerateIntoSegment)if(m.isDegenerateIntoSegment){const T=h.degenerateSegment,_=m.degenerateSegment,M=i,b=c;T.delta(M),_.delta(b);const v=s.subVectors(_.start,T.start),P=M.x*b.y-M.y*b.x;if(X(P))return!1;const I=(v.x*b.y-v.y*b.x)/P,C=-(M.x*v.y-M.y*v.x)/P;if(I<0||I>1||C<0||C>1)return!1;const E=T.start.z+M.z*I,D=_.start.z+b.z*C;return X(E-D)?(x&&(x.start.copy(T.start).addScaledVector(M,I),x.end.copy(T.start).addScaledVector(M,I)),!0):!1}else return m.isDegenerateIntoPoint?B(h,m,x):A(m,h,x,S);else{if(h.isDegenerateIntoPoint)return m.isDegenerateIntoPoint?m.a.distanceToSquared(h.a)<Ge?(x&&(x.start.copy(h.a),x.end.copy(h.a)),!0):!1:m.isDegenerateIntoSegment?B(m,h,x):w(m,h,x);if(m.isDegenerateIntoPoint)return w(h,m,x);if(m.isDegenerateIntoSegment)return A(h,m,x,S)}}return function(m,x=null,S=!1){this.needsUpdate&&this.update(),m.isExtendedTriangle?m.needsUpdate&&m.update():(e.copy(m),e.update(),m=e);const T=d(this,m,x,S);if(T!==void 0)return T;const _=this.plane,M=m.plane;let b=M.distanceToPoint(this.a),v=M.distanceToPoint(this.b),P=M.distanceToPoint(this.c);X(b)&&(b=0),X(v)&&(v=0),X(P)&&(P=0);const I=b*v,C=b*P;if(I>0&&C>0)return!1;let E=_.distanceToPoint(m.a),D=_.distanceToPoint(m.b),Dt=_.distanceToPoint(m.c);X(E)&&(E=0),X(D)&&(D=0),X(Dt)&&(Dt=0);const $e=E*D,Oe=E*Dt;if($e>0&&Oe>0)return!1;i.copy(_.normal),c.copy(M.normal);const fe=i.cross(c);let pe=0,ye=Math.abs(fe.x);const Ze=Math.abs(fe.y);Ze>ye&&(ye=Ze,pe=1),Math.abs(fe.z)>ye&&(pe=2);const pt=xs[pe],Un=this.a[pt],Vn=this.b[pt],Fn=this.c[pt],Nn=m.a[pt],Hn=m.b[pt],qn=m.c[pt];if(g(this,Un,Vn,Fn,I,C,b,v,P,f,a))return l(this,m,x,S);if(g(m,Nn,Hn,qn,$e,Oe,E,D,Dt,u,r))return l(this,m,x,S);if(f.y<f.x){const de=f.y;f.y=f.x,f.x=de,y.copy(a.start),a.start.copy(a.end),a.end.copy(y)}if(u.y<u.x){const de=u.y;u.y=u.x,u.x=de,y.copy(r.start),r.start.copy(r.end),r.end.copy(y)}return f.y<u.x||u.y<f.x?!1:(x&&(u.x>f.x?x.start.copy(r.start):x.start.copy(a.start),u.y<f.y?x.end.copy(r.end):x.end.copy(a.end)),!0)}})();K.prototype.distanceToPoint=(function(){const e=new R;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}})();K.prototype.distanceToTriangle=(function(){const e=new R,t=new R,n=["a","b","c"],s=new G,i=new G;return function(o,a=null,r=null){const y=a||r?s:null;if(this.intersectsTriangle(o,y))return(a||r)&&(a&&y.getCenter(a),r&&y.getCenter(r)),0;let f=1/0;for(let u=0;u<3;u++){let l;const p=n[u],g=o[p];this.closestPointToPoint(g,e),l=g.distanceToSquared(e),l<f&&(f=l,a&&a.copy(e),r&&r.copy(g));const A=this[p];o.closestPointToPoint(A,e),l=A.distanceToSquared(e),l<f&&(f=l,a&&a.copy(A),r&&r.copy(e))}for(let u=0;u<3;u++){const l=n[u],p=n[(u+1)%3];s.set(this[l],this[p]);for(let g=0;g<3;g++){const A=n[g],w=n[(g+1)%3];i.set(o[A],o[w]),qe(s,i,e,t);const B=e.distanceToSquared(t);B<f&&(f=B,a&&a.copy(e),r&&r.copy(t))}}return Math.sqrt(f)}})();class k{constructor(t,n,s){this.isOrientedBox=!0,this.min=new R,this.max=new R,this.matrix=new rt,this.invMatrix=new rt,this.points=new Array(8).fill().map(()=>new R),this.satAxes=new Array(3).fill().map(()=>new R),this.satBounds=new Array(3).fill().map(()=>new tt),this.alignedSatBounds=new Array(3).fill().map(()=>new tt),this.needsUpdate=!1,t&&this.min.copy(t),n&&this.max.copy(n),s&&this.matrix.copy(s)}set(t,n,s){this.min.copy(t),this.max.copy(n),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}k.prototype.update=(function(){return function(){const t=this.matrix,n=this.min,s=this.max,i=this.points;for(let y=0;y<=1;y++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const l=1*y|2*f|4*u,p=i[l];p.x=y?s.x:n.x,p.y=f?s.y:n.y,p.z=u?s.z:n.z,p.applyMatrix4(t)}const c=this.satBounds,o=this.satAxes,a=i[0];for(let y=0;y<3;y++){const f=o[y],u=c[y],l=1<<y,p=i[l];f.subVectors(a,p),u.setFromPoints(f,i)}const r=this.alignedSatBounds;r[0].setFromPointsField(i,"x"),r[1].setFromPointsField(i,"y"),r[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();k.prototype.intersectsBox=(function(){const e=new tt;return function(n){this.needsUpdate&&this.update();const s=n.min,i=n.max,c=this.satBounds,o=this.satAxes,a=this.alignedSatBounds;if(e.min=s.x,e.max=i.x,a[0].isSeparated(e)||(e.min=s.y,e.max=i.y,a[1].isSeparated(e))||(e.min=s.z,e.max=i.z,a[2].isSeparated(e)))return!1;for(let r=0;r<3;r++){const y=o[r],f=c[r];if(e.setFromBox(y,n),f.isSeparated(e))return!1}return!0}})();k.prototype.intersectsTriangle=(function(){const e=new K,t=new Array(3),n=new tt,s=new tt,i=new R;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(e.copy(o),e.update(),o=e);const a=this.satBounds,r=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let l=0;l<3;l++){const p=a[l],g=r[l];if(n.setFromPoints(g,t),p.isSeparated(n))return!1}const y=o.satBounds,f=o.satAxes,u=this.points;for(let l=0;l<3;l++){const p=y[l],g=f[l];if(n.setFromPoints(g,u),p.isSeparated(n))return!1}for(let l=0;l<3;l++){const p=r[l];for(let g=0;g<4;g++){const A=f[g];if(i.crossVectors(p,A),n.setFromPoints(i,t),s.setFromPoints(i,u),n.isSeparated(s))return!1}}return!0}})();k.prototype.closestPointToPoint=(function(){return function(t,n){return this.needsUpdate&&this.update(),n.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),n}})();k.prototype.distanceToPoint=(function(){const e=new R;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}})();k.prototype.distanceToBox=(function(){const e=["x","y","z"],t=new Array(12).fill().map(()=>new G),n=new Array(12).fill().map(()=>new G),s=new R,i=new R;return function(o,a=0,r=null,y=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(r||y)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),r&&r.copy(s),y&&y.copy(i)),0;const f=a*a,u=o.min,l=o.max,p=this.points;let g=1/0;for(let w=0;w<8;w++){const B=p[w];i.copy(B).clamp(u,l);const d=B.distanceToSquared(i);if(d<g&&(g=d,r&&r.copy(B),y&&y.copy(i),d<f))return Math.sqrt(d)}let A=0;for(let w=0;w<3;w++)for(let B=0;B<=1;B++)for(let d=0;d<=1;d++){const h=(w+1)%3,m=(w+2)%3,x=B<<h|d<<m,S=1<<w|B<<h|d<<m,T=p[x],_=p[S];t[A].set(T,_);const b=e[w],v=e[h],P=e[m],I=n[A],C=I.start,E=I.end;C[b]=u[b],C[v]=B?u[v]:l[v],C[P]=d?u[P]:l[v],E[b]=l[b],E[v]=B?u[v]:l[v],E[P]=d?u[P]:l[v],A++}for(let w=0;w<=1;w++)for(let B=0;B<=1;B++)for(let d=0;d<=1;d++){i.x=w?l.x:u.x,i.y=B?l.y:u.y,i.z=d?l.z:u.z,this.closestPointToPoint(i,s);const h=i.distanceToSquared(s);if(h<g&&(g=h,r&&r.copy(s),y&&y.copy(i),h<f))return Math.sqrt(h)}for(let w=0;w<12;w++){const B=t[w];for(let d=0;d<12;d++){const h=n[d];qe(B,h,s,i);const m=s.distanceToSquared(i);if(m<g&&(g=m,r&&r.copy(s),y&&y.copy(i),m<f))return Math.sqrt(m)}}return Math.sqrt(g)}})();class gs extends Ne{constructor(){super(()=>new K)}}const Y=new gs,St=new R,Be=new R;function ws(e,t,n={},s=0,i=1/0){const c=s*s,o=i*i;let a=1/0,r=null;if(e.shapecast({boundsTraverseOrder:f=>(St.copy(t).clamp(f.min,f.max),St.distanceToSquared(t)),intersectsBounds:(f,u,l)=>l<a&&l<o,intersectsTriangle:(f,u)=>{f.closestPointToPoint(t,St);const l=t.distanceToSquared(St);return l<a&&(Be.copy(St),a=l,r=u),l<c}}),a===1/0)return null;const y=Math.sqrt(a);return n.point?n.point.copy(Be):n.point=Be.clone(),n.distance=y,n.faceIndex=r,n}const Ht=parseInt(xn)>=169,As=parseInt(xn)<=161,lt=new R,ut=new R,ft=new R,qt=new ct,$t=new ct,Ot=new ct,tn=new R,en=new R,nn=new R,_t=new R;function Bs(e,t,n,s,i,c,o,a){let r;if(c===$n?r=e.intersectTriangle(s,n,t,!0,i):r=e.intersectTriangle(t,n,s,c!==On,i),r===null)return null;const y=e.origin.distanceTo(i);return y<o||y>a?null:{distance:y,point:i.clone()}}function sn(e,t,n,s,i,c,o,a,r,y,f){lt.fromBufferAttribute(t,c),ut.fromBufferAttribute(t,o),ft.fromBufferAttribute(t,a);const u=Bs(e,lt,ut,ft,_t,r,y,f);if(u){if(s){qt.fromBufferAttribute(s,c),$t.fromBufferAttribute(s,o),Ot.fromBufferAttribute(s,a),u.uv=new ct;const p=Bt.getInterpolation(_t,lt,ut,ft,qt,$t,Ot,u.uv);Ht||(u.uv=p)}if(i){qt.fromBufferAttribute(i,c),$t.fromBufferAttribute(i,o),Ot.fromBufferAttribute(i,a),u.uv1=new ct;const p=Bt.getInterpolation(_t,lt,ut,ft,qt,$t,Ot,u.uv1);Ht||(u.uv1=p),As&&(u.uv2=u.uv1)}if(n){tn.fromBufferAttribute(n,c),en.fromBufferAttribute(n,o),nn.fromBufferAttribute(n,a),u.normal=new R;const p=Bt.getInterpolation(_t,lt,ut,ft,tn,en,nn,u.normal);u.normal.dot(e.direction)>0&&u.normal.multiplyScalar(-1),Ht||(u.normal=p)}const l={a:c,b:o,c:a,normal:new R,materialIndex:0};if(Bt.getNormal(lt,ut,ft,l.normal),u.face=l,u.faceIndex=c,Ht){const p=new R;Bt.getBarycoord(_t,lt,ut,ft,p),u.barycoord=p}}return u}function on(e){return e&&e.isMaterial?e.side:e}function ue(e,t,n,s,i,c,o){const a=s*3;let r=a+0,y=a+1,f=a+2;const{index:u,groups:l}=e;e.index&&(r=u.getX(r),y=u.getX(y),f=u.getX(f));const{position:p,normal:g,uv:A,uv1:w}=e.attributes;if(Array.isArray(t)){const B=s*3;for(let d=0,h=l.length;d<h;d++){const{start:m,count:x,materialIndex:S}=l[d];if(B>=m&&B<m+x){const T=on(t[S]),_=sn(n,p,g,A,w,r,y,f,T,c,o);if(_)if(_.faceIndex=s,_.face.materialIndex=S,i)i.push(_);else return _}}}else{const B=on(t),d=sn(n,p,g,A,w,r,y,f,B,c,o);if(d)if(d.faceIndex=s,d.face.materialIndex=0,i)i.push(d);else return d}return null}function U(e,t,n,s){const i=e.a,c=e.b,o=e.c;let a=t,r=t+1,y=t+2;n&&(a=n.getX(a),r=n.getX(r),y=n.getX(y)),i.x=s.getX(a),i.y=s.getY(a),i.z=s.getZ(a),c.x=s.getX(r),c.y=s.getY(r),c.z=s.getZ(r),o.x=s.getX(y),o.y=s.getY(y),o.z=s.getZ(y)}function Ts(e,t,n,s,i,c,o,a){const{geometry:r,_indirectBuffer:y}=e;for(let f=s,u=s+i;f<u;f++)ue(r,t,n,f,c,o,a)}function Ps(e,t,n,s,i,c,o){const{geometry:a,_indirectBuffer:r}=e;let y=1/0,f=null;for(let u=s,l=s+i;u<l;u++){let p;p=ue(a,t,n,u,null,c,o),p&&p.distance<y&&(f=p,y=p.distance)}return f}function bs(e,t,n,s,i,c,o){const{geometry:a}=n,{index:r}=a,y=a.attributes.position;for(let f=e,u=t+e;f<u;f++){let l;if(l=f,U(o,l*3,r,y),o.needsUpdate=!0,s(o,l,i,c))return!0}return!1}function Ss(e,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,s=n.index?n.index.array:null,i=n.attributes.position;let c,o,a,r,y=0;const f=e._roots;for(let l=0,p=f.length;l<p;l++)c=f[l],o=new Uint32Array(c),a=new Uint16Array(c),r=new Float32Array(c),u(0,y),y+=c.byteLength;function u(l,p,g=!1){const A=l*2;if(F(A,a)){const w=O(l,o),B=Z(A,a);let d=1/0,h=1/0,m=1/0,x=-1/0,S=-1/0,T=-1/0;for(let _=3*w,M=3*(w+B);_<M;_++){let b=s[_];const v=i.getX(b),P=i.getY(b),I=i.getZ(b);v<d&&(d=v),v>x&&(x=v),P<h&&(h=P),P>S&&(S=P),I<m&&(m=I),I>T&&(T=I)}return r[l+0]!==d||r[l+1]!==h||r[l+2]!==m||r[l+3]!==x||r[l+4]!==S||r[l+5]!==T?(r[l+0]=d,r[l+1]=h,r[l+2]=m,r[l+3]=x,r[l+4]=S,r[l+5]=T,!0):!1}else{const w=N(l),B=H(l,o);let d=g,h=!1,m=!1;if(t){if(!d){const b=w/V+p/$,v=B/V+p/$;h=t.has(b),m=t.has(v),d=!h&&!m}}else h=!0,m=!0;const x=d||h,S=d||m;let T=!1;x&&(T=u(w,p,d));let _=!1;S&&(_=u(B,p,d));const M=T||_;if(M)for(let b=0;b<3;b++){const v=w+b,P=B+b,I=r[v],C=r[v+3],E=r[P],D=r[P+3];r[l+b]=I<E?I:E,r[l+b+3]=C>D?C:D}return M}}}function at(e,t,n,s,i){let c,o,a,r,y,f;const u=1/n.direction.x,l=1/n.direction.y,p=1/n.direction.z,g=n.origin.x,A=n.origin.y,w=n.origin.z;let B=t[e],d=t[e+3],h=t[e+1],m=t[e+3+1],x=t[e+2],S=t[e+3+2];return u>=0?(c=(B-g)*u,o=(d-g)*u):(c=(d-g)*u,o=(B-g)*u),l>=0?(a=(h-A)*l,r=(m-A)*l):(a=(m-A)*l,r=(h-A)*l),c>r||a>o||((a>c||isNaN(c))&&(c=a),(r<o||isNaN(o))&&(o=r),p>=0?(y=(x-w)*p,f=(S-w)*p):(y=(S-w)*p,f=(x-w)*p),c>f||y>o)?!1:((y>c||c!==c)&&(c=y),(f<o||o!==o)&&(o=f),c<=i&&o>=s)}function _s(e,t,n,s,i,c,o,a){const{geometry:r,_indirectBuffer:y}=e;for(let f=s,u=s+i;f<u;f++){let l=y?y[f]:f;ue(r,t,n,l,c,o,a)}}function Ms(e,t,n,s,i,c,o){const{geometry:a,_indirectBuffer:r}=e;let y=1/0,f=null;for(let u=s,l=s+i;u<l;u++){let p;p=ue(a,t,n,r?r[u]:u,null,c,o),p&&p.distance<y&&(f=p,y=p.distance)}return f}function vs(e,t,n,s,i,c,o){const{geometry:a}=n,{index:r}=a,y=a.attributes.position;for(let f=e,u=t+e;f<u;f++){let l;if(l=n.resolveTriangleIndex(f),U(o,l*3,r,y),o.needsUpdate=!0,s(o,l,i,c))return!0}return!1}function Is(e,t,n,s,i,c,o){L.setBuffer(e._roots[t]),Ce(0,e,n,s,i,c,o),L.clearBuffer()}function Ce(e,t,n,s,i,c,o){const{float32Array:a,uint16Array:r,uint32Array:y}=L,f=e*2;if(F(f,r)){const l=O(e,y),p=Z(f,r);Ts(t,n,s,l,p,i,c,o)}else{const l=N(e);at(l,a,s,c,o)&&Ce(l,t,n,s,i,c,o);const p=H(e,y);at(p,a,s,c,o)&&Ce(p,t,n,s,i,c,o)}}const Cs=["x","y","z"];function Rs(e,t,n,s,i,c){L.setBuffer(e._roots[t]);const o=Re(0,e,n,s,i,c);return L.clearBuffer(),o}function Re(e,t,n,s,i,c){const{float32Array:o,uint16Array:a,uint32Array:r}=L;let y=e*2;if(F(y,a)){const u=O(e,r),l=Z(y,a);return Ps(t,n,s,u,l,i,c)}else{const u=Fe(e,r),l=Cs[u],g=s.direction[l]>=0;let A,w;g?(A=N(e),w=H(e,r)):(A=H(e,r),w=N(e));const d=at(A,o,s,i,c)?Re(A,t,n,s,i,c):null;if(d){const x=d.point[l];if(g?x<=o[w+u]:x>=o[w+u+3])return d}const m=at(w,o,s,i,c)?Re(w,t,n,s,i,c):null;return d&&m?d.distance<=m.distance?d:m:d||m||null}}const Zt=new W,xt=new K,gt=new K,Mt=new rt,rn=new k,kt=new k;function Es(e,t,n,s){L.setBuffer(e._roots[t]);const i=Ee(0,e,n,s);return L.clearBuffer(),i}function Ee(e,t,n,s,i=null){const{float32Array:c,uint16Array:o,uint32Array:a}=L;let r=e*2;if(i===null&&(n.boundingBox||n.computeBoundingBox(),rn.set(n.boundingBox.min,n.boundingBox.max,s),i=rn),F(r,o)){const f=t.geometry,u=f.index,l=f.attributes.position,p=n.index,g=n.attributes.position,A=O(e,a),w=Z(r,o);if(Mt.copy(s).invert(),n.boundsTree)return z(e,c,kt),kt.matrix.copy(Mt),kt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:d=>kt.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let h=A*3,m=(w+A)*3;h<m;h+=3)if(U(gt,h,u,l),gt.needsUpdate=!0,d.intersectsTriangle(gt))return!0;return!1}});{const B=le(n);for(let d=A*3,h=(w+A)*3;d<h;d+=3){U(xt,d,u,l),xt.a.applyMatrix4(Mt),xt.b.applyMatrix4(Mt),xt.c.applyMatrix4(Mt),xt.needsUpdate=!0;for(let m=0,x=B*3;m<x;m+=3)if(U(gt,m,p,g),gt.needsUpdate=!0,xt.intersectsTriangle(gt))return!0}}}else{const f=N(e),u=H(e,a);return z(f,c,Zt),!!(i.intersectsBox(Zt)&&Ee(f,t,n,s,i)||(z(u,c,Zt),i.intersectsBox(Zt)&&Ee(u,t,n,s,i)))}}const Xt=new rt,Te=new k,vt=new k,Ls=new R,zs=new R,Ds=new R,Us=new R;function Vs(e,t,n,s={},i={},c=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Te.set(t.boundingBox.min,t.boundingBox.max,n),Te.needsUpdate=!0;const a=e.geometry,r=a.attributes.position,y=a.index,f=t.attributes.position,u=t.index,l=Y.getPrimitive(),p=Y.getPrimitive();let g=Ls,A=zs,w=null,B=null;i&&(w=Ds,B=Us);let d=1/0,h=null,m=null;return Xt.copy(n).invert(),vt.matrix.copy(Xt),e.shapecast({boundsTraverseOrder:x=>Te.distanceToBox(x),intersectsBounds:(x,S,T)=>T<d&&T<o?(S&&(vt.min.copy(x.min),vt.max.copy(x.max),vt.needsUpdate=!0),!0):!1,intersectsRange:(x,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:_=>vt.distanceToBox(_),intersectsBounds:(_,M,b)=>b<d&&b<o,intersectsRange:(_,M)=>{for(let b=_,v=_+M;b<v;b++){U(p,3*b,u,f),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let P=x,I=x+S;P<I;P++){U(l,3*P,y,r),l.needsUpdate=!0;const C=l.distanceToTriangle(p,g,w);if(C<d&&(A.copy(g),B&&B.copy(w),d=C,h=P,m=b),C<c)return!0}}}});{const T=le(t);for(let _=0,M=T;_<M;_++){U(p,3*_,u,f),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let b=x,v=x+S;b<v;b++){U(l,3*b,y,r),l.needsUpdate=!0;const P=l.distanceToTriangle(p,g,w);if(P<d&&(A.copy(g),B&&B.copy(w),d=P,h=b,m=_),P<c)return!0}}}}}),Y.releasePrimitive(l),Y.releasePrimitive(p),d===1/0?null:(s.point?s.point.copy(A):s.point=A.clone(),s.distance=d,s.faceIndex=h,i&&(i.point?i.point.copy(B):i.point=B.clone(),i.point.applyMatrix4(Xt),A.applyMatrix4(Xt),i.distance=A.sub(i.point).length(),i.faceIndex=m),s)}function Fs(e,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,s=n.index?n.index.array:null,i=n.attributes.position;let c,o,a,r,y=0;const f=e._roots;for(let l=0,p=f.length;l<p;l++)c=f[l],o=new Uint32Array(c),a=new Uint16Array(c),r=new Float32Array(c),u(0,y),y+=c.byteLength;function u(l,p,g=!1){const A=l*2;if(F(A,a)){const w=O(l,o),B=Z(A,a);let d=1/0,h=1/0,m=1/0,x=-1/0,S=-1/0,T=-1/0;for(let _=w,M=w+B;_<M;_++){const b=3*e.resolveTriangleIndex(_);for(let v=0;v<3;v++){let P=b+v;P=s?s[P]:P;const I=i.getX(P),C=i.getY(P),E=i.getZ(P);I<d&&(d=I),I>x&&(x=I),C<h&&(h=C),C>S&&(S=C),E<m&&(m=E),E>T&&(T=E)}}return r[l+0]!==d||r[l+1]!==h||r[l+2]!==m||r[l+3]!==x||r[l+4]!==S||r[l+5]!==T?(r[l+0]=d,r[l+1]=h,r[l+2]=m,r[l+3]=x,r[l+4]=S,r[l+5]=T,!0):!1}else{const w=N(l),B=H(l,o);let d=g,h=!1,m=!1;if(t){if(!d){const b=w/V+p/$,v=B/V+p/$;h=t.has(b),m=t.has(v),d=!h&&!m}}else h=!0,m=!0;const x=d||h,S=d||m;let T=!1;x&&(T=u(w,p,d));let _=!1;S&&(_=u(B,p,d));const M=T||_;if(M)for(let b=0;b<3;b++){const v=w+b,P=B+b,I=r[v],C=r[v+3],E=r[P],D=r[P+3];r[l+b]=I<E?I:E,r[l+b+3]=C>D?C:D}return M}}}function Ns(e,t,n,s,i,c,o){L.setBuffer(e._roots[t]),Le(0,e,n,s,i,c,o),L.clearBuffer()}function Le(e,t,n,s,i,c,o){const{float32Array:a,uint16Array:r,uint32Array:y}=L,f=e*2;if(F(f,r)){const l=O(e,y),p=Z(f,r);_s(t,n,s,l,p,i,c,o)}else{const l=N(e);at(l,a,s,c,o)&&Le(l,t,n,s,i,c,o);const p=H(e,y);at(p,a,s,c,o)&&Le(p,t,n,s,i,c,o)}}const Hs=["x","y","z"];function qs(e,t,n,s,i,c){L.setBuffer(e._roots[t]);const o=ze(0,e,n,s,i,c);return L.clearBuffer(),o}function ze(e,t,n,s,i,c){const{float32Array:o,uint16Array:a,uint32Array:r}=L;let y=e*2;if(F(y,a)){const u=O(e,r),l=Z(y,a);return Ms(t,n,s,u,l,i,c)}else{const u=Fe(e,r),l=Hs[u],g=s.direction[l]>=0;let A,w;g?(A=N(e),w=H(e,r)):(A=H(e,r),w=N(e));const d=at(A,o,s,i,c)?ze(A,t,n,s,i,c):null;if(d){const x=d.point[l];if(g?x<=o[w+u]:x>=o[w+u+3])return d}const m=at(w,o,s,i,c)?ze(w,t,n,s,i,c):null;return d&&m?d.distance<=m.distance?d:m:d||m||null}}const Yt=new W,wt=new K,At=new K,It=new rt,cn=new k,Wt=new k;function $s(e,t,n,s){L.setBuffer(e._roots[t]);const i=De(0,e,n,s);return L.clearBuffer(),i}function De(e,t,n,s,i=null){const{float32Array:c,uint16Array:o,uint32Array:a}=L;let r=e*2;if(i===null&&(n.boundingBox||n.computeBoundingBox(),cn.set(n.boundingBox.min,n.boundingBox.max,s),i=cn),F(r,o)){const f=t.geometry,u=f.index,l=f.attributes.position,p=n.index,g=n.attributes.position,A=O(e,a),w=Z(r,o);if(It.copy(s).invert(),n.boundsTree)return z(e,c,Wt),Wt.matrix.copy(It),Wt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:d=>Wt.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let h=A,m=w+A;h<m;h++)if(U(At,3*t.resolveTriangleIndex(h),u,l),At.needsUpdate=!0,d.intersectsTriangle(At))return!0;return!1}});{const B=le(n);for(let d=A,h=w+A;d<h;d++){const m=t.resolveTriangleIndex(d);U(wt,3*m,u,l),wt.a.applyMatrix4(It),wt.b.applyMatrix4(It),wt.c.applyMatrix4(It),wt.needsUpdate=!0;for(let x=0,S=B*3;x<S;x+=3)if(U(At,x,p,g),At.needsUpdate=!0,wt.intersectsTriangle(At))return!0}}}else{const f=N(e),u=H(e,a);return z(f,c,Yt),!!(i.intersectsBox(Yt)&&De(f,t,n,s,i)||(z(u,c,Yt),i.intersectsBox(Yt)&&De(u,t,n,s,i)))}}const jt=new rt,Pe=new k,Ct=new k,Os=new R,Zs=new R,ks=new R,Xs=new R;function Ys(e,t,n,s={},i={},c=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Pe.set(t.boundingBox.min,t.boundingBox.max,n),Pe.needsUpdate=!0;const a=e.geometry,r=a.attributes.position,y=a.index,f=t.attributes.position,u=t.index,l=Y.getPrimitive(),p=Y.getPrimitive();let g=Os,A=Zs,w=null,B=null;i&&(w=ks,B=Xs);let d=1/0,h=null,m=null;return jt.copy(n).invert(),Ct.matrix.copy(jt),e.shapecast({boundsTraverseOrder:x=>Pe.distanceToBox(x),intersectsBounds:(x,S,T)=>T<d&&T<o?(S&&(Ct.min.copy(x.min),Ct.max.copy(x.max),Ct.needsUpdate=!0),!0):!1,intersectsRange:(x,S)=>{if(t.boundsTree){const T=t.boundsTree;return T.shapecast({boundsTraverseOrder:_=>Ct.distanceToBox(_),intersectsBounds:(_,M,b)=>b<d&&b<o,intersectsRange:(_,M)=>{for(let b=_,v=_+M;b<v;b++){const P=T.resolveTriangleIndex(b);U(p,3*P,u,f),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let I=x,C=x+S;I<C;I++){const E=e.resolveTriangleIndex(I);U(l,3*E,y,r),l.needsUpdate=!0;const D=l.distanceToTriangle(p,g,w);if(D<d&&(A.copy(g),B&&B.copy(w),d=D,h=I,m=b),D<c)return!0}}}})}else{const T=le(t);for(let _=0,M=T;_<M;_++){U(p,3*_,u,f),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let b=x,v=x+S;b<v;b++){const P=e.resolveTriangleIndex(b);U(l,3*P,y,r),l.needsUpdate=!0;const I=l.distanceToTriangle(p,g,w);if(I<d&&(A.copy(g),B&&B.copy(w),d=I,h=b,m=_),I<c)return!0}}}}}),Y.releasePrimitive(l),Y.releasePrimitive(p),d===1/0?null:(s.point?s.point.copy(A):s.point=A.clone(),s.distance=d,s.faceIndex=h,i&&(i.point?i.point.copy(B):i.point=B.clone(),i.point.applyMatrix4(jt),A.applyMatrix4(jt),i.distance=A.sub(i.point).length(),i.faceIndex=m),s)}function an(e,t,n){return e===null?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e)}const Kt=new k,Qt=new Zn,ln=new R,un=new rt,fn=new R,be=["getX","getY","getZ"];class ie extends ds{static serialize(t,n={}){n={cloneBuffers:!0,...n};const s=t.geometry,i=t._roots,c=t._indirectBuffer,o=s.getIndex(),a={version:1,roots:null,index:null,indirectBuffer:null};return n.cloneBuffers?(a.roots=i.map(r=>r.slice()),a.index=o?o.array.slice():null,a.indirectBuffer=c?c.slice():null):(a.roots=i,a.index=o?o.array:null,a.indirectBuffer=c),a}static deserialize(t,n,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:i,roots:c,indirectBuffer:o}=t;t.version||r(c);const a=new ie(n,{...s,[Ve]:!0});if(a._roots=c,a._indirectBuffer=o||null,s.setIndex){const y=n.getIndex();if(y===null){const f=new mn(t.index,1,!1);n.setIndex(f)}else y.array!==i&&(y.array.set(i),y.needsUpdate=!0)}return a;function r(y){for(let f=0;f<y.length;f++){const u=y[f],l=new Uint32Array(u),p=new Uint16Array(u);for(let g=0,A=u.byteLength/$;g<A;g++){const w=V*g,B=2*w;F(B,p)||(l[w+6]=l[w+6]/V-g)}}}}get primitiveStride(){return 3}get resolveTriangleIndex(){return this.resolvePrimitiveIndex}constructor(t,n={}){n.maxLeafTris&&(n={...n,maxLeafSize:n.maxLeafTris}),super(t,n)}shiftTriangleOffsets(t){return super.shiftPrimitiveOffsets(t)}writePrimitiveBounds(t,n,s){const i=this.geometry,c=this._indirectBuffer,o=i.attributes.position,a=i.index?i.index.array:null,y=(c?c[t]:t)*3;let f=y+0,u=y+1,l=y+2;a&&(f=a[f],u=a[u],l=a[l]);for(let p=0;p<3;p++){const g=o[be[p]](f),A=o[be[p]](u),w=o[be[p]](l);let B=g;A<B&&(B=A),w<B&&(B=w);let d=g;A>d&&(d=A),w>d&&(d=w),n[s+p]=B,n[s+p+3]=d}return n}computePrimitiveBounds(t,n,s){const i=this.geometry,c=this._indirectBuffer,o=i.attributes.position,a=i.index?i.index.array:null,r=o.normalized;if(t<0||n+t-s.offset>s.length/6)throw new Error("MeshBVH: compute triangle bounds range is invalid.");const y=o.array,f=o.offset||0;let u=3;o.isInterleavedBufferAttribute&&(u=o.data.stride);const l=["getX","getY","getZ"],p=s.offset;for(let g=t,A=t+n;g<A;g++){const B=(c?c[g]:g)*3,d=(g-p)*6;let h=B+0,m=B+1,x=B+2;a&&(h=a[h],m=a[m],x=a[x]),r||(h=h*u+f,m=m*u+f,x=x*u+f);for(let S=0;S<3;S++){let T,_,M;r?(T=o[l[S]](h),_=o[l[S]](m),M=o[l[S]](x)):(T=y[h+S],_=y[m+S],M=y[x+S]);let b=T;_<b&&(b=_),M<b&&(b=M);let v=T;_>v&&(v=_),M>v&&(v=M);const P=(v-b)/2,I=S*2;s[d+I+0]=b+P,s[d+I+1]=P+(Math.abs(b)+P)*Gt}}return s}raycastObject3D(t,n,s=[]){const{material:i}=t;if(i===void 0)return;un.copy(t.matrixWorld).invert(),Qt.copy(n.ray).applyMatrix4(un),fn.setFromMatrixScale(t.matrixWorld),ln.copy(Qt.direction).multiply(fn);const c=ln.length(),o=n.near/c,a=n.far/c;if(n.firstHitOnly===!0){let r=this.raycastFirst(Qt,i,o,a);r=an(r,t,n),r&&s.push(r)}else{const r=this.raycast(Qt,i,o,a);for(let y=0,f=r.length;y<f;y++){const u=an(r[y],t,n);u&&s.push(u)}}return s}refit(t=null){return(this.indirect?Fs:Ss)(this,t)}raycast(t,n=ke,s=0,i=1/0){const c=this._roots,o=[],a=this.indirect?Ns:Is;for(let r=0,y=c.length;r<y;r++)a(this,r,n,t,o,s,i);return o}raycastFirst(t,n=ke,s=0,i=1/0){const c=this._roots;let o=null;const a=this.indirect?qs:Rs;for(let r=0,y=c.length;r<y;r++){const f=a(this,r,n,t,s,i);f!=null&&(o==null||f.distance<o.distance)&&(o=f)}return o}intersectsGeometry(t,n){let s=!1;const i=this._roots,c=this.indirect?$s:Es;for(let o=0,a=i.length;o<a&&(s=c(this,o,t,n),!s);o++);return s}shapecast(t){const n=Y.getPrimitive(),s=super.shapecast({...t,intersectsPrimitive:t.intersectsTriangle,scratchPrimitive:n,iterate:this.indirect?vs:bs});return Y.releasePrimitive(n),s}bvhcast(t,n,s){let{intersectsRanges:i,intersectsTriangles:c}=s;const o=Y.getPrimitive(),a=this.geometry.index,r=this.geometry.attributes.position,y=this.indirect?g=>{const A=this.resolveTriangleIndex(g);U(o,A*3,a,r)}:g=>{U(o,g*3,a,r)},f=Y.getPrimitive(),u=t.geometry.index,l=t.geometry.attributes.position,p=t.indirect?g=>{const A=t.resolveTriangleIndex(g);U(f,A*3,u,l)}:g=>{U(f,g*3,u,l)};if(c){if(!(t instanceof ie))throw new Error('MeshBVH: "intersectsTriangles" callback can only be used with another MeshBVH.');const g=(A,w,B,d,h,m,x,S)=>{for(let T=B,_=B+d;T<_;T++){p(T),f.a.applyMatrix4(n),f.b.applyMatrix4(n),f.c.applyMatrix4(n),f.needsUpdate=!0;for(let M=A,b=A+w;M<b;M++)if(y(M),o.needsUpdate=!0,c(o,f,M,T,h,m,x,S))return!0}return!1};if(i){const A=i;i=function(w,B,d,h,m,x,S,T){return A(w,B,d,h,m,x,S,T)?!0:g(w,B,d,h,m,x,S,T)}}else i=g}return super.bvhcast(t,n,{intersectsRanges:i})}intersectsBox(t,n){return Kt.set(t.min,t.max,n),Kt.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Kt.intersectsBox(s),intersectsTriangle:s=>Kt.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:n=>t.intersectsBox(n),intersectsTriangle:n=>n.intersectsSphere(t)})}closestPointToGeometry(t,n,s={},i={},c=0,o=1/0){return(this.indirect?Ys:Vs)(this,t,n,s,i,c,o)}closestPointToPoint(t,n={},s=0,i=1/0){return ws(this,t,n,s,i)}}const Tt={Mesh:zt.prototype.raycast,Line:An.prototype.raycast,LineSegments:gn.prototype.raycast,LineLoop:wn.prototype.raycast,Points:Bn.prototype.raycast,BatchedMesh:Xn.prototype.raycast},q=new zt,Jt=[];function Ws(e,t){if(this.isBatchedMesh)js.call(this,e,t);else{const{geometry:n}=this;if(n.boundsTree)n.boundsTree.raycastObject3D(this,e,t);else{let s;if(this instanceof zt)s=Tt.Mesh;else if(this instanceof gn)s=Tt.LineSegments;else if(this instanceof wn)s=Tt.LineLoop;else if(this instanceof An)s=Tt.Line;else if(this instanceof Bn)s=Tt.Points;else throw new Error("BVH: Fallback raycast function not found.");s.call(this,e,t)}}}function js(e,t){if(this.boundsTrees){const n=this.boundsTrees,s=this._drawInfo||this._instanceInfo,i=this._drawRanges||this._geometryInfo,c=this.matrixWorld;q.material=this.material,q.geometry=this.geometry;const o=q.geometry.boundsTree,a=q.geometry.drawRange;q.geometry.boundingSphere===null&&(q.geometry.boundingSphere=new kn);for(let r=0,y=s.length;r<y;r++){if(!this.getVisibleAt(r))continue;const f=s[r].geometryIndex;if(q.geometry.boundsTree=n[f],this.getMatrixAt(r,q.matrixWorld).premultiply(c),!q.geometry.boundsTree){this.getBoundingBoxAt(f,q.geometry.boundingBox),this.getBoundingSphereAt(f,q.geometry.boundingSphere);const u=i[f];q.geometry.setDrawRange(u.start,u.count)}q.raycast(e,Jt);for(let u=0,l=Jt.length;u<l;u++){const p=Jt[u];p.object=this,p.batchId=r,t.push(p)}Jt.length=0}q.geometry.boundsTree=o,q.geometry.drawRange=a,q.material=null,q.geometry=null}else Tt.BatchedMesh.call(this,e,t)}function Ks(e={}){const{type:t=ie}=e;return this.boundsTree=new t(this,e),this.boundsTree}function Qs(){this.boundsTree=null}Sn.prototype.computeBoundsTree=Ks;Sn.prototype.disposeBoundsTree=Qs;zt.prototype.raycast=Ws;const pn=[];function wi(e){pn.length=0,pn.push(...e)}let Rn=null,En=null,Ln=null,zn=null;function Ai(){return Rn}function Js(){return En}function Bi(){return Ln}function Ti(){return zn}function Pi(e){Rn=e}function bi(e){En=e}function Si(e){Ln=e}function _i(e){zn=e}let Gs=1.7,ti=0,ei=200,ni=.4,si=1;function Mi(e){Gs=e}function vi(e){ti=e}function Ii(e){ei=e}function Ci(e){ni=e}function Ri(e){si=e}const Ei=Ue(!1),Li=!1,zi=Ue(!1),Lt=[],yn=[],dn=[],Di=new Map,Ui=new bn,Vi=new bn,ii=[];for(let e=0;e<8;e++){const t=e/8*Math.PI*2;ii.push(new R(Math.cos(t),0,Math.sin(t)))}const Fi=new Pn(26248),Ni=.8,Hi=new Pn(21862),qi=.4;function $i(e){return Math.round(e*1e4)/1e4}function Oi(e){return e.split("/").pop()||""}function Zi(e){return e.replace(/\.glb$/i,"").replace(/[-_]/g," ").replace(/\b\w/g,t=>t.toUpperCase())}const Se=new R;function ki(){return Js().getWorldDirection(Se),Math.atan2(Se.x,Se.z)}function nt(e){e&&(e.source?.data?.close&&e.source.data.close(),e.dispose())}function Xi(e){e.traverse(t=>{if(t.geometry&&t.geometry.dispose(),t.material){const n=Array.isArray(t.material)?t.material:[t.material];for(const s of n)nt(s.map),nt(s.normalMap),nt(s.roughnessMap),nt(s.metalnessMap),nt(s.emissiveMap),nt(s.aoMap),nt(s.lightMap),nt(s.alphaMap),s.dispose()}})}function Yi(e){e.traverse(t=>{t.geometry&&t.geometry.dispose()})}function Wi(e,t,n){const s=[];return e.traverse(i=>{if(!i.isMesh||i.userData.isDisplayZone)return;const c=Array.isArray(i.material)?i.material:[i.material];for(const o of c)o.emissive&&(s.push({mesh:i,origEmissive:o.emissive.clone(),origEmissiveIntensity:o.emissiveIntensity??1}),o.emissive.copy(t),o.emissiveIntensity=n)}),s}function ji(e){for(const t of e){const n=Array.isArray(t.mesh.material)?t.mesh.material:[t.mesh.material];for(const s of n)s.emissive&&(s.emissive.copy(t.origEmissive),s.emissiveIntensity=t.origEmissiveIntensity)}}function Ki(e){Dn(e),e.traverse(t=>{if(!t.isMesh)return;let n=Lt.indexOf(t);n>=0&&Lt.splice(n,1),n=yn.indexOf(t),n>=0&&yn.splice(n,1)})}const oi=200;function ri(e){const t=e.geometry;if(!t||t.boundsTree)return;const n=t.index;(n?n.count/3:(t.attributes?.position?.count??0)/3)>oi&&t.computeBoundsTree({strategy:0,maxLeafSize:10})}function ci(e){e.traverse(t=>{t.isMesh&&ri(t)})}const ee=[];let ne=!1;function Qi(e){ee.push(e),ne||ai()}function ai(){if(ee.length===0){ne=!1;return}ne=!0;const e=()=>{const t=ee.shift();t&&ci(t),ee.length>0?typeof Ut<"u"?Ut(e,{timeout:500}):setTimeout(e,0):ne=!1};typeof Ut<"u"?Ut(e,{timeout:500}):setTimeout(e,0)}const li=new Yn({visible:!1}),oe=new Map,ot=new R,re=new R;function ui(e){Dn(e);const t=new W().setFromObject(e);if(t.isEmpty())return;t.getSize(ot),t.getCenter(re);const n=new Tn(ot.x,ot.y,ot.z);n.computeBoundingSphere();const s=new zt(n,li);s.position.copy(re),s.visible=!1,s.matrixAutoUpdate=!1,s.updateMatrix(),s.matrixWorld.copy(s.matrix),s.userData.isCollisionProxy=!0,Lt.push(s),oe.set(e,s)}function Dn(e){const t=oe.get(e);if(!t)return;const n=Lt.indexOf(t);n>=0&&Lt.splice(n,1),t.geometry.dispose(),oe.delete(e)}function Ji(e){for(let t=0;t<dn.length;t++){const n=dn[t],s=oe.get(n.group),i=e?.[t]??new W().setFromObject(n.group);i.isEmpty()||(i.getSize(ot),i.getCenter(re),s?(s.geometry.dispose(),s.geometry=new Tn(ot.x,ot.y,ot.z),s.geometry.computeBoundingSphere(),s.position.copy(re),s.updateMatrix(),s.matrixWorld.copy(s.matrix)):ui(n.group))}}const fi=Ue(!1);function Gi(){return{sidebarOpen:fi}}export{mi as $,ci as A,Hi as B,Lt as C,ii as D,Ui as E,ni as F,Ji as G,ri as H,vi as I,Ri as J,Mi as K,Ci as L,ei as M,Ii as N,wi as O,qi as P,Dn as Q,_i as R,Pi as S,Ni as T,bi as U,Si as V,Li as W,hi as X,xi as Y,gi as Z,Gi as _,Ai as a,Bi as b,Js as c,pn as d,Ei as e,Zi as f,Ti as g,yn as h,Di as i,Oi as j,Ki as k,Yi as l,$i as m,Qi as n,ui as o,dn as p,Vi as q,si as r,ti as s,Gs as t,Xi as u,zi as v,ji as w,Wi as x,Fi as y,ki as z};

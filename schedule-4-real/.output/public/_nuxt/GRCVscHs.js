import{o as Le,c as ze,a as De,l as Ue,N as Dt}from"./Dm1c8T6h.js";import{o as W,j as rt,n as mn,V as R,af as G,g as hn,f as ct,ae as Bt,B as On,w as $n,ak as xn,R as kn,aZ as Xe,a as Lt,aM as gn,aN as wn,K as An,aO as Bn,ag as Xn,a$ as Zn,b0 as Tn,M as Yn,b as Pn,i as bn,J as Sn}from"./DqYnToru.js";function mi(e,t){return Le(),ze("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor","aria-hidden":"true","data-slot":"icon"},[De("path",{"fill-rule":"evenodd",d:"M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z","clip-rule":"evenodd"})])}function hi(e,t){return Le(),ze("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor","aria-hidden":"true","data-slot":"icon"},[De("path",{d:"M18 1.5c2.9 0 5.25 2.35 5.25 5.25v3.75a.75.75 0 0 1-1.5 0V6.75a3.75 3.75 0 1 0-7.5 0v3a3 3 0 0 1 3 3v6.75a3 3 0 0 1-3 3H3.75a3 3 0 0 1-3-3v-6.75a3 3 0 0 1 3-3h9v-3c0-2.9 2.35-5.25 5.25-5.25Z"})])}function xi(e,t){return Le(),ze("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor","aria-hidden":"true","data-slot":"icon"},[De("path",{"fill-rule":"evenodd",d:"M12.516 2.17a.75.75 0 0 0-1.032 0 11.209 11.209 0 0 1-7.877 3.08.75.75 0 0 0-.722.515A12.74 12.74 0 0 0 2.25 9.75c0 5.942 4.064 10.933 9.563 12.348a.749.749 0 0 0 .374 0c5.499-1.415 9.563-6.406 9.563-12.348 0-1.39-.223-2.73-.635-3.985a.75.75 0 0 0-.722-.516l-.143.001c-2.996 0-5.717-1.17-7.734-3.08Zm3.094 8.016a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z","clip-rule":"evenodd"})])}const _n=0,Wn=1,jn=2,Ze=2,pe=1.25,Ye=1,O=32,V=O/4,Mn=65535,Jt=Math.pow(2,-24),Ve=Symbol("SKIP_GENERATION"),vn={strategy:_n,maxDepth:40,maxLeafSize:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null,[Ve]:!1};function z(e,t,n){return n.min.x=t[e],n.min.y=t[e+1],n.min.z=t[e+2],n.max.x=t[e+3],n.max.y=t[e+4],n.max.z=t[e+5],n}function We(e){let t=-1,n=-1/0;for(let s=0;s<3;s++){const i=e[s+3]-e[s];i>n&&(n=i,t=s)}return t}function je(e,t){t.set(e)}function Ke(e,t,n){let s,i;for(let c=0;c<3;c++){const o=c+3;s=e[c],i=t[c],n[c]=s<i?s:i,s=e[o],i=t[o],n[o]=s>i?s:i}}function Ut(e,t,n){for(let s=0;s<3;s++){const i=t[e+2*s],c=t[e+2*s+1],o=i-c,a=i+c;o<n[s]&&(n[s]=o),a>n[s+3]&&(n[s+3]=a)}}function bt(e){const t=e[3]-e[0],n=e[4]-e[1],s=e[5]-e[2];return 2*(t*n+n*s+s*t)}function F(e,t){return t[e+15]===Mn}function $(e,t){return t[e+6]}function k(e,t){return t[e+14]}function N(e){return e+V}function H(e,t){const n=t[e+6];return e+n*V}function Fe(e,t){return t[e+7]}function ye(e,t,n,s,i){let c=1/0,o=1/0,a=1/0,r=-1/0,y=-1/0,u=-1/0,f=1/0,l=1/0,p=1/0,g=-1/0,A=-1/0,w=-1/0;const B=e.offset||0;for(let d=(t-B)*6,h=(t+n-B)*6;d<h;d+=6){const m=e[d+0],x=e[d+1],S=m-x,T=m+x;S<c&&(c=S),T>r&&(r=T),m<f&&(f=m),m>g&&(g=m);const _=e[d+2],M=e[d+3],b=_-M,v=_+M;b<o&&(o=b),v>y&&(y=v),_<l&&(l=_),_>A&&(A=_);const P=e[d+4],I=e[d+5],C=P-I,E=P+I;C<a&&(a=C),E>u&&(u=E),P<p&&(p=P),P>w&&(w=P)}s[0]=c,s[1]=o,s[2]=a,s[3]=r,s[4]=y,s[5]=u,i[0]=f,i[1]=l,i[2]=p,i[3]=g,i[4]=A,i[5]=w}const Q=32,Kn=(e,t)=>e.candidate-t.candidate,et=new Array(Q).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Vt=new Float32Array(6);function Qn(e,t,n,s,i,c){let o=-1,a=0;if(c===_n)o=We(t),o!==-1&&(a=(t[o]+t[o+3])/2);else if(c===Wn)o=We(e),o!==-1&&(a=Jn(n,s,i,o));else if(c===jn){const r=bt(e);let y=pe*i;const u=n.offset||0,f=(s-u)*6,l=(s+i-u)*6;for(let p=0;p<3;p++){const g=t[p],B=(t[p+3]-g)/Q;if(i<Q/4){const d=[...et];d.length=i;let h=0;for(let x=f;x<l;x+=6,h++){const S=d[h];S.candidate=n[x+2*p],S.count=0;const{bounds:T,leftCacheBounds:_,rightCacheBounds:M}=S;for(let b=0;b<3;b++)M[b]=1/0,M[b+3]=-1/0,_[b]=1/0,_[b+3]=-1/0,T[b]=1/0,T[b+3]=-1/0;Ut(x,n,T)}d.sort(Kn);let m=i;for(let x=0;x<m;x++){const S=d[x];for(;x+1<m&&d[x+1].candidate===S.candidate;)d.splice(x+1,1),m--}for(let x=f;x<l;x+=6){const S=n[x+2*p];for(let T=0;T<m;T++){const _=d[T];S>=_.candidate?Ut(x,n,_.rightCacheBounds):(Ut(x,n,_.leftCacheBounds),_.count++)}}for(let x=0;x<m;x++){const S=d[x],T=S.count,_=i-S.count,M=S.leftCacheBounds,b=S.rightCacheBounds;let v=0;T!==0&&(v=bt(M)/r);let P=0;_!==0&&(P=bt(b)/r);const I=Ye+pe*(v*T+P*_);I<y&&(o=p,y=I,a=S.candidate)}}else{for(let m=0;m<Q;m++){const x=et[m];x.count=0,x.candidate=g+B+m*B;const S=x.bounds;for(let T=0;T<3;T++)S[T]=1/0,S[T+3]=-1/0}for(let m=f;m<l;m+=6){let T=~~((n[m+2*p]-g)/B);T>=Q&&(T=Q-1);const _=et[T];_.count++,Ut(m,n,_.bounds)}const d=et[Q-1];je(d.bounds,d.rightCacheBounds);for(let m=Q-2;m>=0;m--){const x=et[m],S=et[m+1];Ke(x.bounds,S.rightCacheBounds,x.rightCacheBounds)}let h=0;for(let m=0;m<Q-1;m++){const x=et[m],S=x.count,T=x.bounds,M=et[m+1].rightCacheBounds;S!==0&&(h===0?je(T,Vt):Ke(T,Vt,Vt)),h+=S;let b=0,v=0;h!==0&&(b=bt(Vt)/r);const P=i-h;P!==0&&(v=bt(M)/r);const I=Ye+pe*(b*h+v*P);I<y&&(o=p,y=I,a=x.candidate)}}}}return{axis:o,pos:a}}function Jn(e,t,n,s){let i=0;const c=e.offset;for(let o=t,a=t+n;o<a;o++)i+=e[(o-c)*6+s*2];return i/n}class de{constructor(){this.boundingData=new Float32Array(6)}}function Gn(e,t,n,s,i,c){let o=s,a=s+i-1;const r=c.pos,y=c.axis*2,u=n.offset||0;for(;;){for(;o<=a&&n[(o-u)*6+y]<r;)o++;for(;o<=a&&n[(a-u)*6+y]>=r;)a--;if(o<a){for(let f=0;f<t;f++){let l=e[o*t+f];e[o*t+f]=e[a*t+f],e[a*t+f]=l}for(let f=0;f<6;f++){const l=o-u,p=a-u,g=n[l*6+f];n[l*6+f]=n[p*6+f],n[p*6+f]=g}o++,a--}else return o}}let In,Gt,Pe,Cn;const ts=Math.pow(2,32);function be(e){return"count"in e?1:1+be(e.left)+be(e.right)}function es(e,t,n){return In=new Float32Array(n),Gt=new Uint32Array(n),Pe=new Uint16Array(n),Cn=new Uint8Array(n),Se(e,t)}function Se(e,t){const n=e/4,s=e/2,i="count"in t,c=t.boundingData;for(let o=0;o<6;o++)In[n+o]=c[o];if(i)return t.buffer?(Cn.set(new Uint8Array(t.buffer),e),e+t.buffer.byteLength):(Gt[n+6]=t.offset,Pe[s+14]=t.count,Pe[s+15]=Mn,e+O);{const{left:o,right:a,splitAxis:r}=t,y=e+O;let u=Se(y,o);const f=e/O,p=u/O-f;if(p>ts)throw new Error("MeshBVH: Cannot store relative child node offset greater than 32 bits.");return Gt[n+6]=p,Gt[n+7]=r,Se(u,a)}}function ns(e,t,n,s,i,c){const{maxDepth:o,verbose:a,maxLeafSize:r,strategy:y,onProgress:u}=i,f=e.primitiveBuffer,l=e.primitiveBufferStride,p=new Float32Array(6);let g=!1;const A=new de;return ye(t,n,s,A.boundingData,p),B(A,n,s,p),A;function w(d){u&&u((d-c.offset)/c.count)}function B(d,h,m,x=null,S=0){if(!g&&S>=o&&(g=!0),m<=r||S>=o)return w(h+m),d.offset=h,d.count=m,d;const T=Qn(d.boundingData,x,t,h,m,y);if(T.axis===-1)return w(h+m),d.offset=h,d.count=m,d;const _=Gn(f,l,t,h,m,T);if(_===h||_===h+m)w(h+m),d.offset=h,d.count=m;else{d.splitAxis=T.axis;const M=new de,b=h,v=_-h;d.left=M,ye(t,b,v,M.boundingData,p),B(M,b,v,p,S+1);const P=new de,I=_,C=m-v;d.right=P,ye(t,I,C,P.boundingData,p),B(P,I,C,p,S+1)}return d}}function ss(e,t){const n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=e.getRootRanges(t.range),i=s[0],c=s[s.length-1],o={offset:i.offset,count:c.offset+c.count-i.offset},a=new Float32Array(6*o.count);a.offset=o.offset,e.computePrimitiveBounds(o.offset,o.count,a),e._roots=s.map(r=>{const y=ns(e,a,r.offset,r.count,t,o),u=be(y),f=new n(O*u);return es(0,y,f),f})}class Ne{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class is{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let n=null;this.setBuffer=s=>{n&&t.push(n),n=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{n=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const L=new is;let it,Pt;const yt=[],Ft=new Ne(()=>new W);function os(e,t,n,s,i,c){it=Ft.getPrimitive(),Pt=Ft.getPrimitive(),yt.push(it,Pt),L.setBuffer(e._roots[t]);const o=_e(0,e.geometry,n,s,i,c);L.clearBuffer(),Ft.releasePrimitive(it),Ft.releasePrimitive(Pt),yt.pop(),yt.pop();const a=yt.length;return a>0&&(Pt=yt[a-1],it=yt[a-2]),o}function _e(e,t,n,s,i=null,c=0,o=0){const{float32Array:a,uint16Array:r,uint32Array:y}=L;let u=e*2;if(F(u,r)){const l=$(e,y),p=k(u,r);return z(e,a,it),s(l,p,!1,o,c+e/V,it)}else{let b=function(P){const{uint16Array:I,uint32Array:C}=L;let E=P*2;for(;!F(E,I);)P=N(P),E=P*2;return $(P,C)},v=function(P){const{uint16Array:I,uint32Array:C}=L;let E=P*2;for(;!F(E,I);)P=H(P,C),E=P*2;return $(P,C)+k(E,I)};const l=N(e),p=H(e,y);let g=l,A=p,w,B,d,h;if(i&&(d=it,h=Pt,z(g,a,d),z(A,a,h),w=i(d),B=i(h),B<w)){g=p,A=l;const P=w;w=B,B=P,d=h}d||(d=it,z(g,a,d));const m=F(g*2,r),x=n(d,m,w,o+1,c+g/V);let S;if(x===Ze){const P=b(g),C=v(g)-P;S=s(P,C,!0,o+1,c+g/V,d)}else S=x&&_e(g,t,n,s,i,c,o+1);if(S)return!0;h=Pt,z(A,a,h);const T=F(A*2,r),_=n(h,T,B,o+1,c+A/V);let M;if(_===Ze){const P=b(A),C=v(A)-P;M=s(P,C,!0,o+1,c+A/V,h)}else M=_&&_e(A,t,n,s,i,c,o+1);return!!M}}const Rt=new L.constructor,ne=new L.constructor,st=new Ne(()=>new W),dt=new W,mt=new W,me=new W,he=new W;let xe=!1;function rs(e,t,n,s){if(xe)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");xe=!0;const i=e._roots,c=t._roots;let o,a=0,r=0;const y=new rt().copy(n).invert();for(let u=0,f=i.length;u<f;u++){Rt.setBuffer(i[u]),r=0;const l=st.getPrimitive();z(0,Rt.float32Array,l),l.applyMatrix4(y);for(let p=0,g=c.length;p<g&&(ne.setBuffer(c[p]),o=j(0,0,n,y,s,a,r,0,0,l),ne.clearBuffer(),r+=c[p].byteLength/O,!o);p++);if(st.releasePrimitive(l),Rt.clearBuffer(),a+=i[u].byteLength/O,o)break}return xe=!1,o}function j(e,t,n,s,i,c=0,o=0,a=0,r=0,y=null,u=!1){let f,l;u?(f=ne,l=Rt):(f=Rt,l=ne);const p=f.float32Array,g=f.uint32Array,A=f.uint16Array,w=l.float32Array,B=l.uint32Array,d=l.uint16Array,h=e*2,m=t*2,x=F(h,A),S=F(m,d);let T=!1;if(S&&x)u?T=i($(t,B),k(t*2,d),$(e,g),k(e*2,A),r,o+t/V,a,c+e/V):T=i($(e,g),k(e*2,A),$(t,B),k(t*2,d),a,c+e/V,r,o+t/V);else if(S){const _=st.getPrimitive();z(t,w,_),_.applyMatrix4(n);const M=N(e),b=H(e,g);z(M,p,dt),z(b,p,mt);const v=_.intersectsBox(dt),P=_.intersectsBox(mt);T=v&&j(t,M,s,n,i,o,c,r,a+1,_,!u)||P&&j(t,b,s,n,i,o,c,r,a+1,_,!u),st.releasePrimitive(_)}else{const _=N(t),M=H(t,B);z(_,w,me),z(M,w,he);const b=y.intersectsBox(me),v=y.intersectsBox(he);if(b&&v)T=j(e,_,n,s,i,c,o,a,r+1,y,u)||j(e,M,n,s,i,c,o,a,r+1,y,u);else if(b)if(x)T=j(e,_,n,s,i,c,o,a,r+1,y,u);else{const P=st.getPrimitive();P.copy(me).applyMatrix4(n);const I=N(e),C=H(e,g);z(I,p,dt),z(C,p,mt);const E=P.intersectsBox(dt),D=P.intersectsBox(mt);T=E&&j(_,I,s,n,i,o,c,r,a+1,P,!u)||D&&j(_,C,s,n,i,o,c,r,a+1,P,!u),st.releasePrimitive(P)}else if(v)if(x)T=j(e,M,n,s,i,c,o,a,r+1,y,u);else{const P=st.getPrimitive();P.copy(he).applyMatrix4(n);const I=N(e),C=H(e,g);z(I,p,dt),z(C,p,mt);const E=P.intersectsBox(dt),D=P.intersectsBox(mt);T=E&&j(M,I,s,n,i,o,c,r,a+1,P,!u)||D&&j(M,C,s,n,i,o,c,r,a+1,P,!u),st.releasePrimitive(P)}}return T}const Qe=new W,ht=new Float32Array(6);class cs{constructor(){this._roots=null,this.primitiveBuffer=null,this.primitiveBufferStride=null}init(t){t={...vn,...t},ss(this,t)}getRootRanges(){throw new Error("BVH: getRootRanges() not implemented")}writePrimitiveBounds(){throw new Error("BVH: writePrimitiveBounds() not implemented")}writePrimitiveRangeBounds(t,n,s,i){let c=1/0,o=1/0,a=1/0,r=-1/0,y=-1/0,u=-1/0;for(let f=t,l=t+n;f<l;f++){this.writePrimitiveBounds(f,ht,0);const[p,g,A,w,B,d]=ht;p<c&&(c=p),w>r&&(r=w),g<o&&(o=g),B>y&&(y=B),A<a&&(a=A),d>u&&(u=d)}return s[i+0]=c,s[i+1]=o,s[i+2]=a,s[i+3]=r,s[i+4]=y,s[i+5]=u,s}computePrimitiveBounds(t,n,s){const i=s.offset||0;for(let c=t,o=t+n;c<o;c++){this.writePrimitiveBounds(c,ht,0);const[a,r,y,u,f,l]=ht,p=(a+u)/2,g=(r+f)/2,A=(y+l)/2,w=(u-a)/2,B=(f-r)/2,d=(l-y)/2,h=(c-i)*6;s[h+0]=p,s[h+1]=w+(Math.abs(p)+w)*Jt,s[h+2]=g,s[h+3]=B+(Math.abs(g)+B)*Jt,s[h+4]=A,s[h+5]=d+(Math.abs(A)+d)*Jt}return s}shiftPrimitiveOffsets(t){const n=this._indirectBuffer;if(n)for(let s=0,i=n.length;s<i;s++)n[s]+=t;else{const s=this._roots;for(let i=0;i<s.length;i++){const c=s[i],o=new Uint32Array(c),a=new Uint16Array(c),r=c.byteLength/O;for(let y=0;y<r;y++){const u=V*y,f=2*u;F(f,a)&&(o[u+6]+=t)}}}}traverse(t,n=0){const s=this._roots[n],i=new Uint32Array(s),c=new Uint16Array(s);o(0);function o(a,r=0){const y=a*2,u=F(y,c);if(u){const f=i[a+6],l=c[y+14];t(r,u,new Float32Array(s,a*4,6),f,l)}else{const f=N(a),l=H(a,i),p=Fe(a,i);t(r,u,new Float32Array(s,a*4,6),p)||(o(f,r+1),o(l,r+1))}}}refit(){const t=this._roots;for(let n=0,s=t.length;n<s;n++){const i=t[n],c=new Uint32Array(i),o=new Uint16Array(i),a=new Float32Array(i),r=i.byteLength/O;for(let y=r-1;y>=0;y--){const u=y*V,f=u*2;if(F(f,o)){const p=$(u,c),g=k(f,o);this.writePrimitiveRangeBounds(p,g,ht,0),a.set(ht,u)}else{const p=N(u),g=H(u,c);for(let A=0;A<3;A++){const w=a[p+A],B=a[p+A+3],d=a[g+A],h=a[g+A+3];a[u+A]=w<d?w:d,a[u+A+3]=B>h?B:h}}}}}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{z(0,new Float32Array(s),Qe),t.union(Qe)}),t}shapecast(t){let{boundsTraverseOrder:n,intersectsBounds:s,intersectsRange:i,intersectsPrimitive:c,scratchPrimitive:o,iterate:a}=t;if(i&&c){const f=i;i=(l,p,g,A,w)=>f(l,p,g,A,w)?!0:a(l,p,this,c,g,A,o)}else i||(c?i=(f,l,p,g)=>a(f,l,this,c,p,g,o):i=(f,l,p)=>p);let r=!1,y=0;const u=this._roots;for(let f=0,l=u.length;f<l;f++){const p=u[f];if(r=os(this,f,s,i,n,y),r)break;y+=p.byteLength/O}return r}bvhcast(t,n,s){let{intersectsRanges:i}=s;return rs(this,t,n,i)}}function as(){return typeof SharedArrayBuffer<"u"}function He(e){return e.index?e.index.count:e.attributes.position.count}function re(e){return He(e)/3}function ls(e,t=ArrayBuffer){return e>65535?new Uint32Array(new t(4*e)):new Uint16Array(new t(2*e))}function fs(e,t){if(!e.index){const n=e.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=ls(n,s);e.setIndex(new mn(i,1));for(let c=0;c<n;c++)i[c]=c}}function us(e,t,n){const s=He(e)/n,i=t||e.drawRange,c=i.start/n,o=(i.start+i.count)/n,a=Math.max(0,c),r=Math.min(s,o)-a;return{offset:Math.floor(a),count:Math.floor(r)}}function ps(e,t){return e.groups.map(n=>({offset:n.start/t,count:n.count/t}))}function Je(e,t,n){const s=us(e,t,n),i=ps(e,n);if(!i.length)return[s];const c=[],o=s.offset,a=s.offset+s.count,r=He(e)/n,y=[];for(const l of i){const{offset:p,count:g}=l,A=p,w=isFinite(g)?g:r-p,B=p+w;A<a&&B>o&&(y.push({pos:Math.max(o,A),isStart:!0}),y.push({pos:Math.min(a,B),isStart:!1}))}y.sort((l,p)=>l.pos!==p.pos?l.pos-p.pos:l.type==="end"?-1:1);let u=0,f=null;for(const l of y){const p=l.pos;u!==0&&p!==f&&c.push({offset:f,count:p-f}),u+=l.isStart?1:-1,f=p}return c}function ys(e,t){const n=e[e.length-1],s=n.offset+n.count>2**16,i=e.reduce((y,u)=>y+u.count,0),c=s?4:2,o=t?new SharedArrayBuffer(i*c):new ArrayBuffer(i*c),a=s?new Uint32Array(o):new Uint16Array(o);let r=0;for(let y=0;y<e.length;y++){const{offset:u,count:f}=e[y];for(let l=0;l<f;l++)a[r+l]=u+l;r+=f}return a}class ds extends cs{get indirect(){return!!this._indirectBuffer}get primitiveStride(){return null}get primitiveBufferStride(){return this.indirect?1:this.primitiveStride}set primitiveBufferStride(t){}get primitiveBuffer(){return this.indirect?this._indirectBuffer:this.geometry.index.array}set primitiveBuffer(t){}constructor(t,n={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("BVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("BVH: Only BufferGeometries are supported.");if(n.useSharedArrayBuffer&&!as())throw new Error("BVH: SharedArrayBuffer is not available.");super(),this.geometry=t,this.resolvePrimitiveIndex=n.indirect?s=>this._indirectBuffer[s]:s=>s,this.primitiveBuffer=null,this.primitiveBufferStride=null,this._indirectBuffer=null,n={...vn,...n},n[Ve]||this.init(n)}init(t){const{geometry:n,primitiveStride:s}=this;if(t.indirect){const i=Je(n,t.range,s),c=ys(i,t.useSharedArrayBuffer);this._indirectBuffer=c}else fs(n,t);super.init(t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new W))}getRootRanges(t){return this.indirect?[{offset:0,count:this._indirectBuffer.length}]:Je(this.geometry,t,this.primitiveStride)}raycastObject3D(){throw new Error("BVH: raycastObject3D() not implemented")}}class tt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,n){let s=1/0,i=-1/0;for(let c=0,o=t.length;c<o;c++){const r=t[c][n];s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}setFromPoints(t,n){let s=1/0,i=-1/0;for(let c=0,o=n.length;c<o;c++){const a=n[c],r=t.dot(a);s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}tt.prototype.setFromBox=(function(){const e=new R;return function(n,s){const i=s.min,c=s.max;let o=1/0,a=-1/0;for(let r=0;r<=1;r++)for(let y=0;y<=1;y++)for(let u=0;u<=1;u++){e.x=i.x*r+c.x*(1-r),e.y=i.y*y+c.y*(1-y),e.z=i.z*u+c.z*(1-u);const f=n.dot(e);o=Math.min(f,o),a=Math.max(f,a)}this.min=o,this.max=a}})();const ms=(function(){const e=new R,t=new R,n=new R;return function(i,c,o){const a=i.start,r=e,y=c.start,u=t;n.subVectors(a,y),e.subVectors(i.end,i.start),t.subVectors(c.end,c.start);const f=n.dot(u),l=u.dot(r),p=u.dot(u),g=n.dot(r),w=r.dot(r)*p-l*l;let B,d;w!==0?B=(f*l-g*p)/w:B=0,d=(f+B*l)/p,o.x=B,o.y=d}})(),qe=(function(){const e=new ct,t=new R,n=new R;return function(i,c,o,a){ms(i,c,e);let r=e.x,y=e.y;if(r>=0&&r<=1&&y>=0&&y<=1){i.at(r,o),c.at(y,a);return}else if(r>=0&&r<=1){y<0?c.at(0,a):c.at(1,a),i.closestPointToPoint(a,!0,o);return}else if(y>=0&&y<=1){r<0?i.at(0,o):i.at(1,o),c.closestPointToPoint(o,!0,a);return}else{let u;r<0?u=i.start:u=i.end;let f;y<0?f=c.start:f=c.end;const l=t,p=n;if(i.closestPointToPoint(f,!0,t),c.closestPointToPoint(u,!0,n),l.distanceToSquared(f)<=p.distanceToSquared(u)){o.copy(l),a.copy(f);return}else{o.copy(u),a.copy(p);return}}}})(),hs=(function(){const e=new R,t=new R,n=new hn,s=new G;return function(c,o){const{radius:a,center:r}=c,{a:y,b:u,c:f}=o;if(s.start=y,s.end=u,s.closestPointToPoint(r,!0,e).distanceTo(r)<=a||(s.start=y,s.end=f,s.closestPointToPoint(r,!0,e).distanceTo(r)<=a)||(s.start=u,s.end=f,s.closestPointToPoint(r,!0,e).distanceTo(r)<=a))return!0;const A=o.getPlane(n);if(Math.abs(A.distanceToPoint(r))<=a){const B=A.projectPoint(r,t);if(o.containsPoint(B))return!0}return!1}})(),xs=["x","y","z"],J=1e-15,Ge=J*J;function Z(e){return Math.abs(e)<J}class K extends Bt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new R),this.satBounds=new Array(4).fill().map(()=>new tt),this.points=[this.a,this.b,this.c],this.plane=new hn,this.isDegenerateIntoSegment=!1,this.isDegenerateIntoPoint=!1,this.degenerateSegment=new G,this.needsUpdate=!0}intersectsSphere(t){return hs(t,this)}update(){const t=this.a,n=this.b,s=this.c,i=this.points,c=this.satAxes,o=this.satBounds,a=c[0],r=o[0];this.getNormal(a),r.setFromPoints(a,i);const y=c[1],u=o[1];y.subVectors(t,n),u.setFromPoints(y,i);const f=c[2],l=o[2];f.subVectors(n,s),l.setFromPoints(f,i);const p=c[3],g=o[3];p.subVectors(s,t),g.setFromPoints(p,i);const A=y.length(),w=f.length(),B=p.length();this.isDegenerateIntoPoint=!1,this.isDegenerateIntoSegment=!1,A<J?w<J||B<J?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(t),this.degenerateSegment.end.copy(s)):w<J?B<J?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(n),this.degenerateSegment.end.copy(t)):B<J&&(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(s),this.degenerateSegment.end.copy(n)),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}K.prototype.closestPointToSegment=(function(){const e=new R,t=new R,n=new G;return function(i,c=null,o=null){const{start:a,end:r}=i,y=this.points;let u,f=1/0;for(let l=0;l<3;l++){const p=(l+1)%3;n.start.copy(y[l]),n.end.copy(y[p]),qe(n,i,e,t),u=e.distanceToSquared(t),u<f&&(f=u,c&&c.copy(e),o&&o.copy(t))}return this.closestPointToPoint(a,e),u=a.distanceToSquared(e),u<f&&(f=u,c&&c.copy(e),o&&o.copy(a)),this.closestPointToPoint(r,e),u=r.distanceToSquared(e),u<f&&(f=u,c&&c.copy(e),o&&o.copy(r)),Math.sqrt(f)}})();K.prototype.intersectsTriangle=(function(){const e=new K,t=new tt,n=new tt,s=new R,i=new R,c=new R,o=new R,a=new G,r=new G,y=new R,u=new ct,f=new ct;function l(h,m,x,S){const T=s;!h.isDegenerateIntoPoint&&!h.isDegenerateIntoSegment?T.copy(h.plane.normal):T.copy(m.plane.normal);const _=h.satBounds,M=h.satAxes;for(let P=1;P<4;P++){const I=_[P],C=M[P];if(t.setFromPoints(C,m.points),I.isSeparated(t)||(o.copy(T).cross(C),t.setFromPoints(o,h.points),n.setFromPoints(o,m.points),t.isSeparated(n)))return!1}const b=m.satBounds,v=m.satAxes;for(let P=1;P<4;P++){const I=b[P],C=v[P];if(t.setFromPoints(C,h.points),I.isSeparated(t)||(o.crossVectors(T,C),t.setFromPoints(o,h.points),n.setFromPoints(o,m.points),t.isSeparated(n)))return!1}return x&&(x.start.set(0,0,0),x.end.set(0,0,0)),!0}function p(h,m,x,S,T,_,M,b,v,P,I){let C=M/(M-b);P.x=S+(T-S)*C,I.start.subVectors(m,h).multiplyScalar(C).add(h),C=M/(M-v),P.y=S+(_-S)*C,I.end.subVectors(x,h).multiplyScalar(C).add(h)}function g(h,m,x,S,T,_,M,b,v,P,I){if(T>0)p(h.c,h.a,h.b,S,m,x,v,M,b,P,I);else if(_>0)p(h.b,h.a,h.c,x,m,S,b,M,v,P,I);else if(b*v>0||M!=0)p(h.a,h.b,h.c,m,x,S,M,b,v,P,I);else if(b!=0)p(h.b,h.a,h.c,x,m,S,b,M,v,P,I);else if(v!=0)p(h.c,h.a,h.b,S,m,x,v,M,b,P,I);else return!0;return!1}function A(h,m,x,S){const T=m.degenerateSegment,_=h.plane.distanceToPoint(T.start),M=h.plane.distanceToPoint(T.end);return Z(_)?Z(M)?l(h,m,x,S):(x&&(x.start.copy(T.start),x.end.copy(T.start)),h.containsPoint(T.start)):Z(M)?(x&&(x.start.copy(T.end),x.end.copy(T.end)),h.containsPoint(T.end)):h.plane.intersectLine(T,s)!=null?(x&&(x.start.copy(s),x.end.copy(s)),h.containsPoint(s)):!1}function w(h,m,x){const S=m.a;return Z(h.plane.distanceToPoint(S))&&h.containsPoint(S)?(x&&(x.start.copy(S),x.end.copy(S)),!0):!1}function B(h,m,x){const S=h.degenerateSegment,T=m.a;return S.closestPointToPoint(T,!0,s),T.distanceToSquared(s)<Ge?(x&&(x.start.copy(T),x.end.copy(T)),!0):!1}function d(h,m,x,S){if(h.isDegenerateIntoSegment)if(m.isDegenerateIntoSegment){const T=h.degenerateSegment,_=m.degenerateSegment,M=i,b=c;T.delta(M),_.delta(b);const v=s.subVectors(_.start,T.start),P=M.x*b.y-M.y*b.x;if(Z(P))return!1;const I=(v.x*b.y-v.y*b.x)/P,C=-(M.x*v.y-M.y*v.x)/P;if(I<0||I>1||C<0||C>1)return!1;const E=T.start.z+M.z*I,D=_.start.z+b.z*C;return Z(E-D)?(x&&(x.start.copy(T.start).addScaledVector(M,I),x.end.copy(T.start).addScaledVector(M,I)),!0):!1}else return m.isDegenerateIntoPoint?B(h,m,x):A(m,h,x,S);else{if(h.isDegenerateIntoPoint)return m.isDegenerateIntoPoint?m.a.distanceToSquared(h.a)<Ge?(x&&(x.start.copy(h.a),x.end.copy(h.a)),!0):!1:m.isDegenerateIntoSegment?B(m,h,x):w(m,h,x);if(m.isDegenerateIntoPoint)return w(h,m,x);if(m.isDegenerateIntoSegment)return A(h,m,x,S)}}return function(m,x=null,S=!1){this.needsUpdate&&this.update(),m.isExtendedTriangle?m.needsUpdate&&m.update():(e.copy(m),e.update(),m=e);const T=d(this,m,x,S);if(T!==void 0)return T;const _=this.plane,M=m.plane;let b=M.distanceToPoint(this.a),v=M.distanceToPoint(this.b),P=M.distanceToPoint(this.c);Z(b)&&(b=0),Z(v)&&(v=0),Z(P)&&(P=0);const I=b*v,C=b*P;if(I>0&&C>0)return!1;let E=_.distanceToPoint(m.a),D=_.distanceToPoint(m.b),zt=_.distanceToPoint(m.c);Z(E)&&(E=0),Z(D)&&(D=0),Z(zt)&&(zt=0);const Oe=E*D,$e=E*zt;if(Oe>0&&$e>0)return!1;i.copy(_.normal),c.copy(M.normal);const ae=i.cross(c);let le=0,fe=Math.abs(ae.x);const ke=Math.abs(ae.y);ke>fe&&(fe=ke,le=1),Math.abs(ae.z)>fe&&(le=2);const pt=xs[le],Un=this.a[pt],Vn=this.b[pt],Fn=this.c[pt],Nn=m.a[pt],Hn=m.b[pt],qn=m.c[pt];if(g(this,Un,Vn,Fn,I,C,b,v,P,u,a))return l(this,m,x,S);if(g(m,Nn,Hn,qn,Oe,$e,E,D,zt,f,r))return l(this,m,x,S);if(u.y<u.x){const ue=u.y;u.y=u.x,u.x=ue,y.copy(a.start),a.start.copy(a.end),a.end.copy(y)}if(f.y<f.x){const ue=f.y;f.y=f.x,f.x=ue,y.copy(r.start),r.start.copy(r.end),r.end.copy(y)}return u.y<f.x||f.y<u.x?!1:(x&&(f.x>u.x?x.start.copy(r.start):x.start.copy(a.start),f.y<u.y?x.end.copy(r.end):x.end.copy(a.end)),!0)}})();K.prototype.distanceToPoint=(function(){const e=new R;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}})();K.prototype.distanceToTriangle=(function(){const e=new R,t=new R,n=["a","b","c"],s=new G,i=new G;return function(o,a=null,r=null){const y=a||r?s:null;if(this.intersectsTriangle(o,y))return(a||r)&&(a&&y.getCenter(a),r&&y.getCenter(r)),0;let u=1/0;for(let f=0;f<3;f++){let l;const p=n[f],g=o[p];this.closestPointToPoint(g,e),l=g.distanceToSquared(e),l<u&&(u=l,a&&a.copy(e),r&&r.copy(g));const A=this[p];o.closestPointToPoint(A,e),l=A.distanceToSquared(e),l<u&&(u=l,a&&a.copy(A),r&&r.copy(e))}for(let f=0;f<3;f++){const l=n[f],p=n[(f+1)%3];s.set(this[l],this[p]);for(let g=0;g<3;g++){const A=n[g],w=n[(g+1)%3];i.set(o[A],o[w]),qe(s,i,e,t);const B=e.distanceToSquared(t);B<u&&(u=B,a&&a.copy(e),r&&r.copy(t))}}return Math.sqrt(u)}})();class X{constructor(t,n,s){this.isOrientedBox=!0,this.min=new R,this.max=new R,this.matrix=new rt,this.invMatrix=new rt,this.points=new Array(8).fill().map(()=>new R),this.satAxes=new Array(3).fill().map(()=>new R),this.satBounds=new Array(3).fill().map(()=>new tt),this.alignedSatBounds=new Array(3).fill().map(()=>new tt),this.needsUpdate=!1,t&&this.min.copy(t),n&&this.max.copy(n),s&&this.matrix.copy(s)}set(t,n,s){this.min.copy(t),this.max.copy(n),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}X.prototype.update=(function(){return function(){const t=this.matrix,n=this.min,s=this.max,i=this.points;for(let y=0;y<=1;y++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){const l=1*y|2*u|4*f,p=i[l];p.x=y?s.x:n.x,p.y=u?s.y:n.y,p.z=f?s.z:n.z,p.applyMatrix4(t)}const c=this.satBounds,o=this.satAxes,a=i[0];for(let y=0;y<3;y++){const u=o[y],f=c[y],l=1<<y,p=i[l];u.subVectors(a,p),f.setFromPoints(u,i)}const r=this.alignedSatBounds;r[0].setFromPointsField(i,"x"),r[1].setFromPointsField(i,"y"),r[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();X.prototype.intersectsBox=(function(){const e=new tt;return function(n){this.needsUpdate&&this.update();const s=n.min,i=n.max,c=this.satBounds,o=this.satAxes,a=this.alignedSatBounds;if(e.min=s.x,e.max=i.x,a[0].isSeparated(e)||(e.min=s.y,e.max=i.y,a[1].isSeparated(e))||(e.min=s.z,e.max=i.z,a[2].isSeparated(e)))return!1;for(let r=0;r<3;r++){const y=o[r],u=c[r];if(e.setFromBox(y,n),u.isSeparated(e))return!1}return!0}})();X.prototype.intersectsTriangle=(function(){const e=new K,t=new Array(3),n=new tt,s=new tt,i=new R;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(e.copy(o),e.update(),o=e);const a=this.satBounds,r=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let l=0;l<3;l++){const p=a[l],g=r[l];if(n.setFromPoints(g,t),p.isSeparated(n))return!1}const y=o.satBounds,u=o.satAxes,f=this.points;for(let l=0;l<3;l++){const p=y[l],g=u[l];if(n.setFromPoints(g,f),p.isSeparated(n))return!1}for(let l=0;l<3;l++){const p=r[l];for(let g=0;g<4;g++){const A=u[g];if(i.crossVectors(p,A),n.setFromPoints(i,t),s.setFromPoints(i,f),n.isSeparated(s))return!1}}return!0}})();X.prototype.closestPointToPoint=(function(){return function(t,n){return this.needsUpdate&&this.update(),n.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),n}})();X.prototype.distanceToPoint=(function(){const e=new R;return function(n){return this.closestPointToPoint(n,e),n.distanceTo(e)}})();X.prototype.distanceToBox=(function(){const e=["x","y","z"],t=new Array(12).fill().map(()=>new G),n=new Array(12).fill().map(()=>new G),s=new R,i=new R;return function(o,a=0,r=null,y=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(r||y)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),r&&r.copy(s),y&&y.copy(i)),0;const u=a*a,f=o.min,l=o.max,p=this.points;let g=1/0;for(let w=0;w<8;w++){const B=p[w];i.copy(B).clamp(f,l);const d=B.distanceToSquared(i);if(d<g&&(g=d,r&&r.copy(B),y&&y.copy(i),d<u))return Math.sqrt(d)}let A=0;for(let w=0;w<3;w++)for(let B=0;B<=1;B++)for(let d=0;d<=1;d++){const h=(w+1)%3,m=(w+2)%3,x=B<<h|d<<m,S=1<<w|B<<h|d<<m,T=p[x],_=p[S];t[A].set(T,_);const b=e[w],v=e[h],P=e[m],I=n[A],C=I.start,E=I.end;C[b]=f[b],C[v]=B?f[v]:l[v],C[P]=d?f[P]:l[v],E[b]=l[b],E[v]=B?f[v]:l[v],E[P]=d?f[P]:l[v],A++}for(let w=0;w<=1;w++)for(let B=0;B<=1;B++)for(let d=0;d<=1;d++){i.x=w?l.x:f.x,i.y=B?l.y:f.y,i.z=d?l.z:f.z,this.closestPointToPoint(i,s);const h=i.distanceToSquared(s);if(h<g&&(g=h,r&&r.copy(s),y&&y.copy(i),h<u))return Math.sqrt(h)}for(let w=0;w<12;w++){const B=t[w];for(let d=0;d<12;d++){const h=n[d];qe(B,h,s,i);const m=s.distanceToSquared(i);if(m<g&&(g=m,r&&r.copy(s),y&&y.copy(i),m<u))return Math.sqrt(m)}}return Math.sqrt(g)}})();class gs extends Ne{constructor(){super(()=>new K)}}const Y=new gs,St=new R,ge=new R;function ws(e,t,n={},s=0,i=1/0){const c=s*s,o=i*i;let a=1/0,r=null;if(e.shapecast({boundsTraverseOrder:u=>(St.copy(t).clamp(u.min,u.max),St.distanceToSquared(t)),intersectsBounds:(u,f,l)=>l<a&&l<o,intersectsTriangle:(u,f)=>{u.closestPointToPoint(t,St);const l=t.distanceToSquared(St);return l<a&&(ge.copy(St),a=l,r=f),l<c}}),a===1/0)return null;const y=Math.sqrt(a);return n.point?n.point.copy(ge):n.point=ge.clone(),n.distance=y,n.faceIndex=r,n}const Nt=parseInt(xn)>=169,As=parseInt(xn)<=161,lt=new R,ft=new R,ut=new R,Ht=new ct,qt=new ct,Ot=new ct,tn=new R,en=new R,nn=new R,_t=new R;function Bs(e,t,n,s,i,c,o,a){let r;if(c===On?r=e.intersectTriangle(s,n,t,!0,i):r=e.intersectTriangle(t,n,s,c!==$n,i),r===null)return null;const y=e.origin.distanceTo(i);return y<o||y>a?null:{distance:y,point:i.clone()}}function sn(e,t,n,s,i,c,o,a,r,y,u){lt.fromBufferAttribute(t,c),ft.fromBufferAttribute(t,o),ut.fromBufferAttribute(t,a);const f=Bs(e,lt,ft,ut,_t,r,y,u);if(f){if(s){Ht.fromBufferAttribute(s,c),qt.fromBufferAttribute(s,o),Ot.fromBufferAttribute(s,a),f.uv=new ct;const p=Bt.getInterpolation(_t,lt,ft,ut,Ht,qt,Ot,f.uv);Nt||(f.uv=p)}if(i){Ht.fromBufferAttribute(i,c),qt.fromBufferAttribute(i,o),Ot.fromBufferAttribute(i,a),f.uv1=new ct;const p=Bt.getInterpolation(_t,lt,ft,ut,Ht,qt,Ot,f.uv1);Nt||(f.uv1=p),As&&(f.uv2=f.uv1)}if(n){tn.fromBufferAttribute(n,c),en.fromBufferAttribute(n,o),nn.fromBufferAttribute(n,a),f.normal=new R;const p=Bt.getInterpolation(_t,lt,ft,ut,tn,en,nn,f.normal);f.normal.dot(e.direction)>0&&f.normal.multiplyScalar(-1),Nt||(f.normal=p)}const l={a:c,b:o,c:a,normal:new R,materialIndex:0};if(Bt.getNormal(lt,ft,ut,l.normal),f.face=l,f.faceIndex=c,Nt){const p=new R;Bt.getBarycoord(_t,lt,ft,ut,p),f.barycoord=p}}return f}function on(e){return e&&e.isMaterial?e.side:e}function ce(e,t,n,s,i,c,o){const a=s*3;let r=a+0,y=a+1,u=a+2;const{index:f,groups:l}=e;e.index&&(r=f.getX(r),y=f.getX(y),u=f.getX(u));const{position:p,normal:g,uv:A,uv1:w}=e.attributes;if(Array.isArray(t)){const B=s*3;for(let d=0,h=l.length;d<h;d++){const{start:m,count:x,materialIndex:S}=l[d];if(B>=m&&B<m+x){const T=on(t[S]),_=sn(n,p,g,A,w,r,y,u,T,c,o);if(_)if(_.faceIndex=s,_.face.materialIndex=S,i)i.push(_);else return _}}}else{const B=on(t),d=sn(n,p,g,A,w,r,y,u,B,c,o);if(d)if(d.faceIndex=s,d.face.materialIndex=0,i)i.push(d);else return d}return null}function U(e,t,n,s){const i=e.a,c=e.b,o=e.c;let a=t,r=t+1,y=t+2;n&&(a=n.getX(a),r=n.getX(r),y=n.getX(y)),i.x=s.getX(a),i.y=s.getY(a),i.z=s.getZ(a),c.x=s.getX(r),c.y=s.getY(r),c.z=s.getZ(r),o.x=s.getX(y),o.y=s.getY(y),o.z=s.getZ(y)}function Ts(e,t,n,s,i,c,o,a){const{geometry:r,_indirectBuffer:y}=e;for(let u=s,f=s+i;u<f;u++)ce(r,t,n,u,c,o,a)}function Ps(e,t,n,s,i,c,o){const{geometry:a,_indirectBuffer:r}=e;let y=1/0,u=null;for(let f=s,l=s+i;f<l;f++){let p;p=ce(a,t,n,f,null,c,o),p&&p.distance<y&&(u=p,y=p.distance)}return u}function bs(e,t,n,s,i,c,o){const{geometry:a}=n,{index:r}=a,y=a.attributes.position;for(let u=e,f=t+e;u<f;u++){let l;if(l=u,U(o,l*3,r,y),o.needsUpdate=!0,s(o,l,i,c))return!0}return!1}function Ss(e,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,s=n.index?n.index.array:null,i=n.attributes.position;let c,o,a,r,y=0;const u=e._roots;for(let l=0,p=u.length;l<p;l++)c=u[l],o=new Uint32Array(c),a=new Uint16Array(c),r=new Float32Array(c),f(0,y),y+=c.byteLength;function f(l,p,g=!1){const A=l*2;if(F(A,a)){const w=$(l,o),B=k(A,a);let d=1/0,h=1/0,m=1/0,x=-1/0,S=-1/0,T=-1/0;for(let _=3*w,M=3*(w+B);_<M;_++){let b=s[_];const v=i.getX(b),P=i.getY(b),I=i.getZ(b);v<d&&(d=v),v>x&&(x=v),P<h&&(h=P),P>S&&(S=P),I<m&&(m=I),I>T&&(T=I)}return r[l+0]!==d||r[l+1]!==h||r[l+2]!==m||r[l+3]!==x||r[l+4]!==S||r[l+5]!==T?(r[l+0]=d,r[l+1]=h,r[l+2]=m,r[l+3]=x,r[l+4]=S,r[l+5]=T,!0):!1}else{const w=N(l),B=H(l,o);let d=g,h=!1,m=!1;if(t){if(!d){const b=w/V+p/O,v=B/V+p/O;h=t.has(b),m=t.has(v),d=!h&&!m}}else h=!0,m=!0;const x=d||h,S=d||m;let T=!1;x&&(T=f(w,p,d));let _=!1;S&&(_=f(B,p,d));const M=T||_;if(M)for(let b=0;b<3;b++){const v=w+b,P=B+b,I=r[v],C=r[v+3],E=r[P],D=r[P+3];r[l+b]=I<E?I:E,r[l+b+3]=C>D?C:D}return M}}}function at(e,t,n,s,i){let c,o,a,r,y,u;const f=1/n.direction.x,l=1/n.direction.y,p=1/n.direction.z,g=n.origin.x,A=n.origin.y,w=n.origin.z;let B=t[e],d=t[e+3],h=t[e+1],m=t[e+3+1],x=t[e+2],S=t[e+3+2];return f>=0?(c=(B-g)*f,o=(d-g)*f):(c=(d-g)*f,o=(B-g)*f),l>=0?(a=(h-A)*l,r=(m-A)*l):(a=(m-A)*l,r=(h-A)*l),c>r||a>o||((a>c||isNaN(c))&&(c=a),(r<o||isNaN(o))&&(o=r),p>=0?(y=(x-w)*p,u=(S-w)*p):(y=(S-w)*p,u=(x-w)*p),c>u||y>o)?!1:((y>c||c!==c)&&(c=y),(u<o||o!==o)&&(o=u),c<=i&&o>=s)}function _s(e,t,n,s,i,c,o,a){const{geometry:r,_indirectBuffer:y}=e;for(let u=s,f=s+i;u<f;u++){let l=y?y[u]:u;ce(r,t,n,l,c,o,a)}}function Ms(e,t,n,s,i,c,o){const{geometry:a,_indirectBuffer:r}=e;let y=1/0,u=null;for(let f=s,l=s+i;f<l;f++){let p;p=ce(a,t,n,r?r[f]:f,null,c,o),p&&p.distance<y&&(u=p,y=p.distance)}return u}function vs(e,t,n,s,i,c,o){const{geometry:a}=n,{index:r}=a,y=a.attributes.position;for(let u=e,f=t+e;u<f;u++){let l;if(l=n.resolveTriangleIndex(u),U(o,l*3,r,y),o.needsUpdate=!0,s(o,l,i,c))return!0}return!1}function Is(e,t,n,s,i,c,o){L.setBuffer(e._roots[t]),Me(0,e,n,s,i,c,o),L.clearBuffer()}function Me(e,t,n,s,i,c,o){const{float32Array:a,uint16Array:r,uint32Array:y}=L,u=e*2;if(F(u,r)){const l=$(e,y),p=k(u,r);Ts(t,n,s,l,p,i,c,o)}else{const l=N(e);at(l,a,s,c,o)&&Me(l,t,n,s,i,c,o);const p=H(e,y);at(p,a,s,c,o)&&Me(p,t,n,s,i,c,o)}}const Cs=["x","y","z"];function Rs(e,t,n,s,i,c){L.setBuffer(e._roots[t]);const o=ve(0,e,n,s,i,c);return L.clearBuffer(),o}function ve(e,t,n,s,i,c){const{float32Array:o,uint16Array:a,uint32Array:r}=L;let y=e*2;if(F(y,a)){const f=$(e,r),l=k(y,a);return Ps(t,n,s,f,l,i,c)}else{const f=Fe(e,r),l=Cs[f],g=s.direction[l]>=0;let A,w;g?(A=N(e),w=H(e,r)):(A=H(e,r),w=N(e));const d=at(A,o,s,i,c)?ve(A,t,n,s,i,c):null;if(d){const x=d.point[l];if(g?x<=o[w+f]:x>=o[w+f+3])return d}const m=at(w,o,s,i,c)?ve(w,t,n,s,i,c):null;return d&&m?d.distance<=m.distance?d:m:d||m||null}}const $t=new W,xt=new K,gt=new K,Mt=new rt,rn=new X,kt=new X;function Es(e,t,n,s){L.setBuffer(e._roots[t]);const i=Ie(0,e,n,s);return L.clearBuffer(),i}function Ie(e,t,n,s,i=null){const{float32Array:c,uint16Array:o,uint32Array:a}=L;let r=e*2;if(i===null&&(n.boundingBox||n.computeBoundingBox(),rn.set(n.boundingBox.min,n.boundingBox.max,s),i=rn),F(r,o)){const u=t.geometry,f=u.index,l=u.attributes.position,p=n.index,g=n.attributes.position,A=$(e,a),w=k(r,o);if(Mt.copy(s).invert(),n.boundsTree)return z(e,c,kt),kt.matrix.copy(Mt),kt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:d=>kt.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let h=A*3,m=(w+A)*3;h<m;h+=3)if(U(gt,h,f,l),gt.needsUpdate=!0,d.intersectsTriangle(gt))return!0;return!1}});{const B=re(n);for(let d=A*3,h=(w+A)*3;d<h;d+=3){U(xt,d,f,l),xt.a.applyMatrix4(Mt),xt.b.applyMatrix4(Mt),xt.c.applyMatrix4(Mt),xt.needsUpdate=!0;for(let m=0,x=B*3;m<x;m+=3)if(U(gt,m,p,g),gt.needsUpdate=!0,xt.intersectsTriangle(gt))return!0}}}else{const u=N(e),f=H(e,a);return z(u,c,$t),!!(i.intersectsBox($t)&&Ie(u,t,n,s,i)||(z(f,c,$t),i.intersectsBox($t)&&Ie(f,t,n,s,i)))}}const Xt=new rt,we=new X,vt=new X,Ls=new R,zs=new R,Ds=new R,Us=new R;function Vs(e,t,n,s={},i={},c=0,o=1/0){t.boundingBox||t.computeBoundingBox(),we.set(t.boundingBox.min,t.boundingBox.max,n),we.needsUpdate=!0;const a=e.geometry,r=a.attributes.position,y=a.index,u=t.attributes.position,f=t.index,l=Y.getPrimitive(),p=Y.getPrimitive();let g=Ls,A=zs,w=null,B=null;i&&(w=Ds,B=Us);let d=1/0,h=null,m=null;return Xt.copy(n).invert(),vt.matrix.copy(Xt),e.shapecast({boundsTraverseOrder:x=>we.distanceToBox(x),intersectsBounds:(x,S,T)=>T<d&&T<o?(S&&(vt.min.copy(x.min),vt.max.copy(x.max),vt.needsUpdate=!0),!0):!1,intersectsRange:(x,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:_=>vt.distanceToBox(_),intersectsBounds:(_,M,b)=>b<d&&b<o,intersectsRange:(_,M)=>{for(let b=_,v=_+M;b<v;b++){U(p,3*b,f,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let P=x,I=x+S;P<I;P++){U(l,3*P,y,r),l.needsUpdate=!0;const C=l.distanceToTriangle(p,g,w);if(C<d&&(A.copy(g),B&&B.copy(w),d=C,h=P,m=b),C<c)return!0}}}});{const T=re(t);for(let _=0,M=T;_<M;_++){U(p,3*_,f,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let b=x,v=x+S;b<v;b++){U(l,3*b,y,r),l.needsUpdate=!0;const P=l.distanceToTriangle(p,g,w);if(P<d&&(A.copy(g),B&&B.copy(w),d=P,h=b,m=_),P<c)return!0}}}}}),Y.releasePrimitive(l),Y.releasePrimitive(p),d===1/0?null:(s.point?s.point.copy(A):s.point=A.clone(),s.distance=d,s.faceIndex=h,i&&(i.point?i.point.copy(B):i.point=B.clone(),i.point.applyMatrix4(Xt),A.applyMatrix4(Xt),i.distance=A.sub(i.point).length(),i.faceIndex=m),s)}function Fs(e,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,s=n.index?n.index.array:null,i=n.attributes.position;let c,o,a,r,y=0;const u=e._roots;for(let l=0,p=u.length;l<p;l++)c=u[l],o=new Uint32Array(c),a=new Uint16Array(c),r=new Float32Array(c),f(0,y),y+=c.byteLength;function f(l,p,g=!1){const A=l*2;if(F(A,a)){const w=$(l,o),B=k(A,a);let d=1/0,h=1/0,m=1/0,x=-1/0,S=-1/0,T=-1/0;for(let _=w,M=w+B;_<M;_++){const b=3*e.resolveTriangleIndex(_);for(let v=0;v<3;v++){let P=b+v;P=s?s[P]:P;const I=i.getX(P),C=i.getY(P),E=i.getZ(P);I<d&&(d=I),I>x&&(x=I),C<h&&(h=C),C>S&&(S=C),E<m&&(m=E),E>T&&(T=E)}}return r[l+0]!==d||r[l+1]!==h||r[l+2]!==m||r[l+3]!==x||r[l+4]!==S||r[l+5]!==T?(r[l+0]=d,r[l+1]=h,r[l+2]=m,r[l+3]=x,r[l+4]=S,r[l+5]=T,!0):!1}else{const w=N(l),B=H(l,o);let d=g,h=!1,m=!1;if(t){if(!d){const b=w/V+p/O,v=B/V+p/O;h=t.has(b),m=t.has(v),d=!h&&!m}}else h=!0,m=!0;const x=d||h,S=d||m;let T=!1;x&&(T=f(w,p,d));let _=!1;S&&(_=f(B,p,d));const M=T||_;if(M)for(let b=0;b<3;b++){const v=w+b,P=B+b,I=r[v],C=r[v+3],E=r[P],D=r[P+3];r[l+b]=I<E?I:E,r[l+b+3]=C>D?C:D}return M}}}function Ns(e,t,n,s,i,c,o){L.setBuffer(e._roots[t]),Ce(0,e,n,s,i,c,o),L.clearBuffer()}function Ce(e,t,n,s,i,c,o){const{float32Array:a,uint16Array:r,uint32Array:y}=L,u=e*2;if(F(u,r)){const l=$(e,y),p=k(u,r);_s(t,n,s,l,p,i,c,o)}else{const l=N(e);at(l,a,s,c,o)&&Ce(l,t,n,s,i,c,o);const p=H(e,y);at(p,a,s,c,o)&&Ce(p,t,n,s,i,c,o)}}const Hs=["x","y","z"];function qs(e,t,n,s,i,c){L.setBuffer(e._roots[t]);const o=Re(0,e,n,s,i,c);return L.clearBuffer(),o}function Re(e,t,n,s,i,c){const{float32Array:o,uint16Array:a,uint32Array:r}=L;let y=e*2;if(F(y,a)){const f=$(e,r),l=k(y,a);return Ms(t,n,s,f,l,i,c)}else{const f=Fe(e,r),l=Hs[f],g=s.direction[l]>=0;let A,w;g?(A=N(e),w=H(e,r)):(A=H(e,r),w=N(e));const d=at(A,o,s,i,c)?Re(A,t,n,s,i,c):null;if(d){const x=d.point[l];if(g?x<=o[w+f]:x>=o[w+f+3])return d}const m=at(w,o,s,i,c)?Re(w,t,n,s,i,c):null;return d&&m?d.distance<=m.distance?d:m:d||m||null}}const Zt=new W,wt=new K,At=new K,It=new rt,cn=new X,Yt=new X;function Os(e,t,n,s){L.setBuffer(e._roots[t]);const i=Ee(0,e,n,s);return L.clearBuffer(),i}function Ee(e,t,n,s,i=null){const{float32Array:c,uint16Array:o,uint32Array:a}=L;let r=e*2;if(i===null&&(n.boundingBox||n.computeBoundingBox(),cn.set(n.boundingBox.min,n.boundingBox.max,s),i=cn),F(r,o)){const u=t.geometry,f=u.index,l=u.attributes.position,p=n.index,g=n.attributes.position,A=$(e,a),w=k(r,o);if(It.copy(s).invert(),n.boundsTree)return z(e,c,Yt),Yt.matrix.copy(It),Yt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:d=>Yt.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let h=A,m=w+A;h<m;h++)if(U(At,3*t.resolveTriangleIndex(h),f,l),At.needsUpdate=!0,d.intersectsTriangle(At))return!0;return!1}});{const B=re(n);for(let d=A,h=w+A;d<h;d++){const m=t.resolveTriangleIndex(d);U(wt,3*m,f,l),wt.a.applyMatrix4(It),wt.b.applyMatrix4(It),wt.c.applyMatrix4(It),wt.needsUpdate=!0;for(let x=0,S=B*3;x<S;x+=3)if(U(At,x,p,g),At.needsUpdate=!0,wt.intersectsTriangle(At))return!0}}}else{const u=N(e),f=H(e,a);return z(u,c,Zt),!!(i.intersectsBox(Zt)&&Ee(u,t,n,s,i)||(z(f,c,Zt),i.intersectsBox(Zt)&&Ee(f,t,n,s,i)))}}const Wt=new rt,Ae=new X,Ct=new X,$s=new R,ks=new R,Xs=new R,Zs=new R;function Ys(e,t,n,s={},i={},c=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Ae.set(t.boundingBox.min,t.boundingBox.max,n),Ae.needsUpdate=!0;const a=e.geometry,r=a.attributes.position,y=a.index,u=t.attributes.position,f=t.index,l=Y.getPrimitive(),p=Y.getPrimitive();let g=$s,A=ks,w=null,B=null;i&&(w=Xs,B=Zs);let d=1/0,h=null,m=null;return Wt.copy(n).invert(),Ct.matrix.copy(Wt),e.shapecast({boundsTraverseOrder:x=>Ae.distanceToBox(x),intersectsBounds:(x,S,T)=>T<d&&T<o?(S&&(Ct.min.copy(x.min),Ct.max.copy(x.max),Ct.needsUpdate=!0),!0):!1,intersectsRange:(x,S)=>{if(t.boundsTree){const T=t.boundsTree;return T.shapecast({boundsTraverseOrder:_=>Ct.distanceToBox(_),intersectsBounds:(_,M,b)=>b<d&&b<o,intersectsRange:(_,M)=>{for(let b=_,v=_+M;b<v;b++){const P=T.resolveTriangleIndex(b);U(p,3*P,f,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let I=x,C=x+S;I<C;I++){const E=e.resolveTriangleIndex(I);U(l,3*E,y,r),l.needsUpdate=!0;const D=l.distanceToTriangle(p,g,w);if(D<d&&(A.copy(g),B&&B.copy(w),d=D,h=I,m=b),D<c)return!0}}}})}else{const T=re(t);for(let _=0,M=T;_<M;_++){U(p,3*_,f,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let b=x,v=x+S;b<v;b++){const P=e.resolveTriangleIndex(b);U(l,3*P,y,r),l.needsUpdate=!0;const I=l.distanceToTriangle(p,g,w);if(I<d&&(A.copy(g),B&&B.copy(w),d=I,h=b,m=_),I<c)return!0}}}}}),Y.releasePrimitive(l),Y.releasePrimitive(p),d===1/0?null:(s.point?s.point.copy(A):s.point=A.clone(),s.distance=d,s.faceIndex=h,i&&(i.point?i.point.copy(B):i.point=B.clone(),i.point.applyMatrix4(Wt),A.applyMatrix4(Wt),i.distance=A.sub(i.point).length(),i.faceIndex=m),s)}function an(e,t,n){return e===null?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e)}const jt=new X,Kt=new kn,ln=new R,fn=new rt,un=new R,Be=["getX","getY","getZ"];class se extends ds{static serialize(t,n={}){n={cloneBuffers:!0,...n};const s=t.geometry,i=t._roots,c=t._indirectBuffer,o=s.getIndex(),a={version:1,roots:null,index:null,indirectBuffer:null};return n.cloneBuffers?(a.roots=i.map(r=>r.slice()),a.index=o?o.array.slice():null,a.indirectBuffer=c?c.slice():null):(a.roots=i,a.index=o?o.array:null,a.indirectBuffer=c),a}static deserialize(t,n,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:i,roots:c,indirectBuffer:o}=t;t.version||r(c);const a=new se(n,{...s,[Ve]:!0});if(a._roots=c,a._indirectBuffer=o||null,s.setIndex){const y=n.getIndex();if(y===null){const u=new mn(t.index,1,!1);n.setIndex(u)}else y.array!==i&&(y.array.set(i),y.needsUpdate=!0)}return a;function r(y){for(let u=0;u<y.length;u++){const f=y[u],l=new Uint32Array(f),p=new Uint16Array(f);for(let g=0,A=f.byteLength/O;g<A;g++){const w=V*g,B=2*w;F(B,p)||(l[w+6]=l[w+6]/V-g)}}}}get primitiveStride(){return 3}get resolveTriangleIndex(){return this.resolvePrimitiveIndex}constructor(t,n={}){n.maxLeafTris&&(n={...n,maxLeafSize:n.maxLeafTris}),super(t,n)}shiftTriangleOffsets(t){return super.shiftPrimitiveOffsets(t)}writePrimitiveBounds(t,n,s){const i=this.geometry,c=this._indirectBuffer,o=i.attributes.position,a=i.index?i.index.array:null,y=(c?c[t]:t)*3;let u=y+0,f=y+1,l=y+2;a&&(u=a[u],f=a[f],l=a[l]);for(let p=0;p<3;p++){const g=o[Be[p]](u),A=o[Be[p]](f),w=o[Be[p]](l);let B=g;A<B&&(B=A),w<B&&(B=w);let d=g;A>d&&(d=A),w>d&&(d=w),n[s+p]=B,n[s+p+3]=d}return n}computePrimitiveBounds(t,n,s){const i=this.geometry,c=this._indirectBuffer,o=i.attributes.position,a=i.index?i.index.array:null,r=o.normalized;if(t<0||n+t-s.offset>s.length/6)throw new Error("MeshBVH: compute triangle bounds range is invalid.");const y=o.array,u=o.offset||0;let f=3;o.isInterleavedBufferAttribute&&(f=o.data.stride);const l=["getX","getY","getZ"],p=s.offset;for(let g=t,A=t+n;g<A;g++){const B=(c?c[g]:g)*3,d=(g-p)*6;let h=B+0,m=B+1,x=B+2;a&&(h=a[h],m=a[m],x=a[x]),r||(h=h*f+u,m=m*f+u,x=x*f+u);for(let S=0;S<3;S++){let T,_,M;r?(T=o[l[S]](h),_=o[l[S]](m),M=o[l[S]](x)):(T=y[h+S],_=y[m+S],M=y[x+S]);let b=T;_<b&&(b=_),M<b&&(b=M);let v=T;_>v&&(v=_),M>v&&(v=M);const P=(v-b)/2,I=S*2;s[d+I+0]=b+P,s[d+I+1]=P+(Math.abs(b)+P)*Jt}}return s}raycastObject3D(t,n,s=[]){const{material:i}=t;if(i===void 0)return;fn.copy(t.matrixWorld).invert(),Kt.copy(n.ray).applyMatrix4(fn),un.setFromMatrixScale(t.matrixWorld),ln.copy(Kt.direction).multiply(un);const c=ln.length(),o=n.near/c,a=n.far/c;if(n.firstHitOnly===!0){let r=this.raycastFirst(Kt,i,o,a);r=an(r,t,n),r&&s.push(r)}else{const r=this.raycast(Kt,i,o,a);for(let y=0,u=r.length;y<u;y++){const f=an(r[y],t,n);f&&s.push(f)}}return s}refit(t=null){return(this.indirect?Fs:Ss)(this,t)}raycast(t,n=Xe,s=0,i=1/0){const c=this._roots,o=[],a=this.indirect?Ns:Is;for(let r=0,y=c.length;r<y;r++)a(this,r,n,t,o,s,i);return o}raycastFirst(t,n=Xe,s=0,i=1/0){const c=this._roots;let o=null;const a=this.indirect?qs:Rs;for(let r=0,y=c.length;r<y;r++){const u=a(this,r,n,t,s,i);u!=null&&(o==null||u.distance<o.distance)&&(o=u)}return o}intersectsGeometry(t,n){let s=!1;const i=this._roots,c=this.indirect?Os:Es;for(let o=0,a=i.length;o<a&&(s=c(this,o,t,n),!s);o++);return s}shapecast(t){const n=Y.getPrimitive(),s=super.shapecast({...t,intersectsPrimitive:t.intersectsTriangle,scratchPrimitive:n,iterate:this.indirect?vs:bs});return Y.releasePrimitive(n),s}bvhcast(t,n,s){let{intersectsRanges:i,intersectsTriangles:c}=s;const o=Y.getPrimitive(),a=this.geometry.index,r=this.geometry.attributes.position,y=this.indirect?g=>{const A=this.resolveTriangleIndex(g);U(o,A*3,a,r)}:g=>{U(o,g*3,a,r)},u=Y.getPrimitive(),f=t.geometry.index,l=t.geometry.attributes.position,p=t.indirect?g=>{const A=t.resolveTriangleIndex(g);U(u,A*3,f,l)}:g=>{U(u,g*3,f,l)};if(c){if(!(t instanceof se))throw new Error('MeshBVH: "intersectsTriangles" callback can only be used with another MeshBVH.');const g=(A,w,B,d,h,m,x,S)=>{for(let T=B,_=B+d;T<_;T++){p(T),u.a.applyMatrix4(n),u.b.applyMatrix4(n),u.c.applyMatrix4(n),u.needsUpdate=!0;for(let M=A,b=A+w;M<b;M++)if(y(M),o.needsUpdate=!0,c(o,u,M,T,h,m,x,S))return!0}return!1};if(i){const A=i;i=function(w,B,d,h,m,x,S,T){return A(w,B,d,h,m,x,S,T)?!0:g(w,B,d,h,m,x,S,T)}}else i=g}return super.bvhcast(t,n,{intersectsRanges:i})}intersectsBox(t,n){return jt.set(t.min,t.max,n),jt.needsUpdate=!0,this.shapecast({intersectsBounds:s=>jt.intersectsBox(s),intersectsTriangle:s=>jt.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:n=>t.intersectsBox(n),intersectsTriangle:n=>n.intersectsSphere(t)})}closestPointToGeometry(t,n,s={},i={},c=0,o=1/0){return(this.indirect?Ys:Vs)(this,t,n,s,i,c,o)}closestPointToPoint(t,n={},s=0,i=1/0){return ws(this,t,n,s,i)}}const Tt={Mesh:Lt.prototype.raycast,Line:An.prototype.raycast,LineSegments:gn.prototype.raycast,LineLoop:wn.prototype.raycast,Points:Bn.prototype.raycast,BatchedMesh:Zn.prototype.raycast},q=new Lt,Qt=[];function Ws(e,t){if(this.isBatchedMesh)js.call(this,e,t);else{const{geometry:n}=this;if(n.boundsTree)n.boundsTree.raycastObject3D(this,e,t);else{let s;if(this instanceof Lt)s=Tt.Mesh;else if(this instanceof gn)s=Tt.LineSegments;else if(this instanceof wn)s=Tt.LineLoop;else if(this instanceof An)s=Tt.Line;else if(this instanceof Bn)s=Tt.Points;else throw new Error("BVH: Fallback raycast function not found.");s.call(this,e,t)}}}function js(e,t){if(this.boundsTrees){const n=this.boundsTrees,s=this._drawInfo||this._instanceInfo,i=this._drawRanges||this._geometryInfo,c=this.matrixWorld;q.material=this.material,q.geometry=this.geometry;const o=q.geometry.boundsTree,a=q.geometry.drawRange;q.geometry.boundingSphere===null&&(q.geometry.boundingSphere=new Xn);for(let r=0,y=s.length;r<y;r++){if(!this.getVisibleAt(r))continue;const u=s[r].geometryIndex;if(q.geometry.boundsTree=n[u],this.getMatrixAt(r,q.matrixWorld).premultiply(c),!q.geometry.boundsTree){this.getBoundingBoxAt(u,q.geometry.boundingBox),this.getBoundingSphereAt(u,q.geometry.boundingSphere);const f=i[u];q.geometry.setDrawRange(f.start,f.count)}q.raycast(e,Qt);for(let f=0,l=Qt.length;f<l;f++){const p=Qt[f];p.object=this,p.batchId=r,t.push(p)}Qt.length=0}q.geometry.boundsTree=o,q.geometry.drawRange=a,q.material=null,q.geometry=null}else Tt.BatchedMesh.call(this,e,t)}function Ks(e={}){const{type:t=se}=e;return this.boundsTree=new t(this,e),this.boundsTree}function Qs(){this.boundsTree=null}Sn.prototype.computeBoundsTree=Ks;Sn.prototype.disposeBoundsTree=Qs;Lt.prototype.raycast=Ws;const pn=[];function gi(e){pn.length=0,pn.push(...e)}let Rn=null,En=null,Ln=null,zn=null;function wi(){return Rn}function Js(){return En}function Ai(){return Ln}function Bi(){return zn}function Ti(e){Rn=e}function Pi(e){En=e}function bi(e){Ln=e}function Si(e){zn=e}let Gs=1.7,ti=0,ei=200,ni=.4,si=1;function _i(e){Gs=e}function Mi(e){ti=e}function vi(e){ei=e}function Ii(e){ni=e}function Ci(e){si=e}const Ri=Ue(!1),Ei=!1,Li=Ue(!1),Et=[],yn=[],dn=[],zi=new Map,Di=new bn,Ui=new bn,ii=[];for(let e=0;e<8;e++){const t=e/8*Math.PI*2;ii.push(new R(Math.cos(t),0,Math.sin(t)))}const Vi=new Pn(26248),Fi=.8,Ni=new Pn(21862),Hi=.4;function qi(e){return Math.round(e*1e4)/1e4}function Oi(e){return e.split("/").pop()||""}function $i(e){return e.replace(/\.glb$/i,"").replace(/[-_]/g," ").replace(/\b\w/g,t=>t.toUpperCase())}const Te=new R;function ki(){return Js().getWorldDirection(Te),Math.atan2(Te.x,Te.z)}function nt(e){e&&(e.source?.data?.close&&e.source.data.close(),e.dispose())}function Xi(e){e.traverse(t=>{if(t.geometry&&t.geometry.dispose(),t.material){const n=Array.isArray(t.material)?t.material:[t.material];for(const s of n)nt(s.map),nt(s.normalMap),nt(s.roughnessMap),nt(s.metalnessMap),nt(s.emissiveMap),nt(s.aoMap),nt(s.lightMap),nt(s.alphaMap),s.dispose()}})}function Zi(e){e.traverse(t=>{t.geometry&&t.geometry.dispose()})}function Yi(e,t,n){const s=[];return e.traverse(i=>{if(!i.isMesh||i.userData.isDisplayZone)return;const c=Array.isArray(i.material)?i.material:[i.material];for(const o of c)o.emissive&&(s.push({mesh:i,origEmissive:o.emissive.clone(),origEmissiveIntensity:o.emissiveIntensity??1}),o.emissive.copy(t),o.emissiveIntensity=n)}),s}function Wi(e){for(const t of e){const n=Array.isArray(t.mesh.material)?t.mesh.material:[t.mesh.material];for(const s of n)s.emissive&&(s.emissive.copy(t.origEmissive),s.emissiveIntensity=t.origEmissiveIntensity)}}function ji(e){Dn(e),e.traverse(t=>{if(!t.isMesh)return;let n=Et.indexOf(t);n>=0&&Et.splice(n,1),n=yn.indexOf(t),n>=0&&yn.splice(n,1)})}const oi=200;function ri(e){const t=e.geometry;if(!t||t.boundsTree)return;const n=t.index;(n?n.count/3:(t.attributes?.position?.count??0)/3)>oi&&t.computeBoundsTree({strategy:0,maxLeafSize:10})}function ci(e){e.traverse(t=>{t.isMesh&&ri(t)})}const te=[];let ee=!1;function Ki(e){te.push(e),ee||ai()}function ai(){if(te.length===0){ee=!1;return}ee=!0;const e=()=>{const t=te.shift();t&&ci(t),te.length>0?typeof Dt<"u"?Dt(e,{timeout:500}):setTimeout(e,0):ee=!1};typeof Dt<"u"?Dt(e,{timeout:500}):setTimeout(e,0)}const li=new Yn({visible:!1}),ie=new Map,ot=new R,oe=new R;function fi(e){Dn(e);const t=new W().setFromObject(e);if(t.isEmpty())return;t.getSize(ot),t.getCenter(oe);const n=new Tn(ot.x,ot.y,ot.z);n.computeBoundingSphere();const s=new Lt(n,li);s.position.copy(oe),s.visible=!1,s.matrixAutoUpdate=!1,s.updateMatrix(),s.matrixWorld.copy(s.matrix),s.userData.isCollisionProxy=!0,Et.push(s),ie.set(e,s)}function Dn(e){const t=ie.get(e);if(!t)return;const n=Et.indexOf(t);n>=0&&Et.splice(n,1),t.geometry.dispose(),ie.delete(e)}function Qi(e){for(let t=0;t<dn.length;t++){const n=dn[t],s=ie.get(n.group),i=e?.[t]??new W().setFromObject(n.group);i.isEmpty()||(i.getSize(ot),i.getCenter(oe),s?(s.geometry.dispose(),s.geometry=new Tn(ot.x,ot.y,ot.z),s.geometry.computeBoundingSphere(),s.position.copy(oe),s.updateMatrix(),s.matrixWorld.copy(s.matrix)):fi(n.group))}}const ui=Ue(!1);function Ji(){return{sidebarOpen:ui}}export{ci as A,Ni as B,Et as C,ii as D,Di as E,ni as F,Qi as G,ri as H,Mi as I,Ci as J,_i as K,Ii as L,ei as M,vi as N,gi as O,Hi as P,Dn as Q,Si as R,Ti as S,Fi as T,Pi as U,bi as V,Ei as W,hi as X,xi as Y,Ji as Z,mi as _,wi as a,Ai as b,Js as c,pn as d,Ri as e,$i as f,Bi as g,yn as h,zi as i,Oi as j,ji as k,Zi as l,qi as m,Ki as n,fi as o,dn as p,Ui as q,si as r,ti as s,Gs as t,Xi as u,Li as v,Wi as w,Yi as x,Vi as y,ki as z};

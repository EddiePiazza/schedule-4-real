import{d as e,r as i,c as o}from"../../../nitro/nitro.mjs";import{g as t,e as d,s as n,a as r,u as l,c as s}from"../../../_/mqtt.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";import"mqtt";import"child_process";const a=e(async e=>{var a,m,p,f,v,g,h,c,u,y,P,T,O;const L=await i(e),{light:k,...b}=L;if(!k)throw o({statusCode:400,message:"Light ID is required"});try{const e=t(),i="light2"===k,o=i?["light2"]:["device","light"],T=i?"light2":"light",O=d(e),L=null==(a=null==O?void 0:O.data)?void 0:a.plan;if(1===(null==L?void 0:L.isPlanRun)&&(null==L?void 0:L.stageId)){const o=i?"light2":"light1";try{const i=await n({method:"getConfigField",params:{keyPath:["plan"]}},e,5e3),t=null==(m=null==i?void 0:i.data)?void 0:m.plan;if((null==t?void 0:t.stage)&&Array.isArray(t.stage)){const i=t.stage.findIndex(e=>e.stageId===L.stageId);if(i>=0){const d=t.stage[i],n=d[o]||{};void 0!==b.modeType&&(n.modeType=b.modeType),void 0!==b.mOnOff&&(n.mOnOff=b.mOnOff),void 0!==b.mLevel&&(n.mLevel=b.mLevel,"level"in n&&(n.level=b.mLevel)),void 0!==b.timePeriod&&(n.timePeriod=b.timePeriod),void 0!==b.darkTemp&&(n.darkTemp=b.darkTemp),void 0!==b.offTemp&&(n.offTemp=b.offTemp),void 0!==b.ppfdPeriod&&(n.ppfdPeriod=b.ppfdPeriod),void 0!==b.ppfdMinBrightness&&(n.ppfdMinBrightness=b.ppfdMinBrightness),void 0!==b.ppfdMaxBrightness&&(n.ppfdMaxBrightness=b.ppfdMaxBrightness);const s=null!=(p=n.mLevel)?p:n.level;if(void 0!==s&&Array.isArray(n.timePeriod)&&n.timePeriod.length>0){const e=n.timePeriod.findIndex(e=>e.enabled),i=e>=0?e:0;n.timePeriod[i]&&(n.timePeriod[i].brightness=s)}if(Array.isArray(n.timePeriod)&&n.timePeriod.length>0&&void 0===s){const e=n.timePeriod.findIndex(e=>e.enabled),i=e>=0?e:0;void 0!==(null==(f=n.timePeriod[i])?void 0:f.brightness)&&(n.mLevel=n.timePeriod[i].brightness)}d[o]=n,await r({method:"setConfigField",params:{keyPath:["plan"],plan:t}},e),l(e,{plan:t});const a={...n};return void 0===a.mLevel&&void 0!==a.level&&(a.mLevel=a.level),void 0===a.mOnOff&&void 0!==a.on&&(a.mOnOff=a.on),{success:!0,light:k,...a}}}}catch(e){console.log("[Light Config] Plan save failed, falling back to device config")}}let w={};try{const i=await n({method:"getConfigField",params:{keyPath:o}},e,5e3);w=(null==(v=null==i?void 0:i.data)?void 0:v[T])||{}}catch{}const M={...w};void 0!==b.modeType?M.modeType=b.modeType:void 0!==w.modeType&&(M.modeType=w.modeType),void 0!==b.lastAutoModeType&&(M.lastAutoModeType=b.lastAutoModeType),void 0!==b.mOnOff&&(M.mOnOff=b.mOnOff,"on"in w&&(M.on=b.mOnOff)),void 0!==b.mLevel&&(M.mLevel=b.mLevel,"level"in w&&(M.level=b.mLevel)),void 0!==b.timePeriod&&(M.timePeriod=b.timePeriod);const A=null!=(g=M.mLevel)?g:M.level;if(void 0!==A&&Array.isArray(M.timePeriod)&&M.timePeriod.length>0){const e=M.timePeriod.findIndex(e=>e.enabled),i=e>=0?e:0;M.timePeriod[i]&&(M.timePeriod[i].brightness=A)}if(Array.isArray(M.timePeriod)&&M.timePeriod.length>0&&void 0===A){const e=M.timePeriod.findIndex(e=>e.enabled),i=e>=0?e:0;if(void 0!==(null==(h=M.timePeriod[i])?void 0:h.brightness)){const e=M.timePeriod[i].brightness;M.mLevel=e,"level"in w&&(M.level=e)}}void 0!==b.darkTemp?M.darkTemp=b.darkTemp:void 0!==w.darkTemp&&(M.darkTemp=w.darkTemp),void 0!==b.offTemp?M.offTemp=b.offTemp:void 0!==w.offTemp&&(M.offTemp=w.offTemp),void 0!==b.ppfdPeriod&&(M.ppfdPeriod=b.ppfdPeriod),void 0!==b.ppfdMinBrightness&&(M.ppfdMinBrightness=b.ppfdMinBrightness),void 0!==b.ppfdMaxBrightness&&(M.ppfdMaxBrightness=b.ppfdMaxBrightness);const C={method:"setConfigField",params:{keyPath:o,[T]:M}};console.log("[Light Config] Sending to device:",JSON.stringify({keyPath:o,config:M},null,2));const x=await n(C,e,1e4);console.log("[Light Config] Device response:",JSON.stringify(x,null,2)),await new Promise(e=>setTimeout(e,500));let B=M;try{const i=await n({method:"getConfigField",params:{keyPath:o}},e,5e3);console.log("[Light Config] Verify read response:",JSON.stringify(i,null,2));const t=null==(c=null==i?void 0:i.data)?void 0:c[T];if(t&&(console.log("[Light Config] Read back timePeriod:",JSON.stringify(t.timePeriod,null,2)),B=t,t.modeType!==M.modeType||t.darkTemp!==M.darkTemp||t.offTemp!==M.offTemp)){await new Promise(e=>setTimeout(e,1e3));const i=await n({method:"getConfigField",params:{keyPath:o}},e,5e3),t=null==(u=null==i?void 0:i.data)?void 0:u[T];if(t&&(B=t,t.modeType!==M.modeType))throw new Error("Save verification failed: modeType mismatch")}}catch(e){if(null==(y=e.message)?void 0:y.includes("verification failed"))throw e}if(void 0===B.mLevel&&void 0!==B.level&&(B.mLevel=B.level),void 0===B.mOnOff&&void 0!==B.on&&(B.mOnOff=B.on),i)l(e,{light2:B});else{const i=s(e),o=(null==(P=null==i?void 0:i.data)?void 0:P.device)||{};l(e,{device:{...o,light:B}})}return{success:!0,light:k,...B}}catch(e){throw console.error("Failed to update light config:",e),o({statusCode:(null==(T=e.message)?void 0:T.includes("verification"))?409:500,message:(null==(O=e.message)?void 0:O.includes("verification"))?"Settings saved but verification failed - device may not have applied changes":"Failed to update light configuration"})}});export{a as default};

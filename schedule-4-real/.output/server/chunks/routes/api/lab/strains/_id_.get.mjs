import{d as t,g as e,c as n}from"../../../../nitro/nitro.mjs";import{sanitizeUUID as s,query as o}from"../../../../_/db.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";import"pg";const a=t(async t=>{const a=e(t,"id");if(!a)throw n({statusCode:400,message:"Strain ID is required"});let i;try{i=s(a)}catch{throw n({statusCode:400,message:"Invalid strain ID format"})}try{const t=await o(`\n      SELECT * FROM (\n        SELECT *, ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n        FROM lab_strains\n        WHERE id = '${i}'\n      )\n      WHERE rn = 1 AND is_deleted = 0\n    `);if(!t.length)throw n({statusCode:404,message:"Strain not found"});const e=t[0],s=await o(`\n      SELECT\n        id, plant_code, status, selection_status, pheno_label, is_keeper,\n        final_score, sex, origin_type, date_started, date_to_flower, date_harvested,\n        total_veg_days, total_flower_days, final_height_cm, training_methods,\n        container_size, grow_medium, keeper_notes\n      FROM (\n        SELECT *, ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n        FROM lab_plants\n        WHERE strain_id = '${i}'\n      )\n      WHERE rn = 1 AND is_deleted = 0\n      ORDER BY date_started DESC\n    `),a=s.map(t=>t.id);let r=[];if(a.length>0){const t=await o(`\n        SELECT obs.photos, obs.observed_at, obs.plant_id, p.plant_code\n        FROM (\n          SELECT id, plant_id, photos, observed_at, is_deleted,\n            ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n          FROM lab_observations\n          WHERE plant_id IN ('${a.join("','")}')\n        ) obs\n        LEFT JOIN (\n          SELECT id, plant_code, ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n          FROM lab_plants\n        ) p ON obs.plant_id = p.id AND p.rn = 1\n        WHERE obs.rn = 1 AND obs.is_deleted = 0 AND obs.photos IS NOT NULL\n        ORDER BY obs.observed_at DESC\n        LIMIT 50\n      `);for(const e of t)if(e.photos)try{const t=JSON.parse(e.photos);if(Array.isArray(t))for(const n of t)r.push({url:n,plant_code:e.plant_code,plant_id:e.plant_id,observed_at:e.observed_at})}catch{}r=r.slice(0,20)}let d=[];a.length>0&&(d=await o(`\n        SELECT obs.id, obs.plant_id, obs.observed_at, obs.obs_type, obs.general_notes,\n          obs.health_score, obs.stage, p.plant_code\n        FROM (\n          SELECT id, plant_id, observed_at, obs_type, general_notes, health_score, stage, is_deleted,\n            ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n          FROM lab_observations\n          WHERE plant_id IN ('${a.join("','")}')\n        ) obs\n        LEFT JOIN (\n          SELECT id, plant_code, ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n          FROM lab_plants\n        ) p ON obs.plant_id = p.id AND p.rn = 1\n        WHERE obs.rn = 1 AND obs.is_deleted = 0\n        ORDER BY obs.observed_at DESC\n        LIMIT 10\n      `));const _=await o(`\n      SELECT id, name, code, project_type, status, primary_goal\n      FROM (\n        SELECT *, ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n        FROM lab_breeding_projects\n        WHERE female_strain_id = '${i}' OR male_strain_id = '${i}'\n      )\n      WHERE rn = 1 AND is_deleted = 0\n      ORDER BY timestamp DESC\n      LIMIT 10\n    `),l=s.filter(t=>!["archived","culled"].includes(t.status)),p=s.filter(t=>["archived","harvest","drying","curing"].includes(t.status)),E=s.filter(t=>t.is_keeper),c=s.filter(t=>t.final_score&&t.final_score>0),m=c.length>0?c.reduce((t,e)=>t+e.final_score,0)/c.length:0,R=c.length>0?Math.max(...c.map(t=>t.final_score)):0,h=c.find(t=>t.final_score===R),f=s.filter(t=>t.total_flower_days&&t.total_flower_days>0),O=f.length>0?Math.round(f.reduce((t,e)=>t+e.total_flower_days,0)/f.length):null,b=s.filter(t=>t.final_height_cm&&t.final_height_cm>0),g=b.length>0?Math.round(b.reduce((t,e)=>t+e.final_height_cm,0)/b.length):null,u={};for(const t of s)if(t.training_methods)try{const e=JSON.parse(t.training_methods);for(const t of e)u[t]=(u[t]||0)+1}catch{}const N=Object.entries(u).sort((t,e)=>e[1]-t[1]).slice(0,3).map(([t])=>t),D={};for(const t of s)D[t.status]=(D[t.status]||0)+1;return{...e,dominant_terpenes:e.dominant_terpenes?JSON.parse(e.dominant_terpenes):[],plants:s.map(t=>({...t,training_methods:t.training_methods?JSON.parse(t.training_methods):[]})),photos:r,recent_observations:d,breeding_projects:_,stats:{total_plants:s.length,active_plants:l.length,completed_plants:p.length,keepers:E.length,avg_score:Math.round(10*m)/10,best_score:Math.round(10*R)/10,best_plant:h?{id:h.id,code:h.plant_code,score:h.final_score}:null,avg_flowering_days:O,flowering_diff:O&&e.expected_flowering_days?O-e.expected_flowering_days:null,avg_height_cm:g,common_training:N,plants_by_status:D}}}catch(t){if(t.statusCode)throw t;throw console.error("Failed to fetch strain:",t),n({statusCode:500,message:"Failed to fetch strain"})}});export{a as default};

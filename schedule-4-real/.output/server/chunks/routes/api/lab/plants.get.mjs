import{d as t,a as e}from"../../../nitro/nitro.mjs";import{sanitizeInt as n,sanitizeString as i,query as o}from"../../../_/db.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";import"pg";const r=t(async t=>{var r,s;const a=e(t),m=a.status,p=a.selection,d=Math.min(n(a.limit||"50"),500),l=Math.max(0,n(a.offset||"0"));try{let t="rn = 1 AND is_deleted = 0";m&&(t+="active"===m?" AND status NOT IN ('archived', 'culled')":` AND status = '${i(m)}'`),p&&(t+=` AND selection_status = '${i(p)}'`);const e=(await o(`\n      SELECT * FROM (\n        SELECT *, ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n        FROM lab_plants\n      )\n      WHERE ${t}\n      ORDER BY date_started DESC\n      LIMIT ${d+l}\n    `)).slice(l,l+d),n=[...new Set(e.map(t=>t.strain_id).filter(Boolean))];let r={};if(n.length>0)try{const t=await o(`\n          SELECT id, name FROM (\n            SELECT id, name, is_deleted, ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n            FROM lab_strains\n            WHERE id IN ('${n.join("','")}')\n          )\n          WHERE rn = 1 AND is_deleted = 0\n        `);r=Object.fromEntries(t.map(t=>[t.id,t.name]))}catch{}return e.map(t=>({...t,strain_name:r[t.strain_id]||null,training_methods:t.training_methods?JSON.parse(t.training_methods):[]}))}catch(t){return(null==(r=t.message)?void 0:r.includes("does not exist"))||(null==(s=t.message)?void 0:s.includes("table not found"))||console.error("Failed to fetch plants:",t),[]}});export{r as default};

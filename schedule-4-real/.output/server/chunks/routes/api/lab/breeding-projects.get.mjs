import{d as t,a as r}from"../../../nitro/nitro.mjs";import{sanitizeInt as e,sanitizeString as i,query as n}from"../../../_/db.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";import"pg";const o=t(async t=>{var o,a;const s=r(t),m=s.status,p=Math.min(e(s.limit||"100"),500);try{let t="rn = 1 AND (is_deleted = 0 OR is_deleted IS NULL)";if(m){t+=` AND status = '${i(m)}'`}const r=await n(`\n      SELECT * FROM (\n        SELECT *, ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n        FROM lab_breeding_projects\n      )\n      WHERE ${t}\n      ORDER BY started_at DESC\n      LIMIT ${p}\n    `);let e={};try{const t=await n("\n        SELECT id, name FROM (\n          SELECT *, ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n          FROM lab_strains\n        )\n        WHERE rn = 1 AND is_deleted = 0\n      ");e=Object.fromEntries(t.map(t=>[t.id,t.name]))}catch{}return r.map(t=>({...t,target_traits:t.target_traits?JSON.parse(t.target_traits):[],traits_to_avoid:t.traits_to_avoid?JSON.parse(t.traits_to_avoid):[],female_strain_name:e[t.female_strain_id]||t.female_strain_id||"Unknown",male_strain_name:e[t.male_strain_id]||t.male_strain_id||"Unknown"}))}catch(t){return(null==(o=t.message)?void 0:o.includes("does not exist"))||(null==(a=t.message)?void 0:a.includes("table not found"))||console.error("Failed to fetch breeding projects:",t),[]}});export{o as default};

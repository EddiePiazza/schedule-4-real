import{d as t,a as o}from"../../../nitro/nitro.mjs";import{sanitizeInt as i,sanitizeString as n,query as r}from"../../../_/db.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";import"pg";const e=t(async t=>{var e,a;const s=o(t),m=s.status,p=Math.min(i(s.limit||"100"),500);try{let t="rn = 1";if(m){t+=` AND status = '${n(m)}'`}const o=await r(`\n      SELECT * FROM (\n        SELECT *, ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n        FROM lab_pollen_storage\n      )\n      WHERE ${t}\n      ORDER BY collection_date DESC\n      LIMIT ${p}\n    `);let i={};try{const t=await r("\n        SELECT id, name FROM (\n          SELECT *, ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n          FROM lab_strains\n        )\n        WHERE rn = 1 AND is_deleted = 0\n      ");i=Object.fromEntries(t.map(t=>[t.id,t.name]))}catch{}return o.map(t=>({...t,strain_name:i[t.strain_id]||t.strain_id||"Unknown",strainName:i[t.strain_id]||t.strain_id||"Unknown",batchCode:t.batch_code,collectionDate:t.collection_date,storageMethod:t.storage_method||"refrigerated",viability:t.current_viability||t.viability_at_collection||90}))}catch(t){return(null==(e=t.message)?void 0:e.includes("does not exist"))||(null==(a=t.message)?void 0:a.includes("table not found"))||console.error("Failed to fetch pollen inventory:",t),[]}});export{e as default};

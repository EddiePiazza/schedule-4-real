import{d as t,g as e,r as a,c as n}from"../../../../nitro/nitro.mjs";import{sanitizeUUID as o,query as s,sanitizeString as i}from"../../../../_/db.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";import"pg";const r=t(async t=>{const r=e(t,"id"),d=await a(t);if(!r)throw n({statusCode:400,message:"Plant ID is required"});let p;try{p=o(r)}catch{throw n({statusCode:400,message:"Invalid plant ID format"})}try{const t=await s(`\n      SELECT * FROM (\n        SELECT *, ROW_NUMBER() OVER (PARTITION BY id ORDER BY timestamp DESC) as rn\n        FROM lab_plants\n        WHERE id = '${p}'\n      )\n      WHERE rn = 1 AND is_deleted = 0\n    `);if(!t.length)throw n({statusCode:404,message:"Plant not found"});const e=t[0],a=(new Date).toISOString(),o=d.status&&d.status!==e.status,r=["timestamp","id","strain_id","seed_batch_id","zone_id","plant_code","pheno_label","origin_type","parent_plant_id","project_goal","status","selection_status","cull_reason","cull_date","is_keeper","keeper_notes","sex","sex_confirmed_date","date_started","date_to_veg","date_to_flower","date_harvested","current_week","current_day","total_veg_days","total_flower_days","container_size","grow_medium","nutrients_type","training_methods","final_height_cm","final_score","hof_category","hof_notes","breeding_project_id","is_deleted"],getValue=t=>{const a=void 0!==d[t]?d[t]:e[t];return null==a?"NULL":"training_methods"===t&&Array.isArray(a)?`'${i(JSON.stringify(a))}'`:"string"==typeof a?`'${i(a)}'`:a},_=r.map(t=>"timestamp"===t?"now()":getValue(t));if(await s(`\n      INSERT INTO lab_plants (${r.join(", ")})\n      VALUES (${_.join(", ")})\n    `),o){const t=i(d.status),e=a.split("T")[0];await s(`\n        INSERT INTO lab_stage_log (timestamp, id, plant_id, stage, started_at, ended_at, duration_days, notes)\n        SELECT now(), id, plant_id, stage, started_at, '${e}',\n               datediff('d', started_at, now()), 'Transitioned to ${t}'\n        FROM lab_stage_log\n        WHERE plant_id = '${p}' AND ended_at IS NULL\n        LATEST ON timestamp PARTITION BY plant_id\n      `);const{randomUUID:n}=await import("crypto");await s(`\n        INSERT INTO lab_stage_log (timestamp, id, plant_id, stage, started_at, notes)\n        VALUES (now(), '${n()}', '${p}', '${t}', '${e}', 'Stage started')\n      `)}return(await s(`\n      SELECT * FROM lab_plants\n      WHERE id = '${p}'\n      ORDER BY timestamp DESC\n      LIMIT 1\n    `))[0]}catch(t){if(t.statusCode)throw t;throw console.error("Failed to update plant:",t),n({statusCode:500,message:"Failed to update plant"})}});export{r as default};

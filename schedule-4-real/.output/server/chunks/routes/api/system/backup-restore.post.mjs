import{d as e,r as t,c as o,b as s}from"../../../nitro/nitro.mjs";import{existsSync as n,mkdirSync as r,writeFileSync as a,readFileSync as i}from"fs";import{resolve as c}from"path";import{Socket as p}from"net";import{gzipSync as m,gunzipSync as f}from"zlib";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"https";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs/promises";import"node:url";const l={TIMESTAMP:"TIMESTAMP",DOUBLE:"DOUBLE",FLOAT:"FLOAT",INT:"INT",LONG:"LONG",SHORT:"SHORT",BYTE:"BYTE",BOOLEAN:"BOOLEAN",STRING:"STRING",SYMBOL:"SYMBOL",LONG256:"LONG256",CHAR:"CHAR",DATE:"DATE",BINARY:"BINARY",GEOHASH:"GEOHASH",UUID:"UUID"},u=e(async e=>{const p=await t(e),{filename:u}=p;if(!u)throw o({statusCode:400,message:"Missing filename"});if(u.includes("..")||u.includes("/"))throw o({statusCode:400,message:"Invalid filename"});const T=c(s(),"database/backups"),d=c(T,u);if(!n(d))throw o({statusCode:404,message:"Backup not found"});const S=process.env.QUESTDB_HOST||"127.0.0.1",$=process.env.QUESTDB_HTTP_PORT||"9000",O=process.env.QUESTDB_HOST||"127.0.0.1",g=parseInt(process.env.QUESTDB_ILP_PORT||"9009"),h=`http://${S}:${$}`;try{console.log("[Restore] Creating safety backup...");const e=`safety-${(new Date).toISOString().replace(/[:.]/g,"-").slice(0,19)}.json.gz`,t=await fetch(`${h}/exec?query=${encodeURIComponent("SHOW TABLES")}`);if(t.ok){const o=await t.json(),s=["sys.","telemetry","_query_trace"],n=o.dataset.map(e=>e[0]).filter(e=>!s.some(t=>e.startsWith(t))),i=[];for(const e of n)try{const t=await fetch(`${h}/exec?query=${encodeURIComponent(`SHOW COLUMNS FROM '${e}'`)}`);if(!t.ok)continue;const o=(await t.json()).dataset.map(e=>({name:e[0],type:e[1]})),s=await fetch(`${h}/exec?query=${encodeURIComponent(`SELECT * FROM '${e}' LIMIT 1000000`)}`);if(!s.ok)continue;const n=await s.json();i.push({name:e,schema:o,rowCount:n.count||0,data:n.dataset||[]})}catch{}r(T,{recursive:!0});const p=Buffer.from(JSON.stringify({version:1,created:(new Date).toISOString(),tables:i}));a(c(T,e),m(p,{level:6})),console.log(`[Restore] Safety backup created: ${e}`)}const n=i(d);let p;p=u.endsWith(".gz")?f(n).toString("utf-8"):n.toString("utf-8");const S=JSON.parse(p);if(!S.version||!S.tables)throw o({statusCode:400,message:"Invalid backup format"});let $=0,I=0;for(const e of S.tables){if(!e.name||!e.schema||!e.data)continue;if(!(await fetch(`${h}/exec?query=${encodeURIComponent(`SELECT count() FROM '${e.name}'`)}`)).ok){const t=e.schema.find(e=>"TIMESTAMP"===e.type),o=e.schema.map(e=>{const t=l[e.type.toUpperCase()]||"STRING";return`${e.name} ${t}`}).join(", "),s=t?`CREATE TABLE IF NOT EXISTS '${e.name}' (${o}) timestamp(${t.name}) PARTITION BY DAY WAL`:`CREATE TABLE IF NOT EXISTS '${e.name}' (${o})`;await fetch(`${h}/exec?query=${encodeURIComponent(s)}`)}if(e.data.length>0){I+=await insertViaILP(e,O,g)}$++}let E=[];if(S.configFiles&&"object"==typeof S.configFiles){const e=["proxy/proxy-config.json"];for(const[t,o]of Object.entries(S.configFiles))if(e.includes(t))try{const e=c(s(),t);a(e,JSON.stringify(o,null,2)),E.push(t),console.log(`[Restore] Restored config file: ${t}`)}catch(e){console.error(`[Restore] Failed to restore ${t}:`,e.message)}}return{success:!0,safetyBackup:e,restoredTables:$,restoredRows:I,restoredFiles:E}}catch(e){if(e.statusCode)throw e;throw o({statusCode:500,message:"Failed to restore backup: "+e.message})}});async function insertViaILP(e,t,o){return new Promise((s,n)=>{const r=new p;let a=0,i="";r.connect(o,t,()=>{const t=e.schema,o=t.findIndex(e=>"TIMESTAMP"===e.type);for(const s of e.data){let n="",c=[],p="";for(let e=0;e<t.length;e++){const r=t[e],a=s[e];if(null==a)continue;if(e===o){const e=new Date(a).getTime();isNaN(e)||(p=""+BigInt(e)*BigInt(1e6));continue}const i=r.type.toUpperCase();if("SYMBOL"===i){const e=String(a).replace(/[, =\\]/g,e=>`\\${e}`);n+=`,${r.name}=${e}`}else if("STRING"===i)c.push(`${r.name}="${String(a).replace(/["\\]/g,e=>`\\${e}`)}"`);else if("BOOLEAN"===i)c.push(`${r.name}=${a?"t":"f"}`);else if("DOUBLE"===i||"FLOAT"===i){const e=parseFloat(a);isNaN(e)||c.push(`${r.name}=${e}`)}else if("INT"===i||"LONG"===i||"SHORT"===i||"BYTE"===i){const e=parseInt(a);isNaN(e)||c.push(`${r.name}=${e}i`)}else c.push(`${r.name}="${String(a).replace(/["\\]/g,e=>`\\${e}`)}"`)}if(0===c.length)continue;const m=`${e.name}${n} ${c.join(",")} ${p}\n`;i+=m,a++,i.length>65536&&(r.write(i),i="")}i.length>0?r.write(i,()=>{r.destroy(),s(a)}):(r.destroy(),s(a))}),r.on("error",e=>{r.destroy(),n(e)}),setTimeout(()=>{r.destroy(),s(a)},3e4)})}export{u as default};

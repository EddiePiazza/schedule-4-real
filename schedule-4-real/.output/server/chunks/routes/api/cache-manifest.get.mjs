import{d as t,b as o}from"../../nitro/nitro.mjs";import{promises as e,createReadStream as a}from"fs";import{join as r,extname as s}from"path";import{createHash as i}from"crypto";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs/promises";import"node:url";const n=new Set([".js",".mjs",".cjs",".css",".html",".htm",".map",".ts",".vue",".txt",".md",".xml",".yaml",".yml",".log",".env",".sh"]),c=new Set(["node_modules",".git","_nuxt","room3d","uploads"]);let m=null,p=0;const d=t(async()=>{const t=Date.now();if(m&&t<p)return m;const a={},s=r(o(),"data","appdata");await scanDirectory(s,"",a);const i=r(o(),"data","uploads");try{await e.access(i),await scanDirectory(i,"/lab/uploads",a)}catch{}const n=r(o(),"data","cache","models");try{await e.access(n),await scanDirectory(n,"/cache/models",a)}catch{}const c=r(o(),".output","public");return await scanDirectory(c,"",a),m={files:a,generated:t},p=t+3e4,m});async function scanDirectory(t,o,a){let i;try{i=await e.readdir(t,{withFileTypes:!0})}catch{return}for(const m of i){if(m.name.startsWith("."))continue;const i=r(t,m.name);if(m.isDirectory()){if(c.has(m.name))continue;const t=o?`${o}/${m.name}`:`/${m.name}`;await scanDirectory(i,t,a)}else{const t=s(m.name).toLowerCase();if(n.has(t))continue;try{const t=await e.stat(i);let r;r=t.size<1048576?await computeFileHash(i):`${Math.floor(t.mtimeMs)}-${t.size}`;a[o?`${o}/${m.name}`:`/${m.name}`]={hash:r,size:t.size}}catch{}}}}function computeFileHash(t){return new Promise((o,e)=>{const r=i("md5"),s=a(t);s.on("data",t=>r.update(t)),s.on("end",()=>o(r.digest("hex"))),s.on("error",e)})}export{d as default};

import{d as o,r as t,c as r,b as i}from"../../../nitro/nitro.mjs";import{readFile as s,mkdir as e,writeFile as p}from"fs/promises";import{join as m}from"path";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"node:url";const n=o(async o=>{const n=await t(o);if(!(null==n?void 0:n.roomId)||"string"!=typeof n.roomId)throw r({statusCode:400,message:"roomId (string) required"});const a=m(i(),"data","room3d"),c=m(a,"room-settings.json");let l={rooms:{}};try{const o=JSON.parse(await s(c,"utf-8"));o.rooms&&"object"==typeof o.rooms&&(l=o)}catch{}const d=l.rooms[n.roomId]||{};return"boolean"==typeof n.isPublic&&(d.isPublic=n.isPublic),"boolean"==typeof n.inviteOnly&&(d.inviteOnly=n.inviteOnly),"string"==typeof n.publicName&&(d.publicName=n.publicName.slice(0,60)),"string"==typeof n.publicDescription&&(d.publicDescription=n.publicDescription.slice(0,200)),"string"==typeof n.password&&(d.password=n.password.slice(0,32)),l.rooms[n.roomId]=d,await e(a,{recursive:!0}),await p(c,JSON.stringify(l,null,2),"utf-8"),{ok:!0,roomId:n.roomId,settings:d}});export{n as default};

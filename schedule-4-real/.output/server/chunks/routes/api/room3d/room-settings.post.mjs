import{d as o,r as t,c as r,b as i}from"../../../nitro/nitro.mjs";import{readFile as s,mkdir as e,writeFile as p}from"fs/promises";import{join as m}from"path";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"node:url";const a=o(async o=>{const a=await t(o);if(!(null==a?void 0:a.roomId)||"string"!=typeof a.roomId)throw r({statusCode:400,message:"roomId (string) required"});const n=!0===a.system,d=n?m(i(),"data","appdata","defaults"):m(i(),"data","room3d"),c=m(d,"room-settings.json");let l={rooms:{}};const f=n?m(i(),"data","room3d"):m(i(),"data","appdata","defaults");for(const o of[c,m(f,"room-settings.json")])try{const t=JSON.parse(await s(o,"utf-8"));t.rooms&&"object"==typeof t.rooms&&(l=t);break}catch{}const u=l.rooms[a.roomId]||{};return"boolean"==typeof a.isPublic&&(u.isPublic=a.isPublic),"boolean"==typeof a.inviteOnly&&(u.inviteOnly=a.inviteOnly),"string"==typeof a.publicName&&(u.publicName=a.publicName.slice(0,60)),"string"==typeof a.publicDescription&&(u.publicDescription=a.publicDescription.slice(0,200)),"string"==typeof a.password&&(u.password=a.password.slice(0,32)),l.rooms[a.roomId]=u,await e(d,{recursive:!0}),await p(c,JSON.stringify(l,null,2),"utf-8"),{ok:!0,roomId:a.roomId,settings:u}});export{a as default};

import{d as t,a as r}from"../../../nitro/nitro.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";const e=t(async t=>{const e=(r(t).relays||"").split(",").map(t=>t.trim()).filter(t=>t.startsWith("https://")||t.startsWith("http://")).slice(0,10);if(!e.length)return{peers:[],relayRtts:{},meshRtts:{}};const o=new Map,s={},i={},a=await Promise.allSettled(e.map(async t=>{const r=new AbortController,e=setTimeout(()=>r.abort(),8e3),o=Date.now();try{const e=await fetch(`${t}/peers`,{signal:r.signal}),a=Date.now()-o;if(!e.ok)throw new Error(`HTTP ${e.status}`);const n=await e.text();if(n.length>1e5)throw new Error("Response too large");s[t]=a;const p=JSON.parse(n);if(Array.isArray(p)){const r={};for(const t of p)t.rtt&&t.rtt>0&&t.rtt<3e4&&t.url&&(r[t.url]=t.rtt);Object.keys(r).length>0&&(i[t]=r)}return p}finally{clearTimeout(e)}}));for(const t of a){if("fulfilled"!==t.status)continue;const r=t.value;if(Array.isArray(r))for(const t of r)t.url&&!o.has(t.url)&&o.set(t.url,{url:t.url,pk:t.pk||"",tracker:!!t.tracker,lastSeen:t.lastSeen||0,failures:t.failures||0})}return{peers:Array.from(o.values()),relayRtts:s,meshRtts:i}});export{e as default};

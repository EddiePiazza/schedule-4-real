import{d as t,a as r}from"../../../nitro/nitro.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";const o=t(async t=>{const o=(r(t).relays||"").split(",").map(t=>t.trim()).filter(t=>t.startsWith("https://")||t.startsWith("http://")).slice(0,10);if(!o.length)return{peers:[]};const e=new Map,s=await Promise.allSettled(o.map(async t=>{const r=new AbortController,o=setTimeout(()=>r.abort(),8e3);try{const o=await fetch(`${t}/peers`,{signal:r.signal});if(!o.ok)throw new Error(`HTTP ${o.status}`);const e=await o.text();if(e.length>1e5)throw new Error("Response too large");return JSON.parse(e)}finally{clearTimeout(o)}}));for(const t of s){if("fulfilled"!==t.status)continue;const r=t.value;if(Array.isArray(r))for(const t of r)t.url&&!e.has(t.url)&&e.set(t.url,{url:t.url,pk:t.pk||"",tracker:!!t.tracker,lastSeen:t.lastSeen||0})}return{peers:Array.from(e.values())}});export{o as default};

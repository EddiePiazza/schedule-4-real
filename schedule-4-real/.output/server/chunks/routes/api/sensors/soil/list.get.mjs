import{d as s}from"../../../../nitro/nitro.mjs";import{query as t}from"../../../../_/db.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";import"pg";const n=s(async()=>{try{const s=await t("\n      SELECT\n        sensor_id,\n        min(timestamp) as first_seen,\n        max(timestamp) as last_seen,\n        count() as reading_count\n      FROM sensors_soil\n      WHERE sensor_id != 'avg'\n      GROUP BY sensor_id\n      ORDER BY last_seen DESC\n    "),n=await t("\n      SELECT sensor_id, temp_soil, humi_soil, ec_soil, timestamp\n      FROM sensors_soil\n      WHERE sensor_id != 'avg'\n      LATEST ON timestamp PARTITION BY sensor_id\n    "),o=new Map;if(n&&Array.isArray(n))for(const s of n)o.set(s.sensor_id,{temp_soil:s.temp_soil,humi_soil:s.humi_soil,ec_soil:s.ec_soil,timestamp:s.timestamp});let r=new Map;try{const s=await t("\n        SELECT sensor_id, name, plant_id\n        FROM sensor_names\n        LATEST ON timestamp PARTITION BY sensor_id\n      ");if(s&&Array.isArray(s))for(const t of s)r.set(t.sensor_id,{name:t.name||"",plantId:t.plant_id||null})}catch{}const e=[];if(s&&Array.isArray(s))for(const t of s){const s=o.get(t.sensor_id),n=r.get(t.sensor_id),i=t.sensor_id.slice(-4).toUpperCase();e.push({id:t.sensor_id,shortId:i,name:(null==n?void 0:n.name)||"",plantId:(null==n?void 0:n.plantId)||null,firstSeen:t.first_seen,lastSeen:t.last_seen,readingCount:t.reading_count,current:s||null})}return e}catch(s){return console.error("Error fetching soil sensor list:",s.message),[]}});export{n as default};

import{d as t,a as e}from"../../../nitro/nitro.mjs";import{query as n}from"../../../_/db.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";import"pg";const o=t(async t=>{const{range:o="24h",start:s,end:r}=e(t);let i,a,m;if(s&&r)a=new Date(s),m=new Date(r),i=`timestamp >= '${a.toISOString()}' AND timestamp <= '${m.toISOString()}'`;else{const t=function(t){return{"1h":1,"4h":4,"6h":6,"12h":12,"24h":24,"48h":48,"7d":168,"30d":720,"60d":1440,"90d":2160}[t]||24}(o);a=new Date(Date.now()-60*t*60*1e3),m=new Date,i=`timestamp > dateadd('h', -${t}, now())`}try{let parseUTC=function(t){const e=t.endsWith("Z")?t:t.replace(" ","T")+"Z";return new Date(e)};const t=["O1","O2","O3","O4","O5"],e=await n(`\n      SELECT socket, is_on, timestamp\n      FROM (\n        SELECT socket, is_on, timestamp,\n               ROW_NUMBER() OVER (PARTITION BY socket ORDER BY timestamp DESC) as rn\n        FROM socket_events\n        WHERE timestamp < '${a.toISOString()}'\n          AND socket IN ('O1', 'O2', 'O3', 'O4', 'O5')\n      )\n      WHERE rn = 1\n    `),s=new Map;for(const t of e)s.set(t.socket,t.is_on);const r=await n(`\n      SELECT\n        timestamp,\n        socket,\n        is_on\n      FROM socket_events\n      WHERE ${i}\n        AND socket IN ('O1', 'O2', 'O3', 'O4', 'O5')\n      ORDER BY socket ASC, timestamp ASC\n    `),p=new Map;for(const e of t){const t=1===s.get(e);p.set(e,{socket:e,totalSeconds:0,events:t?[{start:a.toISOString(),end:null}]:[]})}const c=new Map;for(const[t,e]of s)c.set(t,e);for(const t of r){const e=t.socket,n=t.is_on,o=t.timestamp instanceof Date?t.timestamp.toISOString():t.timestamp,s=p.get(e);if(!s)continue;if(c.get(e)===n)continue;c.set(e,n);const r=o.endsWith("Z")?o:o.replace(" ","T")+"Z";if(1===n){const t=s.events[s.events.length-1];t&&null===t.end||s.events.push({start:r,end:null})}else{const t=s.events[s.events.length-1];t&&null===t.end&&(t.end=r)}}for(const[t,e]of p){let t=0;for(const n of e.events){const e=parseUTC(n.start),o=n.end?parseUTC(n.end):m,s=e<a?a:e,r=o>m?m:o;r>s&&(t+=r.getTime()-s.getTime())}e.totalSeconds=Math.round(t/1e3)}const d=Array.from(p.values()).sort((t,e)=>parseInt(t.socket.replace("O",""))-parseInt(e.socket.replace("O","")));return{range:o,rangeStart:a.toISOString(),rangeEnd:m.toISOString(),sockets:d}}catch(t){return console.error("Failed to fetch socket events:",t),{range:o,rangeStart:a.toISOString(),rangeEnd:m.toISOString(),sockets:[]}}});export{o as default};

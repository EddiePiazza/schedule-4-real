import{d as t,a as o,c as e}from"../../../nitro/nitro.mjs";import{query as r}from"../../../_/db.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";import"pg";const s=t(async t=>{var s;const{range:n="24h",flowId:i,socket:m,limit:p="100"}=o(t),a={"1h":1,"4h":4,"6h":6,"12h":12,"24h":24,"48h":48,"7d":168}[n]||24;try{let t=[`timestamp > dateadd('h', -${a}, now())`];const o=[];let e=1;i&&(t.push("flow_id = $"+e++),o.push(i)),m&&(t.push("socket = $"+e++),o.push(m));return(await r(`\n      SELECT\n        timestamp,\n        flow_id,\n        flow_name,\n        trigger_reason,\n        socket,\n        action,\n        result,\n        sensor_values\n      FROM trigger_execution_log\n      WHERE ${t.join(" AND ")}\n      ORDER BY timestamp DESC\n      LIMIT ${parseInt(p)||100}\n    `,o)).map(t=>({timestamp:t.timestamp,flowId:t.flow_id,flowName:t.flow_name,triggerReason:t.trigger_reason,socket:t.socket,action:t.action,result:t.result,sensorValues:t.sensor_values?JSON.parse(t.sensor_values):null}))}catch(t){if(null==(s=t.message)?void 0:s.includes("does not exist"))return[];throw console.error("Failed to fetch execution logs:",t),e({statusCode:500,message:"Failed to fetch execution logs"})}});export{s as default};

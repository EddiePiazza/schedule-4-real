import{d as e,c as l}from"../../../nitro/nitro.mjs";import{g as t,b as o,e as n,r as i,c as d,d as m}from"../../../_/mqtt.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";import"mqtt";import"child_process";const a=e(async()=>{var e,a,s,u,r,c,p,f,v,O,y,h,b,T,w,g,A,j,P,S,k,x,C,E,L,F,q,D,W,_,z,B,G,H,I,J,K,M;try{const l=t(),N=o(l);let Q=n(l);if(!Q||Date.now()-Q.timestamp>3e4){Q={data:await i(l),timestamp:Date.now()}}let R={},U=d(l);if(N.hasOutlets)try{if(null==(e=null==U?void 0:U.data)?void 0:e.outlet)R=U.data.outlet;else{const e=await m(["outlet"],l,5e3);R=(null==e?void 0:e.outlet)||{}}}catch(e){console.log("Could not get outlet config, using status only")}const V={};if(N.hasOutlets){const e=(null==(a=null==Q?void 0:Q.data)?void 0:a.outlet)||{};for(const[l,t]of Object.entries(e))if(l.startsWith("O")&&"object"==typeof t){const e=t,o=R[l]||{};V[l]={mOnOff:null!=(r=null!=(u=null!=(s=e.on)?s:e.mOnOff)?u:o.mOnOff)?r:0,isOn:1===(null!=(f=null!=(p=null!=(c=e.on)?c:e.mOnOff)?p:o.mOnOff)?f:0),modeType:null!=(O=null!=(v=e.modeType)?v:o.modeType)?O:0,tempAdd:o.tempAdd,humiAdd:o.humiAdd,co2Add:o.co2Add,timePeriod:o.timePeriod,cycleTime:o.cycleTime,wateringEnv:o.wateringEnv,bind:o.bind}}for(const[e,l]of Object.entries(R))if(e.startsWith("O")&&!V[e]&&"object"==typeof l){const t=l;V[e]={mOnOff:null!=(y=t.mOnOff)?y:0,isOn:1===(null!=(h=t.mOnOff)?h:0),modeType:null!=(b=t.modeType)?b:0,tempAdd:t.tempAdd,humiAdd:t.humiAdd,co2Add:t.co2Add,timePeriod:t.timePeriod,cycleTime:t.cycleTime,wateringEnv:t.wateringEnv,bind:t.bind}}}let X=null;const Y=null==(T=null==Q?void 0:Q.data)?void 0:T.blower;let Z={};if(null==(w=null==U?void 0:U.data)?void 0:w.blower)Z=U.data.blower;else try{const e=await m(["device","blower"],l,3e3);Z=(null==e?void 0:e.blower)||{}}catch{}if(Y||Object.keys(Z).length>0){const e=null!=(j=null!=(A=null!=(g=null==Y?void 0:Y.on)?g:Z.mOnOff)?A:Z.on)?j:0,l=null!=(S=null!=(P=Z.mLevel)?P:Z.level)?S:(null==Y?void 0:Y.level)>0?Y.level:50,t=null!=(k=Z.closeCO2)?k:0;X={on:1===e||!0===e,level:l,modeType:null!=(C=null!=(x=null==Y?void 0:Y.modeType)?x:Z.modeType)?C:0,closeCO2:1===t||!0===t,minSpeed:null!=(E=Z.minSpeed)?E:0,maxSpeed:null!=(L=Z.maxSpeed)?L:0,timePeriod:Z.timePeriod||[],cycleTime:Z.cycleTime||null}}let $=null;const ee=null==(F=null==Q?void 0:Q.data)?void 0:F.fan;let le={};if(N.hasFan){if(null==(q=null==U?void 0:U.data)?void 0:q.fan)le=U.data.fan;else try{const e=await m(["device","fan"],l,3e3);le=(null==e?void 0:e.fan)||{}}catch{}if(ee||Object.keys(le).length>0){const e=null!=(_=null!=(W=null!=(D=null==ee?void 0:ee.on)?D:le.mOnOff)?W:le.on)?_:0;$={on:1===e||!0===e,level:null!=(B=null!=(z=le.mLevel)?z:le.level)?B:(null==ee?void 0:ee.level)>0?ee.level:50,modeType:null!=(H=null!=(G=null==ee?void 0:ee.modeType)?G:le.modeType)?H:0,minSpeed:null!=(I=le.minSpeed)?I:0,maxSpeed:null!=(J=le.maxSpeed)?J:0,shakeLevel:null!=(K=le.shakeLevel)?K:0,natural:null!=(M=le.natural)?M:0,timePeriod:le.timePeriod||[],cycleTime:le.cycleTime||null}}}return{sockets:V,blower:X,fan:$}}catch(e){throw console.error("Failed to fetch socket states:",e),l({statusCode:500,message:"Failed to fetch socket states from device"})}});export{a as default};

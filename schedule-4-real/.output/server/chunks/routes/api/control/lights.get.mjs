import{d as e,c as t}from"../../../nitro/nitro.mjs";import{g as l,b as i,e as o,r as n,c as d,d as s,s as a}from"../../../_/mqtt.mjs";import"node:http";import"node:https";import"node:crypto";import"stream";import"events";import"http";import"crypto";import"buffer";import"zlib";import"https";import"net";import"tls";import"url";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"fs";import"path";import"fs/promises";import"node:url";import"mqtt";import"child_process";const p=e(async()=>{var e,p,m,r,f,u,c,v,h,g,y,T,O,M,L,P,B,w,A,k,x,b,C,F,I,j,q;try{const t=l(),D=i(t);let _=o(t);if(!_||Date.now()-_.timestamp>3e4){_={data:await n(t),timestamp:Date.now()}}let z={},R={};try{const l=d(t);if(null==(e=null==l?void 0:l.data)?void 0:e.device)z=l.data.device;else{const e=await s(["device"],t,5e3);z=(null==e?void 0:e.device)||{}}if(D.hasLight2)if(null==(p=null==l?void 0:l.data)?void 0:p.light2)R=l.data.light2;else try{const e=await s(["light2"],t,5e3);R=(null==e?void 0:e.light2)||{}}catch{}}catch(e){console.log("Could not get device config, using status only")}let E=null,G=null;const H=null==(m=null==_?void 0:_.data)?void 0:m.plan;if(1===(null==H?void 0:H.isPlanRun)&&(null==H?void 0:H.stageId))try{const e=d(t);let l=null==(r=null==e?void 0:e.data)?void 0:r.plan;if(!l){const e=await a({method:"getConfigField",params:{keyPath:["plan"]}},t,5e3);l=null==(f=null==e?void 0:e.data)?void 0:f.plan}if((null==l?void 0:l.stage)&&Array.isArray(l.stage)){const e=l.stage.find(e=>e.stageId===H.stageId);e&&(e.light1&&(E=e.light1),e.light2&&(G=e.light2))}}catch{}const J={},K=null==(u=null==_?void 0:_.data)?void 0:u.light,N=E||(null==z?void 0:z.light)||{};if(K||void 0!==N.modeType){const e=K||{},t=N,l=null!=(g=null!=(h=null!=(v=null!=(c=e.mOnOff)?c:e.on)?v:t.mOnOff)?h:t.on)?g:e.level>0||e.mLevel>0?1:0,i=null!=(M=null!=(O=null!=(T=null!=(y=e.level)?y:e.mLevel)?T:t.mLevel)?O:t.level)?M:0;J.light={mOnOff:l,mLevel:i,isOn:1===l,modeType:null!=(P=null!=(L=e.modeType)?L:t.modeType)?P:0,lastAutoModeType:t.lastAutoModeType,timePeriod:t.timePeriod,cycleTime:t.cycleTime,ppfdPeriod:t.ppfdPeriod,darkTemp:t.darkTemp,offTemp:t.offTemp,ppfdMinBrightness:t.ppfdMinBrightness,ppfdMaxBrightness:t.ppfdMaxBrightness}}if(D.hasLight2){const e=null==(B=null==_?void 0:_.data)?void 0:B.light2,t=G||(void 0!==R.modeType?R:(null==z?void 0:z.light2)||{});if(e||void 0!==t.modeType){const l=e||{},i=t,o=null!=(x=null!=(k=null!=(A=null!=(w=l.mOnOff)?w:l.on)?A:i.mOnOff)?k:i.on)?x:l.level>0||l.mLevel>0?1:0,n=null!=(I=null!=(F=null!=(C=null!=(b=l.level)?b:l.mLevel)?C:i.mLevel)?F:i.level)?I:0;J.light2={mOnOff:o,mLevel:n,isOn:1===o,modeType:null!=(q=null!=(j=l.modeType)?j:i.modeType)?q:0,lastAutoModeType:i.lastAutoModeType,timePeriod:i.timePeriod,cycleTime:i.cycleTime,ppfdPeriod:i.ppfdPeriod,darkTemp:i.darkTemp,offTemp:i.offTemp,ppfdMinBrightness:i.ppfdMinBrightness,ppfdMaxBrightness:i.ppfdMaxBrightness}}}return J}catch(e){throw console.error("Failed to fetch light states:",e),t({statusCode:500,message:"Failed to fetch light states from device"})}});export{p as default};

import{defineStore as e}from"pinia";import{shallowRef as i,ref as t,computed as n}from"vue";import{u as s,a as d}from"./useAuthGate-BgxmmIEE.mjs";const a=e("sensors",()=>{const e=i(null),d=i(null),a=i([]),o=i([]),h=i({}),l=t(!1),p=t("4h"),m=i([]),r=i({}),c=i({}),g=t(!1),u=i([]),y=i([]),f=n(()=>{if(e.value)return e.value.temp>30?"high":e.value.temp<18?"low":"optimal"}),T=n(()=>{if(e.value)return e.value.humi>70?"high":e.value.humi<40?"low":"optimal"}),v=n(()=>{if(e.value)return e.value.vpd>1.6?"high":e.value.vpd<.4?"low":"optimal"}),O=n(()=>{var i;return null!=(null==(i=e.value)?void 0:i.co2)&&e.value.co2>0});async function _(e,i,t){0===m.value.length&&await E();const n=m.value;if(0!==n.length)try{const s=n.map(async n=>{const s=i&&t?`start=${encodeURIComponent(i)}&end=${encodeURIComponent(t)}&sensorId=${n.id}`:`range=${e}&sensorId=${n.id}`,d=await $fetch(`/api/sensors/soil/history?${s}`);return{sensorId:n.id,data:d||[]}}),d=await Promise.all(s),a={};for(const e of d)a[e.sensorId]=e.data;c.value=a,n.length>0&&a[n[0].id]&&(o.value=a[n[0].id])}catch{}}async function E(){g.value=!0;try{const e=await $fetch("/api/sensors/soil/list");m.value=e||[];const i={};for(const e of m.value)e.current&&(i[e.id]=e.current);r.value=i}catch{}finally{g.value=!1}}return{current:e,soil:d,history:a,soilHistory:o,stats:h,loading:l,selectedRange:p,soilSensors:m,soilSensorsCurrent:r,soilSensorsHistory:c,soilSensorsLoading:g,blowerHistory:u,fanHistory:y,temperatureStatus:f,humidityStatus:T,vpdStatus:v,hasCo2Sensor:O,fetchCurrent:async function(){try{const i=await $fetch("/api/sensors/current");i&&(e.value=i)}catch{}},fetchHistory:async function(e="24h"){p.value=e;const i=0===a.value.length;i&&(l.value=!0);try{const[i,t,n]=await Promise.all([$fetch(`/api/sensors/history?range=${e}`),$fetch(`/api/sensors/blower-history?range=${e}`),$fetch(`/api/sensors/fan-history?range=${e}`)]);i&&(a.value=i),t&&(u.value=t),n&&(y.value=n),await _(e)}catch{}finally{i&&(l.value=!1)}},fetchHistoryCustomRange:async function(e,i){p.value="custom";const t=0===a.value.length;t&&(l.value=!0);try{const[t,n,s]=await Promise.all([$fetch(`/api/sensors/history?start=${encodeURIComponent(e)}&end=${encodeURIComponent(i)}`),$fetch(`/api/sensors/blower-history?start=${encodeURIComponent(e)}&end=${encodeURIComponent(i)}`),$fetch(`/api/sensors/fan-history?start=${encodeURIComponent(e)}&end=${encodeURIComponent(i)}`)]);t&&(a.value=t),n&&(u.value=n),s&&(y.value=s),await _("custom",e,i)}catch{}finally{t&&(l.value=!1)}},fetchStats:async function(e="24h"){try{const i=await $fetch(`/api/sensors/stats?range=${e}`);h.value=i||{}}catch{}},fetchSoilSensors:E,updateSoilSensorName:async function(e,i,t){try{const{getAuthHeaders:n}=s();await $fetch("/api/sensor-names",{method:"POST",headers:n(),body:{sensorId:e,name:i,plantId:t,sensorType:"soil"}}),await E()}catch(e){throw e}},updateSoilSensorCurrent:function(e,i){const t={...r.value};t[e]=i,r.value=t;const n=m.value.find(i=>i.id===e);n&&(n.lastSeen=i.timestamp),m.value.length>0&&m.value[0].id===e&&(d.value=i)}}}),o=7,h=8,l=13,p=3,m=4,r=99;function C(e){return[o,h,l,p,m].includes(e)}const c={enabled:1,weekmask:127,startTime:28800,endTime:72e3},g={weekmask:127,startTime:28800,openDur:3600,closeDur:1800,times:3},u=e("blower",{state:()=>({on:!1,level:50,modeType:0,closeCO2:!1,minSpeed:0,maxSpeed:0,timePeriod:[{...c}],cycleTime:{...g},pendingOn:!1,pendingLevel:50,pendingModeType:0,pendingCloseCO2:!1,pendingMinSpeed:0,pendingMaxSpeed:0,pendingTimePeriod:[{...c}],pendingCycleTime:{...g},loaded:!1,saving:!1,userEdited:!1}),getters:{hasChanges(){const e=JSON.stringify(this.pendingTimePeriod)!==JSON.stringify(this.timePeriod),i=JSON.stringify(this.pendingCycleTime)!==JSON.stringify(this.cycleTime);return this.pendingOn!==this.on||this.pendingLevel!==this.level||this.pendingModeType!==this.modeType||this.pendingCloseCO2!==this.closeCO2||this.pendingMinSpeed!==this.minSpeed||this.pendingMaxSpeed!==this.maxSpeed||e||i},pendingModeCategory(){return this.pendingModeType===r?4:C(this.pendingModeType)?3:this.pendingModeType}},actions:{initFromFetch(e){var i,t,n;this.on=e.on,this.level=e.level>0?e.level:this.level||50,this.modeType=e.modeType,this.closeCO2=null!=(i=e.closeCO2)&&i,this.minSpeed=null!=(t=e.minSpeed)?t:0,this.maxSpeed=null!=(n=e.maxSpeed)?n:0,this.timePeriod=e.timePeriod&&e.timePeriod.length>0?e.timePeriod.map(e=>({...e})):[{...c}],this.cycleTime=e.cycleTime?{...e.cycleTime}:{...g},this.pendingOn=e.on,this.pendingLevel=this.level,this.pendingModeType=e.modeType,this.pendingCloseCO2=this.closeCO2,this.pendingMinSpeed=this.minSpeed,this.pendingMaxSpeed=this.maxSpeed,this.pendingTimePeriod=this.timePeriod.map(e=>({...e})),this.pendingCycleTime={...this.cycleTime},this.loaded=!0,this.userEdited=!1},async fetchIfNeeded(){if(!this.loaded)try{const e=await $fetch("/api/control/blower");e&&this.initFromFetch(e)}catch{}},updateBlower(e){var i,t,n,s,d;const a=null!=(i=e.on)?i:e.mOnOff,o=null!=(t=e.level)?t:e.mLevel;if(void 0===a&&void 0===o)return;const h=void 0!==a?1===a||!0===a:void 0!==o?o>0:this.on,l=null!=(n=e.modeType)?n:this.modeType,p=void 0!==e.closeCO2?1===e.closeCO2||!0===e.closeCO2:this.closeCO2,m=null!=(s=e.minSpeed)?s:this.minSpeed,r=null!=(d=e.maxSpeed)?d:this.maxSpeed,c=e.timePeriod&&e.timePeriod.length>0?e.timePeriod.map(e=>({...e})):this.timePeriod,g=e.cycleTime?{...e.cycleTime}:this.cycleTime,u=void 0!==o&&o>0?o:this.level;this.on=h,this.level=u,this.modeType=l,this.closeCO2=p,this.minSpeed=m,this.maxSpeed=r,this.timePeriod=c,this.cycleTime=g,this.userEdited||(this.pendingOn=h,this.pendingLevel=u,this.pendingModeType=l,this.pendingCloseCO2=p,this.pendingMinSpeed=m,this.pendingMaxSpeed=r,this.pendingTimePeriod=c.map(e=>({...e})),this.pendingCycleTime={...g}),void 0!==o&&o>0&&(this.loaded=!0)},setPendingOn(e){this.pendingOn=e,this.userEdited=!0},setPendingLevel(e){this.pendingLevel=e,this.userEdited=!0},setPendingModeType(e){this.pendingModeType=e,this.userEdited=!0},setPendingCloseCO2(e){this.pendingCloseCO2=e,this.userEdited=!0},setPendingMinSpeed(e){this.pendingMinSpeed=e,this.userEdited=!0},setPendingMaxSpeed(e){this.pendingMaxSpeed=e,this.userEdited=!0},updatePendingTimePeriod(e,i,t){this.pendingTimePeriod[e]&&(this.pendingTimePeriod[e][i]=t,this.userEdited=!0)},updatePendingCycleTime(e,i){this.pendingCycleTime[e]=i,this.userEdited=!0},setPendingModeCategory(e){4===e?this.pendingModeType=r:3===e?C(this.pendingModeType)||(this.pendingModeType=o):this.pendingModeType=e,this.userEdited=!0},resetPending(){this.pendingOn=this.on,this.pendingLevel=this.level,this.pendingModeType=this.modeType,this.pendingCloseCO2=this.closeCO2,this.pendingMinSpeed=this.minSpeed,this.pendingMaxSpeed=this.maxSpeed,this.pendingTimePeriod=this.timePeriod.map(e=>({...e})),this.pendingCycleTime={...this.cycleTime},this.userEdited=!1},async save(){if(this.hasChanges){this.saving=!0;try{const{getAuthHeaders:e}=s(),i=this.pendingModeType===r,t=this.modeType===r,n=i?0:this.pendingModeType,d={on:this.pendingOn,level:this.pendingLevel,modeType:n,closeCO2:this.pendingCloseCO2,minSpeed:this.pendingMinSpeed,maxSpeed:this.pendingMaxSpeed,timePeriod:this.pendingTimePeriod,cycleTime:this.pendingCycleTime};await $fetch("/api/control/blower",{method:"POST",headers:e(),body:d}),i?await $fetch("/api/automation/blower-ai-mode",{method:"POST",headers:e(),body:{aiMode:!0}}):t&&await $fetch("/api/automation/blower-ai-mode",{method:"POST",headers:e(),body:{aiMode:!1}}),this.on=this.pendingOn,this.level=this.pendingLevel,this.modeType=this.pendingModeType,this.closeCO2=this.pendingCloseCO2,this.minSpeed=this.pendingMinSpeed,this.maxSpeed=this.pendingMaxSpeed,this.timePeriod=this.pendingTimePeriod.map(e=>({...e})),this.cycleTime={...this.pendingCycleTime},this.userEdited=!1}catch(e){throw e}finally{this.saving=!1}}},setTriggerModeFromDb(e){e&&0===this.modeType&&(this.modeType=r,this.userEdited||(this.pendingModeType=r))}}}),y={enabled:1,weekmask:127,startTime:28800,endTime:72e3},f={weekmask:127,startTime:28800,openDur:3600,closeDur:1800,times:3},T=e("fan",{state:()=>({on:!1,level:5,modeType:0,minSpeed:0,maxSpeed:0,shakeLevel:0,natural:0,timePeriod:[{...y}],cycleTime:{...f},pendingOn:!1,pendingLevel:5,pendingModeType:0,pendingMinSpeed:0,pendingMaxSpeed:0,pendingShakeLevel:0,pendingNatural:0,pendingTimePeriod:[{...y}],pendingCycleTime:{...f},loaded:!1,saving:!1,userEdited:!1}),getters:{hasChanges(){return this.pendingOn!==this.on||this.pendingLevel!==this.level||this.pendingModeType!==this.modeType||this.pendingMinSpeed!==this.minSpeed||this.pendingMaxSpeed!==this.maxSpeed||this.pendingShakeLevel!==this.shakeLevel||this.pendingNatural!==this.natural||JSON.stringify(this.pendingTimePeriod)!==JSON.stringify(this.timePeriod)||JSON.stringify(this.pendingCycleTime)!==JSON.stringify(this.cycleTime)},pendingModeCategory(){return this.pendingModeType===r?4:C(this.pendingModeType)?3:this.pendingModeType}},actions:{initFromFetch(e){var i,t,n,s;this.on=e.on,this.level=e.level>0?e.level:this.level||5,this.modeType=e.modeType,this.minSpeed=null!=(i=e.minSpeed)?i:0,this.maxSpeed=null!=(t=e.maxSpeed)?t:0,this.shakeLevel=null!=(n=e.shakeLevel)?n:0,this.natural=null!=(s=e.natural)?s:0,this.timePeriod=e.timePeriod&&e.timePeriod.length>0?e.timePeriod.map(e=>({...e})):[{...y}],this.cycleTime=e.cycleTime?{...e.cycleTime}:{...f},this.pendingOn=e.on,this.pendingLevel=this.level,this.pendingModeType=e.modeType,this.pendingMinSpeed=this.minSpeed,this.pendingMaxSpeed=this.maxSpeed,this.pendingShakeLevel=this.shakeLevel,this.pendingNatural=this.natural,this.pendingTimePeriod=this.timePeriod.map(e=>({...e})),this.pendingCycleTime={...this.cycleTime},this.loaded=!0,this.userEdited=!1},updateFan(e){var i,t,n,s,d,a,o;const h=null!=(i=e.on)?i:e.mOnOff,l=null!=(t=e.level)?t:e.mLevel;if(void 0===h&&void 0===l)return;const p=void 0!==h?1===h||!0===h:void 0!==l?l>0:this.on,m=null!=(n=e.modeType)?n:this.modeType,r=null!=(s=e.minSpeed)?s:this.minSpeed,c=null!=(d=e.maxSpeed)?d:this.maxSpeed,g=null!=(a=e.shakeLevel)?a:this.shakeLevel,u=null!=(o=e.natural)?o:this.natural,y=void 0!==l&&l>0?l:this.level,f=e.timePeriod&&e.timePeriod.length>0?e.timePeriod.map(e=>({...e})):this.timePeriod,T=e.cycleTime?{...e.cycleTime}:this.cycleTime;this.on=p,this.level=y,this.modeType=m,this.minSpeed=r,this.maxSpeed=c,this.shakeLevel=g,this.natural=u,this.timePeriod=f,this.cycleTime=T,this.userEdited||(this.pendingOn=p,this.pendingLevel=y,this.pendingModeType=m,this.pendingMinSpeed=r,this.pendingMaxSpeed=c,this.pendingShakeLevel=g,this.pendingNatural=u,this.pendingTimePeriod=f.map(e=>({...e})),this.pendingCycleTime={...T}),void 0!==l&&l>0&&(this.loaded=!0)},setPendingOn(e){this.pendingOn=e,this.userEdited=!0},setPendingLevel(e){this.pendingLevel=e,this.userEdited=!0},setPendingModeType(e){this.pendingModeType=e,this.userEdited=!0},setPendingMinSpeed(e){this.pendingMinSpeed=e,this.userEdited=!0},setPendingMaxSpeed(e){this.pendingMaxSpeed=e,this.userEdited=!0},setPendingShakeLevel(e){this.pendingShakeLevel=e,this.userEdited=!0},setPendingNatural(e){this.pendingNatural=e,this.userEdited=!0},setPendingModeCategory(e){4===e?this.pendingModeType=r:3===e?C(this.pendingModeType)||(this.pendingModeType=o):this.pendingModeType=e,this.userEdited=!0},updatePendingTimePeriod(e,i,t){this.pendingTimePeriod[e]&&(this.pendingTimePeriod[e][i]=t,this.userEdited=!0)},updatePendingCycleTime(e,i){this.pendingCycleTime[e]=i,this.userEdited=!0},resetPending(){this.pendingOn=this.on,this.pendingLevel=this.level,this.pendingModeType=this.modeType,this.pendingMinSpeed=this.minSpeed,this.pendingMaxSpeed=this.maxSpeed,this.pendingShakeLevel=this.shakeLevel,this.pendingNatural=this.natural,this.pendingTimePeriod=this.timePeriod.map(e=>({...e})),this.pendingCycleTime={...this.cycleTime},this.userEdited=!1},async save(){if(this.hasChanges){this.saving=!0;try{const{getAuthHeaders:e}=s(),i=this.pendingModeType===r,t=this.modeType===r,n=i?0:this.pendingModeType;await $fetch("/api/control/fan",{method:"POST",headers:e(),body:{on:this.pendingOn,level:this.pendingLevel,modeType:n,minSpeed:this.pendingMinSpeed,maxSpeed:this.pendingMaxSpeed,shakeLevel:this.pendingShakeLevel,natural:this.pendingNatural,timePeriod:this.pendingTimePeriod,cycleTime:this.pendingCycleTime}}),i?await $fetch("/api/automation/fan-ai-mode",{method:"POST",headers:e(),body:{aiMode:!0}}):t&&await $fetch("/api/automation/fan-ai-mode",{method:"POST",headers:e(),body:{aiMode:!1}}),this.on=this.pendingOn,this.level=this.pendingLevel,this.modeType=this.pendingModeType,this.minSpeed=this.pendingMinSpeed,this.maxSpeed=this.pendingMaxSpeed,this.shakeLevel=this.pendingShakeLevel,this.natural=this.pendingNatural,this.timePeriod=this.pendingTimePeriod.map(e=>({...e})),this.cycleTime={...this.pendingCycleTime},this.userEdited=!1}catch(e){throw e}finally{this.saving=!1}}},setTriggerModeFromDb(e){e&&0===this.modeType&&(this.modeType=r,this.userEdited||(this.pendingModeType=r))}}}),v={0:"Manual",1:"Time Slot",2:"Cycle",3:"Temperature",4:"Humidity",5:"CO2",14:"Drip"},O=e("sockets",{state:()=>({states:{},configs:{},events:null,log:[],wattage:{},lightWattage:{},wattageLoaded:!1,powerStats:null,loading:!1,loaded:!1}),getters:{activeSockets:e=>Object.entries(e.states).filter(([e,i])=>i.isOn).map(([e])=>e),getModeName:()=>e=>v[e]||"Unknown",isLight1Disabled:e=>{var i;return!!e.wattageLoaded&&-1===(null==(i=e.lightWattage.light)?void 0:i.watts)},isLight2Disabled:e=>{if(!e.wattageLoaded)return!1;const i=e.lightWattage.light2;return!i||-1===i.watts}},actions:{async fetchStates(){var e,i,t,n,s,d,a,o;this.loaded||(this.loading=!0);try{const h=await $fetch("/api/control/sockets");if(null==h?void 0:h.sockets){for(const[l,p]of Object.entries(h.sockets))this.states[l]?(this.states[l].modeType=null!=(e=p.modeType)?e:this.states[l].modeType,this.states[l].mOnOff=null!=(i=p.mOnOff)?i:this.states[l].mOnOff,this.states[l].isOn=null!=(t=p.isOn)?t:this.states[l].isOn):this.states[l]={modeType:null!=(n=p.modeType)?n:0,mOnOff:null!=(s=p.mOnOff)?s:0,isOn:null!=(d=p.isOn)&&d},this.configs[l]={modeType:null!=(a=p.modeType)?a:0,mOnOff:null!=(o=p.mOnOff)?o:0,tempAdd:p.tempAdd,humiAdd:p.humiAdd,co2Add:p.co2Add,timePeriod:p.timePeriod,cycleTime:p.cycleTime,wateringEnv:p.wateringEnv,bind:p.bind};this.loaded=!0}(null==h?void 0:h.blower)&&u().initFromFetch(h.blower),(null==h?void 0:h.fan)&&T().initFromFetch(h.fan)}catch{}finally{this.loading=!1}},async toggleSocket(e){const i=this.states[e];if(i&&0===i.modeType){try{const{requireAuth:e}=d();await e()}catch{return}try{const{getAuthHeaders:t}=s();await $fetch("/api/control/socket/toggle",{method:"POST",headers:t(),body:{socket:e,mOnOff:i.mOnOff?0:1}}),this.states[e].mOnOff=i.mOnOff?0:1,this.states[e].isOn=!i.isOn}catch{}}},async updateConfig(e,i){var t,n,d,a,o,h,l,p,m;try{const{getAuthHeaders:r}=s(),c=await $fetch("/api/settings/socket",{method:"POST",headers:r(),body:{socket:e,...i}}),g={modeType:null!=(t=c.modeType)?t:i.modeType,mOnOff:null!=(n=c.mOnOff)?n:i.mOnOff,tempAdd:null!=(d=c.tempAdd)?d:i.tempAdd,humiAdd:null!=(a=c.humiAdd)?a:i.humiAdd,co2Add:null!=(o=c.co2Add)?o:i.co2Add,timePeriod:null!=(h=c.timePeriod)?h:i.timePeriod,cycleTime:null!=(l=c.cycleTime)?l:i.cycleTime,wateringEnv:null!=(p=c.wateringEnv)?p:i.wateringEnv,bind:null!=(m=c.bind)?m:i.bind};return this.configs[e]=g,this.states[e]&&(this.states[e].modeType=g.modeType,this.states[e].mOnOff=g.mOnOff,this.states[e].isOn=1===g.mOnOff),g}catch(e){throw 409===(null==e?void 0:e.statusCode)?new Error("Save verification failed - device may not have applied changes"):e}},updateState(e,i){this.states[e]&&(this.states[e]={...this.states[e],...i})},async fetchEvents(e="24h"){try{const i=await $fetch(`/api/sockets/events?range=${e}`);this.events=i}catch{}},async fetchEventsCustomRange(e,i){try{const t=await $fetch(`/api/sockets/events?start=${encodeURIComponent(e)}&end=${encodeURIComponent(i)}`);this.events=t}catch{}},async fetchLog(e=50){try{const i=await $fetch(`/api/sockets/log?limit=${e}`);this.log=i}catch{}},async fetchWattage(){try{const e=await $fetch("/api/settings/power");this.wattage=e.sockets||{},this.lightWattage=e.lights||{}}catch{}finally{this.wattageLoaded=!0}},async saveWattage(){try{const{getAuthHeaders:e}=s();await $fetch("/api/settings/power",{method:"POST",headers:e(),body:{sockets:this.wattage,lights:this.lightWattage}})}catch(e){throw e}},async fetchPowerStats(e="24h"){try{const i=await $fetch(`/api/stats/power?range=${e}`);this.powerStats=i}catch{}}}}),S={0:"Manual",1:"Time Slot",2:"Cycle",12:"PPFD Auto"},P=e("lights",{state:()=>({states:{},configs:{},loading:!1,loaded:!1}),getters:{activeLights:e=>Object.entries(e.states).filter(([e,i])=>null==i?void 0:i.isOn).map(([e])=>e),totalBrightness:e=>{var i,t;const n=(null==(i=e.states.light)?void 0:i.isOn)?e.states.light.mLevel:0,s=(null==(t=e.states.light2)?void 0:t.isOn)?e.states.light2.mLevel:0;return n||s?Math.round((n+s)/2):0},getModeName:()=>e=>S[e]||`Mode ${e}`},actions:{async fetchStates(){var e,i,t,n,s,d,a,o,h,l,p;this.loading=!0;try{const m=await $fetch("/api/control/lights");if(m){for(const[r,c]of Object.entries(m)){this.states[r]?(this.states[r].modeType=null!=(e=c.modeType)?e:this.states[r].modeType,this.states[r].mOnOff=null!=(i=c.mOnOff)?i:this.states[r].mOnOff,this.states[r].mLevel=null!=(t=c.mLevel)?t:this.states[r].mLevel,this.states[r].isOn=null!=(n=c.isOn)?n:this.states[r].isOn):this.states[r]={modeType:null!=(s=c.modeType)?s:0,mOnOff:null!=(d=c.mOnOff)?d:0,mLevel:null!=(a=c.mLevel)?a:0,isOn:null!=(o=c.isOn)&&o};const m={modeType:null!=(p=null!=(l=c.modeType)?l:null==(h=this.configs[r])?void 0:h.modeType)?p:0,mOnOff:c.mOnOff,mLevel:c.mLevel};void 0!==c.lastAutoModeType&&(m.lastAutoModeType=c.lastAutoModeType),void 0!==c.timePeriod&&(m.timePeriod=c.timePeriod),void 0!==c.cycleTime&&(m.cycleTime=c.cycleTime),void 0!==c.ppfdPeriod&&(m.ppfdPeriod=c.ppfdPeriod),void 0!==c.darkTemp&&(m.darkTemp=c.darkTemp),void 0!==c.offTemp&&(m.offTemp=c.offTemp),void 0!==c.ppfdMinBrightness&&(m.ppfdMinBrightness=c.ppfdMinBrightness),void 0!==c.ppfdMaxBrightness&&(m.ppfdMaxBrightness=c.ppfdMaxBrightness),this.configs[r]=m}this.loaded=!0}}catch{}finally{this.loading=!1}},async setLight(e,i){var t,n,a;const{requireAuth:o}=d();await o();try{const{getAuthHeaders:d}=s(),o=await $fetch("/api/control/light",{method:"POST",headers:d(),body:{light:e,...i}}),h=null!=(t=o.modeType)?t:i.modeType,l=null!=(n=o.mOnOff)?n:i.mOnOff,p=null!=(a=o.mLevel)?a:i.mLevel;this.states[e]={modeType:h,mOnOff:l,mLevel:p,isOn:1===l},this.configs[e]&&(this.configs[e].modeType=h,this.configs[e].mOnOff=l,this.configs[e].mLevel=p)}catch(e){throw e}},async updateConfig(e,i){var t,n,d,a,o,h,l,p,m,r,c,g;try{const{getAuthHeaders:u}=s(),y=await $fetch("/api/settings/light",{method:"POST",headers:u(),body:{light:e,...i}}),f={modeType:null!=(t=y.modeType)?t:i.modeType,mOnOff:null!=(n=y.mOnOff)?n:i.mOnOff,mLevel:null!=(d=y.mLevel)?d:i.mLevel,lastAutoModeType:y.lastAutoModeType,timePeriod:null!=(a=y.timePeriod)?a:i.timePeriod,cycleTime:null!=(o=y.cycleTime)?o:i.cycleTime,ppfdPeriod:null!=(h=y.ppfdPeriod)?h:i.ppfdPeriod,darkTemp:null!=(l=y.darkTemp)?l:i.darkTemp,offTemp:null!=(p=y.offTemp)?p:i.offTemp,ppfdMinBrightness:null!=(m=y.ppfdMinBrightness)?m:i.ppfdMinBrightness,ppfdMaxBrightness:null!=(r=y.ppfdMaxBrightness)?r:i.ppfdMaxBrightness};return this.configs[e]=f,this.states[e]={modeType:f.modeType,mOnOff:null!=(c=f.mOnOff)?c:0,mLevel:null!=(g=f.mLevel)?g:0,isOn:1===f.mOnOff},f}catch(e){throw 409===(null==e?void 0:e.statusCode)?new Error("Save verification failed - device may not have applied changes"):e}},async toggleLight(e){const i=this.states[e];if(!i)return;const t=i.mOnOff?0:1,n=1===t&&0===i.mLevel?100:i.mLevel;await this.setLight(e,{modeType:i.modeType,mOnOff:t,mLevel:n})},async setBrightness(e,i){const t=this.states[e];t&&await this.setLight(e,{modeType:t.modeType,mOnOff:1,mLevel:i})},updateState(e,i){this.states[e]&&(this.states[e]={...this.states[e],...i})},updateFromWs(e){var i,t,n,s,d,a,o;for(const[h,l]of Object.entries(e)){if("object"!=typeof l)continue;const e=l,p=null!=(t=null!=(i=e.on)?i:e.mOnOff)?t:0,m=null!=(s=null!=(n=e.mLevel)?n:e.level)?s:0,r=null!=(o=null!=(a=e.modeType)?a:null==(d=this.states[h])?void 0:d.modeType)?o:0;this.states[h]?(this.states[h].mOnOff=p,this.states[h].isOn=1===p,this.states[h].mLevel=m,this.states[h].modeType=r):this.states[h]={mOnOff:p,isOn:1===p,mLevel:m,modeType:r}}}}});export{C,u as X,T as Z,O as d,r as m,a as o,P as r};

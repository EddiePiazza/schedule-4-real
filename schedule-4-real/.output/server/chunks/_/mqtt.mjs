import e from"mqtt";import{EventEmitter as t}from"events";import{existsSync as s,mkdirSync as o,writeFileSync as n,readFileSync as r}from"fs";import{dirname as i,resolve as a}from"path";import{execFile as c}from"child_process";import{b as l}from"../nitro/nitro.mjs";let d=null,u=!1,g=0;const m=new Map,p=new t;p.setMaxListeners(50);const f=new Map,v=new Map;let w=0,h=!1;function isReceivingForwardedData(){const e=Date.now()-w<1e4;return h&&!e&&(console.log("[MQTT Server] Forwarder heartbeat lost — switching to active mode (direct device commands)"),S=!1),h=e,e}let S=!1;function compareVersions(e,t){const s=(e||"0.0.0").split(".").map(Number),o=t.split(".").map(Number);for(let e=0;e<3;e++){if((s[e]||0)>(o[e]||0))return 1;if((s[e]||0)<(o[e]||0))return-1}return 0}function readLocalVersions(){try{const e=a(l(),"versions.local.json"),t=JSON.parse(r(e,"utf-8")),s={};for(const[e,o]of Object.entries(t.components||{}))s[e]=o.version;return{versions:s,autoUpdate:t.autoUpdate||!1}}catch{return{versions:{},autoUpdate:!1}}}const T=new Map;let D="allow-all",y=new Set;function getFilterConfigPath(){return a(l(),"data","mqtt-device-filter.json")}const C=new Map;function isMessageAllowed(e,t){if("allow-all"===D)return!0;e&&t&&C.set(t,e);const s=e||C.get(t)||"";return!!s&&y.has(s)}const M={ps5:"Power Strip 5",cb:"Controller Board",lc:"Light Controller"};function getMqttSources(){const e=[];for(const[t,s]of T){const o=[];for(const[e,t]of s.devices){const s=$.get(e);o.push({mac:e,type:t.type,typeName:M[t.type.toLowerCase()]||t.type.toUpperCase(),customName:(null==s?void 0:s.customName)||"",lastSeen:t.lastSeen,msgCount:t.msgCount})}e.push({uid:t,devices:o,firstSeen:s.firstSeen,lastSeen:s.lastSeen,totalMessages:s.totalMessages,blockedMessages:s.blockedMessages,allowed:isMessageAllowed(t,"")})}return e.sort((e,t)=>e.allowed!==t.allowed?e.allowed?-1:1:e.uid.localeCompare(t.uid)),e}function getDeviceFilter(){return{mode:D,allowedUids:[...y]}}function setDeviceFilter(e,t){D=e,y=new Set(t),"whitelist"===e&&(w=0);const r=getFilterConfigPath(),a=i(r);s(a)||o(a,{recursive:!0}),n(r,JSON.stringify({mode:e,allowedUids:t},null,2)),console.log(`[MQTT Filter] Updated filter: mode=${e}, allowedUids=[${t.join(", ")}]`)}const $=new Map,E=new Map,I={ps5:{hasOutlets:!0,hasLight2:!0,hasFan:!1,configKeyPaths:[["outlet"],["device"],["target"],["light2"]]},cb:{hasOutlets:!1,hasLight2:!1,hasFan:!0,configKeyPaths:[["device"],["target"]]},lc:{hasOutlets:!1,hasLight2:!1,hasFan:!1,configKeyPaths:[]}};function getDeviceCapabilities(e){var t;return null!=(t=I[e.toLowerCase()])?t:I.ps5}function getPrimaryDeviceType(){for(const[,e]of $){const t=e.deviceType.toLowerCase();if("ps5"===t||"cb"===t)return t}return b.macs.ps5?"ps5":b.macs.cb?"cb":"ps5"}let b={macs:{},userId:""},_=0;async function refreshDeviceInfo(){var e;try{const{getPool:e}=await import("./db.mjs"),t=e(),s=await t.query("\n      SELECT device_type, mac, user_id\n      FROM devices\n      LATEST ON timestamp PARTITION BY device_type\n    ");if(s.rows&&s.rows.length>0)for(const e of s.rows){const t=(e.device_type||"").toLowerCase(),s=e.mac||"",o=e.user_id||"";t&&s&&(b.macs[t]=s),o&&(b.userId=o)}}catch(t){(null==(e=t.message)?void 0:e.includes("does not exist"))||console.error("[MQTT Server] Error refreshing device info:",t.message)}_=Date.now()}const N=new Set;async function autodetectDevice(e,t,s,o){var n;if(!t)return;const r=!N.has(t),i=Date.now(),a=$.get(t);$.set(t,{mac:t,deviceType:e.toUpperCase(),customName:null==a?void 0:a.customName,connected:!0,lastSeen:i,wifiRssi:null!=(n=null!=s?s:null==a?void 0:a.wifiRssi)?n:0,firmwareVer:null!=o?o:null==a?void 0:a.firmwareVer});const c=E.get(t),l=!0;if(c&&!c.connected){const e=Math.floor((i-c.lastStateChange)/1e3);await logWifiEvent(t,"connected",null!=s?s:0,e)}if(E.set(t,{connected:l,lastStateChange:i}),r){N.add(t);const s=e.toUpperCase();b.macs[e.toLowerCase()]=t;try{const e=await import("net"),o=parseInt(process.env.QUESTDB_ILP_PORT||"9009"),n=process.env.QUESTDB_HOST||"127.0.0.1",r=BigInt(i)*BigInt("1000000"),a=r,c=`devices,device_type=${s} mac="${t}",user_id="${b.userId||""}",first_seen=${a}i,last_seen=${r}i ${r}\n`,l=new e.Socket;l.connect(o,n,()=>{l.write(c,()=>{l.destroy()})}),l.on("error",()=>{l.destroy()}),console.log(`[MQTT Server] Device autodetected: ${s} MAC=${t}`)}catch(e){console.error("[MQTT Server] Error writing device to DB:",e.message)}setTimeout(()=>{(async function(e="ps5"){var t;const s=getDeviceCapabilities(e),o=s.configKeyPaths,n={};await Promise.all(o.map(async t=>{try{const s={method:"getConfigField",params:{keyPath:t}},o=await sendCommandAndWait(s,e,5e3);(null==o?void 0:o.data)&&Object.assign(n,o.data)}catch(e){console.log(`[MQTT Server] Config fetch skipped for ${t.join("/")} (device offline or timeout)`)}}));const r=(null==(t=v.get(e))?void 0:t.data)||{};return v.set(e,{data:{...r,...n},timestamp:Date.now()}),n})(e).catch(()=>{})},1e3)}}async function logWifiEvent(e,t,s,o=0){try{const n=await import("net"),r=parseInt(process.env.QUESTDB_ILP_PORT||"9009"),i=process.env.QUESTDB_HOST||"127.0.0.1",a=`device_wifi_events,mac=${e},event_type=${t} rssi=${s}i,duration_seconds=${o}i ${BigInt(Date.now())*BigInt("1000000")}\n`,c=new n.Socket;c.connect(r,i,()=>{c.write(a,()=>{c.destroy()})}),c.on("error",()=>{c.destroy()}),console.log(`[MQTT Server] WiFi event: ${e} ${t} rssi=${s} duration=${o}s`)}catch(e){console.error("[MQTT Server] Error logging WiFi event:",e.message)}}function getDeviceInfo(){return Date.now()-_>1e4&&refreshDeviceInfo(),{...b,ps5Mac:b.macs.ps5||"",lcMac:b.macs.lc||""}}function getMqttClient(){if(d&&u)return d;const t=`mqtt://${process.env.MQTT_HOST||"127.0.0.1"}:${process.env.MQTT_PORT||1883}`;d=e.connect(t,{clientId:`s4r-server-${Date.now()}`,clean:!0,reconnectPeriod:5e3,connectTimeout:1e4});const o=new WeakSet,patchStream=()=>{(null==d?void 0:d.stream)&&!o.has(d.stream)&&(o.add(d.stream),d.stream.on("error",e=>{"EPIPE"!==e.code&&"ECONNRESET"!==e.code&&"ECONNREFUSED"!==e.code&&console.error("[MQTT Server] Stream error:",e.message)}))};return patchStream(),process.__mqttEpipeHandlerInstalled||(process.__mqttEpipeHandlerInstalled=!0,process.on("unhandledRejection",e=>{"EPIPE"!==(null==e?void 0:e.code)&&"ECONNRESET"!==(null==e?void 0:e.code)&&"ECONNREFUSED"!==(null==e?void 0:e.code)&&console.error("[unhandledRejection]",e)})),d.on("connect",()=>{u=!0,console.log("[MQTT Server] Connected"),patchStream(),refreshDeviceInfo(),async function(){var e;try{const{getPool:e}=await import("./db.mjs"),t=e(),s=await t.query("\n      SELECT mac, custom_name\n      FROM device_names\n      LATEST ON timestamp PARTITION BY mac\n    ");if(s.rows)for(const e of s.rows){const t=$.get(e.mac);t&&(t.customName=e.custom_name)}}catch(t){(null==(e=t.message)?void 0:e.includes("does not exist"))||console.error("[MQTT Server] Error loading device names:",t.message)}}(),function(){try{const e=getFilterConfigPath();if(s(e)){const t=JSON.parse(r(e,"utf-8"));D="whitelist"===t.mode?"whitelist":"allow-all",y=new Set(t.allowedUids||[]),console.log(`[MQTT Filter] Loaded filter: mode=${D}, allowedUids=[${[...y].join(", ")}]`)}}catch(e){console.log("[MQTT Filter] No filter config found, using allow-all")}}(),null==d||d.subscribe("ggs/+/+/status",{qos:0}),null==d||d.subscribe("ggs/+/+/config",{qos:0}),null==d||d.subscribe("ggs/+/+/system",{qos:0}),null==d||d.subscribe("ggs/+/+/events",{qos:0}),null==d||d.subscribe("ggs/_source/heartbeat",{qos:0}),import("./ha-bridge.mjs").then(e=>e.initHaBridge(d)).catch(()=>{})}),d.on("message",(e,t)=>{var s,o,n;try{if("ggs/_source/heartbeat"===e){if("whitelist"!==D){const e=isReceivingForwardedData();w=Date.now(),e||console.log("[MQTT Server] Forwarder heartbeat detected — entering passive mode (no device commands)")}try{const e=JSON.parse(t.toString());e.versions&&!S&&(S=!0,function(e){const{versions:t,autoUpdate:s}=readLocalVersions(),o=[];for(const[s,n]of Object.entries(e)){const e=t[s]||"0.0.0";compareVersions(n,e)>0&&o.push(`${s}: ${e} → ${n}`)}o.length>0?(console.log(`[VersionSync] Remote server is ahead on: ${o.join(", ")}`),s?(console.log("[VersionSync] Auto-update enabled, triggering update check..."),c("node",["-e",'const uc=require("./src/services/update-checker.cjs");uc.checkForUpdates({autoApply:true}).then(()=>process.exit(0)).catch(()=>process.exit(1))'],{cwd:l(),timeout:3e5},e=>{e?console.error("[VersionSync] Update check failed:",e):console.log("[VersionSync] Update check completed")})):console.log("[VersionSync] Auto-update disabled, skipping")):console.log("[VersionSync] All versions in sync with remote server")}(e.versions),d&&function(e){const{versions:t,autoUpdate:s}=readLocalVersions();e.publish("ggs/_source/versions",JSON.stringify({versions:t,autoUpdate:s}),{qos:0})}(d))}catch{}return}if(e.startsWith("ggs/ha/")&&e.endsWith("/set"))return void import("./ha-bridge.mjs").then(s=>s.handleHaCommand(e,t.toString())).catch(()=>{});const r=JSON.parse(t.toString()),i=e.split("/"),a=i[1],u=i[2],g=i[3],h=r.uid||(null==(s=r.data)?void 0:s.uid)||"";h&&u&&a&&function(e,t,s){let o=T.get(e);o||(o={uid:e,devices:new Map,firstSeen:Date.now(),lastSeen:Date.now(),totalMessages:0,blockedMessages:0},T.set(e,o),console.log(`[MQTT Filter] New data source detected: UID=${e} device=${s}/${t}`)),o.lastSeen=Date.now(),o.totalMessages++;const n=o.devices.get(t);n?(n.lastSeen=Date.now(),n.msgCount++):o.devices.set(t,{type:s,lastSeen:Date.now(),msgCount:1})}(h,u,a);const y=r.msgId;if(y&&m.has(y)){const e=m.get(y);return clearTimeout(e.timeout),m.delete(y),void e.resolve(r)}if(!isMessageAllowed(h,u)){const e=h||C.get(u)||"";if(e){const t=T.get(e);t&&t.blockedMessages++}return}const M={timestamp:Date.now(),topic:e,deviceType:a||"",mac:u||"",payload:r};if(p.emit("mqtt-raw",M),u&&a){h&&!b.userId&&(b.userId=h);const e=r.data||r;let t,s;"system"===g&&e.sys&&(t=null==(o=e.sys.wifi)?void 0:o.rssi,s=e.sys.ver,p.emit("device",{mac:u,deviceType:a.toUpperCase(),wifiRssi:t,firmwareVer:s,connected:!0,lastSeen:Date.now()})),autodetectDevice(a,u,t,s)}if("status"===g){const e=r.data||r;if(f.set(a,{data:e,timestamp:Date.now()}),e.sensor&&p.emit("sensor",e.sensor),e.outlet&&p.emit("outlet",e.outlet),e.light||e.light2){const t={};e.light&&(t.light=e.light),e.light2&&(t.light2=e.light2),p.emit("light",t)}e.sensors&&p.emit("soil",e.sensors),e.blower&&p.emit("blower",e.blower),e.fan&&p.emit("fan",e.fan)}if("config"===g){const e=r.data||r,t={...(null==(n=v.get(a))?void 0:n.data)||{},...e};v.set(a,{data:t,timestamp:Date.now()})}}catch(e){}}),d.on("error",e=>{"EPIPE"!==e.code&&"ECONNRESET"!==e.code&&(console.error("[MQTT Server] Error:",e.message),u=!1)}),d.on("close",()=>{u=!1}),d.on("reconnect",patchStream),d}function getLastDeviceStatus(e="ps5"){const t=f.get(e);return t||null}async function requestDeviceStatus(e="ps5",t=5e3){const s=f.get(e),o=getMqttClient();return new Promise((n,r)=>{const i=`req-${Date.now()}`;if(s&&Date.now()-s.timestamp<1e4)return void n(s.data);const a=setTimeout(()=>{m.delete(i);const t=f.get(e);t?n(t.data):r(new Error("Device status request timeout"))},t);m.set(i,{resolve:n,reject:r,timeout:a});const c={method:"getDevSta",requestId:i};o.publish("ggs/command",JSON.stringify(c))})}async function sendCommand(e,t="ps5",s=5e3){const o=getMqttClient(),{macs:n,userId:r}=getDeviceInfo(),i=n[t.toLowerCase()]||"",a=i.toUpperCase(),c={...e,pid:e.pid||a,msgId:e.msgId||`${Date.now()}${++g}`,uid:e.uid||r,UTC:e.UTC||Math.floor(Date.now()/1e3)},l=isReceivingForwardedData()?`ggs/_relay/cmd/${t}/${i}`:`ggs/${t}/${i}/cmd`;return new Promise((e,t)=>{const onConnect=()=>{console.log(`[MQTT Server] Sending command to ${l}:`,JSON.stringify(c)),o.publish(l,JSON.stringify(c),s=>{s?t(new Error("Failed to send command")):e({success:!0,msgId:c.msgId})})};u?onConnect():(o.once("connect",onConnect),setTimeout(()=>{o.removeListener("connect",onConnect),t(new Error("MQTT connection timeout"))},s))})}async function sendCommandAndWait(e,t="ps5",s=5e3){const o=getMqttClient(),{macs:n,userId:r}=getDeviceInfo(),i=n[t.toLowerCase()]||"",a=i.toUpperCase(),c=`${Date.now()}${++g}`,l=isReceivingForwardedData(),d={...e,pid:e.pid||a,msgId:c,uid:e.uid||r,UTC:Math.floor(Date.now()/1e3)},u=l?`ggs/_relay/cmd/${t}/${i}`:`ggs/${t}/${i}/cmd`,p=l?Math.max(s,1e4):s;return new Promise((e,t)=>{const s=setTimeout(()=>{m.delete(c),t(new Error("Command response timeout"))},p);m.set(c,{resolve:e,reject:t,timeout:s}),console.log(`[MQTT Server] Sending command to ${u}:`,JSON.stringify(d)),o.publish(u,JSON.stringify(d),e=>{e&&(clearTimeout(s),m.delete(c),t(new Error("Failed to send command")))})})}async function getDeviceConfig(e,t="ps5",s=5e3){const o=v.get(t);if(o&&Date.now()-o.timestamp<3e4)return o.data;const n={method:"getConfigField",params:{keyPath:e}};try{return(await sendCommandAndWait(n,t,s)).data}catch(e){if(o)return o.data;throw e}}function getLastDeviceConfig(e="ps5"){return v.get(e)||null}function updateDeviceConfigCache(e,t){var s;const o=(null==(s=v.get(e))?void 0:s.data)||{};v.set(e,{data:{...o,...t},timestamp:Date.now()})}function getDeviceInfoCache(){return b}async function getDeviceInfoAsync(){return await refreshDeviceInfo(),{...b,ps5Mac:b.macs.ps5||"",lcMac:b.macs.lc||""}}function getAllDevices(){const e=Date.now(),t=[];for(const[s,o]of $){const n=o.connected,r=e-o.lastSeen<6e4;n&&!r&&(o.connected=!1,E.set(s,{connected:!1,lastStateChange:e}),logWifiEvent(s,"disconnected",o.wifiRssi,0).catch(()=>{})),t.push({...o,connected:r})}return t}function getDeviceByMac(e){const t=$.get(e);if(!t)return null;const s=Date.now();return{...t,connected:s-t.lastSeen<6e4}}async function updateDeviceName(e,t){const s=$.get(e);if(!s)return!1;s.customName=t,$.set(e,s);try{const s=await import("net"),o=parseInt(process.env.QUESTDB_ILP_PORT||"9009"),n=process.env.QUESTDB_HOST||"127.0.0.1",r=BigInt(Date.now())*BigInt("1000000"),i=`device_names mac="${e}",custom_name="${t.replace(/"/g,'\\"')}" ${r}\n`,a=new s.Socket;return a.connect(o,n,()=>{a.write(i,()=>{a.destroy()})}),a.on("error",()=>{a.destroy()}),console.log(`[MQTT Server] Device name updated: ${e} -> ${t}`),!0}catch(e){return console.error("[MQTT Server] Error saving device name:",e.message),!1}}export{sendCommand as a,getDeviceCapabilities as b,getLastDeviceConfig as c,getDeviceConfig as d,getLastDeviceStatus as e,getAllDevices as f,getPrimaryDeviceType as g,getDeviceByMac as h,updateDeviceName as i,getDeviceInfoAsync as j,getDeviceInfoCache as k,getMqttSources as l,p as m,getDeviceFilter as n,setDeviceFilter as o,getMqttClient as p,requestDeviceStatus as r,sendCommandAndWait as s,updateDeviceConfigCache as u};
